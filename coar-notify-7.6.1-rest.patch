diff --git a/docker-compose.yml b/docker-compose.yml
index 6c16150407..7f036357c9 100644
--- a/docker-compose.yml
+++ b/docker-compose.yml
@@ -121,6 +121,10 @@ services:
       cp -r /opt/solr/server/solr/configsets/search/* search
       precreate-core statistics /opt/solr/server/solr/configsets/statistics
       cp -r /opt/solr/server/solr/configsets/statistics/* statistics
+      precreate-core qaevent /opt/solr/server/solr/configsets/qaevent
+      cp -r /opt/solr/server/solr/configsets/qaevent/* qaevent
+      precreate-core suggestion /opt/solr/server/solr/configsets/suggestion
+      cp -r /opt/solr/server/solr/configsets/suggestion/* suggestion
       exec solr -f
 volumes:
   assetstore:
diff --git a/dspace-api/pom.xml b/dspace-api/pom.xml
index 97ff29e5c5..c9ed7797d5 100644
--- a/dspace-api/pom.xml
+++ b/dspace-api/pom.xml
@@ -821,6 +821,19 @@
             <groupId>eu.openaire</groupId>
             <artifactId>funders-model</artifactId>
             <version>2.0.0</version>
+            <exclusions>
+                <!-- Newer version pulled in via Jersey below -->
+                <exclusion>
+                    <groupId>org.javassist</groupId>
+                    <artifactId>javassist</artifactId>
+                </exclusion>
+            </exclusions>
+        </dependency>
+
+        <dependency>
+            <groupId>eu.openaire</groupId>
+            <artifactId>broker-client</artifactId>
+            <version>1.1.2</version>
         </dependency>
 
         <dependency>
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/ItemFilter.java b/dspace-api/src/main/java/org/dspace/app/ldn/ItemFilter.java
new file mode 100644
index 0000000000..44dd5389d3
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/ItemFilter.java
@@ -0,0 +1,30 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+/**
+ * model class for the item filters configured into item-filters.xml
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class ItemFilter {
+
+    private String id;
+
+    public ItemFilter(String id) {
+        this.id = id;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/LDNMessageConsumer.java b/dspace-api/src/main/java/org/dspace/app/ldn/LDNMessageConsumer.java
new file mode 100644
index 0000000000..210aaa6c9c
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/LDNMessageConsumer.java
@@ -0,0 +1,243 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+import static java.lang.String.format;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.UUID;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.JsonMappingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.commons.collections4.CollectionUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.app.ldn.factory.NotifyServiceFactory;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.ldn.service.NotifyPatternToTriggerService;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.content.Bitstream;
+import org.dspace.content.BitstreamFormat;
+import org.dspace.content.Bundle;
+import org.dspace.content.Item;
+import org.dspace.content.MetadataValue;
+import org.dspace.content.factory.ContentServiceFactory;
+import org.dspace.content.logic.LogicalStatement;
+import org.dspace.content.service.BitstreamService;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Constants;
+import org.dspace.core.Context;
+import org.dspace.core.I18nUtil;
+import org.dspace.core.LDN;
+import org.dspace.event.Consumer;
+import org.dspace.event.Event;
+import org.dspace.services.ConfigurationService;
+import org.dspace.services.factory.DSpaceServicesFactory;
+import org.dspace.utils.DSpace;
+import org.dspace.web.ContextUtil;
+
+/**
+ * class for creating a new LDN Messages of installed item
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class LDNMessageConsumer implements Consumer {
+
+    private NotifyPatternToTriggerService notifyPatternToTriggerService;
+    private NotifyServiceInboundPatternService inboundPatternService;
+    private LDNMessageService ldnMessageService;
+    private ConfigurationService configurationService;
+    private ItemService itemService;
+    private BitstreamService bitstreamService;
+
+    @Override
+    public void initialize() throws Exception {
+        notifyPatternToTriggerService = NotifyServiceFactory.getInstance().getNotifyPatternToTriggerService();
+        ldnMessageService = NotifyServiceFactory.getInstance().getLDNMessageService();
+        configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();
+        itemService = ContentServiceFactory.getInstance().getItemService();
+        bitstreamService = ContentServiceFactory.getInstance().getBitstreamService();
+        inboundPatternService = NotifyServiceFactory.getInstance().getNotifyServiceInboundPatternService();
+    }
+
+    @Override
+    public void consume(Context context, Event event) throws Exception {
+
+        if (event.getSubjectType() != Constants.ITEM ||
+            event.getEventType() != Event.INSTALL) {
+            return;
+        }
+
+        Item item = (Item) event.getSubject(context);
+        createManualLDNMessages(context, item);
+        createAutomaticLDNMessages(context, item);
+    }
+
+    private void createManualLDNMessages(Context context, Item item) throws SQLException, JsonProcessingException {
+        List<NotifyPatternToTrigger> patternsToTrigger =
+            notifyPatternToTriggerService.findByItem(context, item);
+
+        for (NotifyPatternToTrigger patternToTrigger : patternsToTrigger) {
+            createLDNMessage(context,patternToTrigger.getItem(),
+                patternToTrigger.getNotifyService(), patternToTrigger.getPattern());
+        }
+    }
+
+    private void createAutomaticLDNMessages(Context context, Item item) throws SQLException, JsonProcessingException {
+
+        List<NotifyServiceInboundPattern> inboundPatterns = inboundPatternService.findAutomaticPatterns(context);
+
+        for (NotifyServiceInboundPattern inboundPattern : inboundPatterns) {
+            if (StringUtils.isEmpty(inboundPattern.getConstraint()) ||
+                evaluateFilter(context, item, inboundPattern.getConstraint())) {
+                createLDNMessage(context, item, inboundPattern.getNotifyService(), inboundPattern.getPattern());
+            }
+        }
+    }
+
+    private boolean evaluateFilter(Context context, Item item, String constraint) {
+        LogicalStatement filter =
+            new DSpace().getServiceManager().getServiceByName(constraint, LogicalStatement.class);
+
+        return filter != null && filter.getResult(context, item);
+    }
+
+    private void createLDNMessage(Context context, Item item, NotifyServiceEntity service, String pattern)
+        throws SQLException, JsonMappingException, JsonProcessingException {
+
+        LDN ldn = getLDNMessage(pattern);
+        LDNMessageEntity ldnMessage =
+            ldnMessageService.create(context, format("urn:uuid:%s", UUID.randomUUID()));
+
+        ldnMessage.setObject(item);
+        ldnMessage.setTarget(service);
+        ldnMessage.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_QUEUED);
+        ldnMessage.setQueueTimeout(new Date());
+
+        appendGeneratedMessage(ldn, ldnMessage, pattern);
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(ldnMessage.getMessage(), Notification.class);
+        ldnMessage.setType(StringUtils.joinWith(",", notification.getType()));
+
+        ArrayList<String> notificationTypeArrayList = new ArrayList<String>(notification.getType());
+        // sorting the list
+        Collections.sort(notificationTypeArrayList);
+        ldnMessage.setActivityStreamType(notificationTypeArrayList.get(0));
+        ldnMessage.setCoarNotifyType(notificationTypeArrayList.get(1));
+
+        ldnMessageService.update(context, ldnMessage);
+    }
+
+    private LDN getLDNMessage(String pattern) {
+        try {
+            return LDN.getLDNMessage(I18nUtil.getLDNFilename(Locale.getDefault(), pattern));
+        } catch (IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private void appendGeneratedMessage(LDN ldn, LDNMessageEntity ldnMessage, String pattern) {
+        Item item = (Item) ldnMessage.getObject();
+        ldn.addArgument(getUiUrl());
+        ldn.addArgument(configurationService.getProperty("ldn.notify.inbox"));
+        ldn.addArgument(configurationService.getProperty("dspace.name"));
+        ldn.addArgument(Objects.requireNonNullElse(ldnMessage.getTarget().getUrl(), ""));
+        ldn.addArgument(Objects.requireNonNullElse(ldnMessage.getTarget().getLdnUrl(), ""));
+        ldn.addArgument(getUiUrl() + "/handle/" + ldnMessage.getObject().getHandle());
+        ldn.addArgument(getIdentifierUri(item));
+        ldn.addArgument(generateBitstreamDownloadUrl(item));
+        ldn.addArgument(getBitstreamMimeType(findPrimaryBitstream(item)));
+        ldn.addArgument(ldnMessage.getID());
+        ldn.addArgument(getRelationUri(item));
+        ldn.addArgument("http://purl.org/vocab/frbr/core#supplement");
+        ldn.addArgument(format("urn:uuid:%s", UUID.randomUUID()));
+
+        ldnMessage.setMessage(ldn.generateLDNMessage());
+    }
+
+    private String getUiUrl() {
+        return configurationService.getProperty("dspace.ui.url");
+    }
+
+    private String getIdentifierUri(Item item) {
+        return itemService.getMetadataByMetadataString(item, "dc.identifier.uri")
+                          .stream()
+                          .findFirst()
+                          .map(MetadataValue::getValue)
+                          .orElse("");
+    }
+
+    private String getRelationUri(Item item) {
+        String relationMetadata = configurationService.getProperty("ldn.notify.relation.metadata", "dc.relation");
+        return itemService.getMetadataByMetadataString(item, relationMetadata)
+                          .stream()
+                          .findFirst()
+                          .map(MetadataValue::getValue)
+                          .orElse("");
+    }
+
+    private String generateBitstreamDownloadUrl(Item item) {
+        String uiUrl = getUiUrl();
+        return findPrimaryBitstream(item)
+            .map(bs -> uiUrl + "/bitstreams/" + bs.getID() + "/download")
+            .orElse("");
+    }
+
+    private Optional<Bitstream> findPrimaryBitstream(Item item) {
+        List<Bundle> bundles = item.getBundles(Constants.CONTENT_BUNDLE_NAME);
+        return bundles.stream()
+                      .findFirst()
+                      .map(Bundle::getPrimaryBitstream)
+                      .or(() -> bundles.stream()
+                                       .findFirst()
+                                       .flatMap(bundle -> CollectionUtils.isNotEmpty(bundle.getBitstreams())
+                                           ? Optional.of(bundle.getBitstreams().get(0))
+                                           : Optional.empty()));
+    }
+
+    private String getBitstreamMimeType(Optional<Bitstream> bitstream) {
+        return bitstream.map(bs -> {
+            try {
+                Context context = ContextUtil.obtainCurrentRequestContext();
+                BitstreamFormat bitstreamFormat = bs.getFormat(context);
+                if (bitstreamFormat.getShortDescription().equals("Unknown")) {
+                    return getUserFormatMimeType(bs);
+                }
+                return bitstreamFormat.getMIMEType();
+            } catch (SQLException e) {
+                throw new RuntimeException(e);
+            }
+        }).orElse("");
+    }
+
+    private String getUserFormatMimeType(Bitstream bitstream) {
+        return bitstreamService.getMetadataFirstValue(bitstream,
+            "dc", "format", "mimetype", Item.ANY);
+    }
+
+    @Override
+    public void end(Context ctx) throws Exception {
+
+    }
+
+    @Override
+    public void finish(Context ctx) throws Exception {
+
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/LDNMessageEntity.java b/dspace-api/src/main/java/org/dspace/app/ldn/LDNMessageEntity.java
new file mode 100644
index 0000000000..9fd63e62e4
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/LDNMessageEntity.java
@@ -0,0 +1,319 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+import java.lang.reflect.Field;
+import java.util.Date;
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.Id;
+import javax.persistence.JoinColumn;
+import javax.persistence.ManyToOne;
+import javax.persistence.Table;
+import javax.persistence.Temporal;
+import javax.persistence.TemporalType;
+
+import org.dspace.content.DSpaceObject;
+import org.dspace.core.ReloadableEntity;
+
+/**
+ * Class representing ldnMessages stored in the DSpace system and, when locally resolvable,
+ * some information are stored as dedicated attributes.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@Entity
+@Table(name = "ldn_message")
+public class LDNMessageEntity implements ReloadableEntity<String> {
+
+    /**
+     * LDN messages interact with a fictitious queue. Scheduled tasks manage the queue.
+     */
+
+    /*
+     * Notification Type constants
+     */
+    public static final String TYPE_INCOMING = "Incoming";
+    public static final String TYPE_OUTGOING = "Outgoing";
+
+    /**
+     * Message must not be processed.
+     */
+    public static final Integer QUEUE_STATUS_UNTRUSTED_IP = 0;
+
+    /**
+    * Message queued, it has to be elaborated.
+    */
+    public static final Integer QUEUE_STATUS_QUEUED = 1;
+
+    /**
+     * Message has been taken from the queue and it's elaboration is in progress.
+     */
+    public static final Integer QUEUE_STATUS_PROCESSING = 2;
+
+    /**
+     * Message has been correctly elaborated.
+     */
+    public static final Integer QUEUE_STATUS_PROCESSED = 3;
+
+    /**
+     * Message has not been correctly elaborated - despite more than "ldn.processor.max.attempts" retryies
+     */
+    public static final Integer QUEUE_STATUS_FAILED = 4;
+
+    /**
+     * Message must not be processed
+     */
+    public static final Integer QUEUE_STATUS_UNTRUSTED = 5;
+
+    /**
+     * Message is not processed since action is not mapped
+     */
+    public static final Integer QUEUE_STATUS_UNMAPPED_ACTION = 6;
+
+    /**
+     * Message queued for retry, it has to be elaborated.
+     */
+    public static final Integer QUEUE_STATUS_QUEUED_FOR_RETRY = 7;
+
+    @Id
+    private String id;
+
+    @ManyToOne
+    @JoinColumn(name = "object", referencedColumnName = "uuid")
+    private DSpaceObject object;
+
+    @Column(name = "message", nullable = false, columnDefinition = "text")
+    private String message;
+
+    @Column(name = "type")
+    private String type;
+
+    @Column(name = "queue_status")
+    private Integer queueStatus;
+
+    @Column(name = "queue_attempts")
+    private Integer queueAttempts = 0;
+
+    @Temporal(TemporalType.TIMESTAMP)
+    @Column(name = "queue_last_start_time")
+    private Date queueLastStartTime = null;
+
+    @Temporal(TemporalType.TIMESTAMP)
+    @Column(name = "queue_timeout")
+    private Date queueTimeout = null;
+
+    @ManyToOne
+    @JoinColumn(name = "origin", referencedColumnName = "id")
+    private NotifyServiceEntity origin;
+
+    @ManyToOne
+    @JoinColumn(name = "target", referencedColumnName = "id")
+    private NotifyServiceEntity target;
+
+    @ManyToOne
+    @JoinColumn(name = "inReplyTo", referencedColumnName = "id")
+    private LDNMessageEntity inReplyTo;
+
+    @ManyToOne
+    @JoinColumn(name = "context", referencedColumnName = "uuid")
+    private DSpaceObject context;
+
+    @Column(name = "activity_stream_type")
+    private String activityStreamType;
+
+    @Column(name = "coar_notify_type")
+    private String coarNotifyType;
+
+    @Column(name = "source_ip")
+    private String sourceIp;
+
+    protected LDNMessageEntity() {
+
+    }
+
+    public LDNMessageEntity(String id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getID() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    /**
+     * 
+     * @return the DSpace item related to this message
+     */
+    public DSpaceObject getObject() {
+        return object;
+    }
+
+    public void setObject(DSpaceObject object) {
+        this.object = object;
+    }
+
+    public String getMessage() {
+        return message;
+    }
+
+    public void setMessage(String message) {
+        this.message = message;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    public void setType(String type) {
+        this.type = type;
+    }
+
+    public String getActivityStreamType() {
+        return activityStreamType;
+    }
+
+    public void setActivityStreamType(String activityStreamType) {
+        this.activityStreamType = activityStreamType;
+    }
+
+    public String getCoarNotifyType() {
+        return coarNotifyType;
+    }
+
+    public void setCoarNotifyType(String coarNotifyType) {
+        this.coarNotifyType = coarNotifyType;
+    }
+
+    /**
+     * 
+     * @return The originator of the activity, typically the service responsible for sending the notification
+     */
+    public NotifyServiceEntity getOrigin() {
+        return origin;
+    }
+
+    public void setOrigin(NotifyServiceEntity origin) {
+        this.origin = origin;
+    }
+
+    /**
+     * 
+     * @return The intended destination of the activity, typically the service which consumes the notification
+     */
+    public NotifyServiceEntity getTarget() {
+        return target;
+    }
+
+    public void setTarget(NotifyServiceEntity target) {
+        this.target = target;
+    }
+
+    /**
+     * 
+     * @return This property is used when the notification is a direct response to a previous notification;
+     * contains an {@link org.dspace.app.ldn.LDNMessageEntity#inReplyTo id}
+     */
+    public LDNMessageEntity getInReplyTo() {
+        return inReplyTo;
+    }
+
+    public void setInReplyTo(LDNMessageEntity inReplyTo) {
+        this.inReplyTo = inReplyTo;
+    }
+
+    /**
+     * 
+     * @return This identifies another resource which is relevant to understanding the notification
+     */
+    public DSpaceObject getContext() {
+        return context;
+    }
+
+    public void setContext(DSpaceObject context) {
+        this.context = context;
+    }
+
+    public Integer getQueueStatus() {
+        return queueStatus;
+    }
+
+    public void setQueueStatus(Integer queueStatus) {
+        this.queueStatus = queueStatus;
+    }
+
+    public Integer getQueueAttempts() {
+        return queueAttempts;
+    }
+
+    public void setQueueAttempts(Integer queueAttempts) {
+        this.queueAttempts = queueAttempts;
+    }
+
+    public Date getQueueLastStartTime() {
+        return queueLastStartTime;
+    }
+
+    public void setQueueLastStartTime(Date queueLastStartTime) {
+        this.queueLastStartTime = queueLastStartTime;
+    }
+
+    public Date getQueueTimeout() {
+        return queueTimeout;
+    }
+
+    public void setQueueTimeout(Date queueTimeout) {
+        this.queueTimeout = queueTimeout;
+    }
+
+    public String getSourceIp() {
+        return sourceIp;
+    }
+
+    public void setSourceIp(String sourceIp) {
+        this.sourceIp = sourceIp;
+    }
+
+    @Override
+    public String toString() {
+        return "LDNMessage id:" + this.getID() + " typed:" + this.getType();
+    }
+
+    public static String getNotificationType(LDNMessageEntity ldnMessage) {
+        if (ldnMessage.getInReplyTo() != null || ldnMessage.getOrigin() != null) {
+            return TYPE_INCOMING;
+        }
+        return TYPE_OUTGOING;
+    }
+
+    public static String getServiceNameForNotifyServ(NotifyServiceEntity serviceEntity) {
+        if (serviceEntity != null) {
+            return serviceEntity.getName();
+        }
+        return "self";
+    }
+
+    public static String getQueueStatus(LDNMessageEntity ldnMessage) {
+        Class<LDNMessageEntity> cl = LDNMessageEntity.class;
+        try {
+            for (Field f : cl.getDeclaredFields()) {
+                String fieldName = f.getName();
+                if (fieldName.startsWith("QUEUE_") && (f.get(null) == ldnMessage.getQueueStatus())) {
+                    return fieldName;
+                }
+            }
+        } catch (IllegalArgumentException | IllegalAccessException e) {
+            throw new RuntimeException(e);
+        }
+        return null;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/LDNMessageQueueStatus.java b/dspace-api/src/main/java/org/dspace/app/ldn/LDNMessageQueueStatus.java
new file mode 100644
index 0000000000..ad3dd36e69
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/LDNMessageQueueStatus.java
@@ -0,0 +1,16 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+public enum LDNMessageQueueStatus {
+
+    /**
+     * Resulting processing status of an LDN Message (aka queue management)
+     */
+    QUEUED, PROCESSING, PROCESSED, FAILED;
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/LDNMetadataFields.java b/dspace-api/src/main/java/org/dspace/app/ldn/LDNMetadataFields.java
new file mode 100644
index 0000000000..67a87c144c
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/LDNMetadataFields.java
@@ -0,0 +1,38 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+/**
+ * Constants for LDN metadata fields
+ * 
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.com)
+ */
+public final class LDNMetadataFields {
+
+    // schema and element are the same for each metadata of LDN coar-notify
+    public static final String SCHEMA = "coar";
+    public static final String ELEMENT = "notify";
+
+    // qualifiers
+    public static final String INITIALIZE = "initialize";
+    public static final String REQUEST_REVIEW = "requestreview";
+    public static final String REQUEST_ENDORSEMENT = "requestendorsement";
+    public static final String EXAMINATION = "examination";
+    public static final String REFUSED = "refused";
+    public static final String REVIEW = "review";
+    public static final String ENDORSMENT = "endorsement";
+    public static final String RELEASE = "release";
+
+    /**
+     * 
+     */
+    private LDNMetadataFields() {
+
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/LDNQueueExtractor.java b/dspace-api/src/main/java/org/dspace/app/ldn/LDNQueueExtractor.java
new file mode 100644
index 0000000000..57a7cdfb07
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/LDNQueueExtractor.java
@@ -0,0 +1,54 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+import java.sql.SQLException;
+
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.factory.LDNMessageServiceFactory;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.core.Context;
+
+/**
+ * LDN Message manager: scheduled task invoking extractAndProcessMessageFromQueue() of {@link LDNMessageService}
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science dot it)
+ */
+public class LDNQueueExtractor {
+
+    private static final LDNMessageService ldnMessageService = LDNMessageServiceFactory.getInstance()
+        .getLDNMessageService();
+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(LDNQueueExtractor.class);
+
+    /**
+     * Default constructor
+     */
+    private LDNQueueExtractor() {
+    }
+
+    /**
+     * invokes
+     * @see org.dspace.app.ldn.service.impl.LDNMessageServiceImpl#extractAndProcessMessageFromQueue(Context)
+     * to process the oldest ldn messages from the queue. An LdnMessage is processed when is routed to a
+     * @see org.dspace.app.ldn.processor.LDNProcessor
+     * Also a +1 is added to the ldnMessage entity
+     * @see org.dspace.app.ldn.LDNMessageEntity#getQueueAttempts()
+     * @return the number of processed ldnMessages.
+     * @throws SQLException
+     */
+    public static int extractMessageFromQueue() throws SQLException {
+        Context context = new Context(Context.Mode.READ_WRITE);
+        int processed_messages = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        if (processed_messages > 0) {
+            log.info("Processed Messages x" + processed_messages);
+        }
+        context.complete();
+        return processed_messages;
+    }
+
+};
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/LDNQueueTimeoutChecker.java b/dspace-api/src/main/java/org/dspace/app/ldn/LDNQueueTimeoutChecker.java
new file mode 100644
index 0000000000..36a927d672
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/LDNQueueTimeoutChecker.java
@@ -0,0 +1,53 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+import java.sql.SQLException;
+
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.factory.LDNMessageServiceFactory;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.core.Context;
+
+/**
+ * LDN Message manager: scheduled task invoking checkQueueMessageTimeout() of {@link LDNMessageService}
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science dot it)
+ */
+public class LDNQueueTimeoutChecker {
+
+    private static final LDNMessageService ldnMessageService = LDNMessageServiceFactory.getInstance()
+        .getLDNMessageService();
+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(LDNQueueTimeoutChecker.class);
+
+    /**
+     * Default constructor
+     */
+    private LDNQueueTimeoutChecker() {
+    }
+
+    /**
+     * invokes
+     * @see org.dspace.app.ldn.service.impl.LDNMessageServiceImpl#checkQueueMessageTimeout(Context)
+     * to refresh the queue status of timed-out and in progressing status ldn messages:
+     * according to their attempts put them back in queue or set their status as failed if maxAttempts
+     * reached.
+     * @return the number of managed ldnMessages.
+     * @throws SQLException
+     */
+    public static int checkQueueMessageTimeout() throws SQLException {
+        Context context = new Context(Context.Mode.READ_WRITE);
+        int fixed_messages = 0;
+        fixed_messages = ldnMessageService.checkQueueMessageTimeout(context);
+        if (fixed_messages > 0) {
+            log.info("Managed Messages x" + fixed_messages);
+        }
+        context.complete();
+        return fixed_messages;
+    }
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/LDNRouter.java b/dspace-api/src/main/java/org/dspace/app/ldn/LDNRouter.java
new file mode 100644
index 0000000000..14957aa503
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/LDNRouter.java
@@ -0,0 +1,91 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.Map;
+import java.util.Set;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.processor.LDNProcessor;
+
+/**
+ * Linked Data Notification router.
+ */
+public class LDNRouter {
+
+    private Map<Set<String>, LDNProcessor> incomingProcessors = new HashMap<>();
+    private Map<Set<String>, LDNProcessor> outcomingProcessors = new HashMap<>();
+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(LDNRouter.class);
+
+    /**
+     * Route notification to processor
+     * 
+     * @return LDNProcessor processor to process notification, can be null
+     */
+    public LDNProcessor route(LDNMessageEntity ldnMessage) {
+        if (ldnMessage == null) {
+            log.warn("A null LDNMessage was received and could not be routed.");
+            return null;
+        }
+        if (StringUtils.isEmpty(ldnMessage.getType())) {
+            log.warn("LDNMessage " + ldnMessage + " was received. It has no type, so it couldn't be routed.");
+            return null;
+        }
+        Set<String> ldnMessageTypeSet = new HashSet<String>();
+        ldnMessageTypeSet.add(ldnMessage.getActivityStreamType());
+        ldnMessageTypeSet.add(ldnMessage.getCoarNotifyType());
+
+        LDNProcessor processor = null;
+        if (ldnMessage.getTarget() == null) {
+            processor = incomingProcessors.get(ldnMessageTypeSet);
+        } else if (ldnMessage.getOrigin() == null) {
+            processor = outcomingProcessors.get(ldnMessageTypeSet);
+        }
+
+        return processor;
+    }
+
+    /**
+     * Get all incoming routes.
+     *
+     * @return Map<Set<String>, LDNProcessor>
+     */
+    public Map<Set<String>, LDNProcessor> getIncomingProcessors() {
+        return incomingProcessors;
+    }
+
+    /**
+     * Set all incoming routes.
+     *
+     * @param incomingProcessors
+     */
+    public void setIncomingProcessors(Map<Set<String>, LDNProcessor> incomingProcessors) {
+        this.incomingProcessors = incomingProcessors;
+    }
+
+    /**
+     * Get all outcoming routes.
+     *
+     * @return Map<Set<String>, LDNProcessor>
+     */
+    public Map<Set<String>, LDNProcessor> getOutcomingProcessors() {
+        return outcomingProcessors;
+    }
+
+    /**
+     * Set all outcoming routes.
+     *
+     * @param outcomingProcessors
+     */
+    public void setOutcomingProcessors(Map<Set<String>, LDNProcessor> outcomingProcessors) {
+        this.outcomingProcessors = outcomingProcessors;
+    }
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/NotifyPatternToTrigger.java b/dspace-api/src/main/java/org/dspace/app/ldn/NotifyPatternToTrigger.java
new file mode 100644
index 0000000000..b393d8bedb
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/NotifyPatternToTrigger.java
@@ -0,0 +1,83 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.GeneratedValue;
+import javax.persistence.GenerationType;
+import javax.persistence.Id;
+import javax.persistence.JoinColumn;
+import javax.persistence.ManyToOne;
+import javax.persistence.SequenceGenerator;
+import javax.persistence.Table;
+
+import org.dspace.content.Item;
+import org.dspace.core.ReloadableEntity;
+
+/**
+ * Database object representing notify patterns to be triggered
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@Entity
+@Table(name = "notifypatterns_to_trigger")
+public class NotifyPatternToTrigger implements ReloadableEntity<Integer> {
+
+    @Id
+    @Column(name = "id")
+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "notifypatterns_to_trigger_id_seq")
+    @SequenceGenerator(name = "notifypatterns_to_trigger_id_seq",
+        sequenceName = "notifypatterns_to_trigger_id_seq",
+        allocationSize = 1)
+    private Integer id;
+
+    @ManyToOne
+    @JoinColumn(name = "item_id", referencedColumnName = "uuid")
+    private Item item;
+
+    @ManyToOne
+    @JoinColumn(name = "service_id", referencedColumnName = "id")
+    private NotifyServiceEntity notifyService;
+
+    @Column(name = "pattern")
+    private String pattern;
+
+    public void setId(Integer id) {
+        this.id = id;
+    }
+
+    public Item getItem() {
+        return item;
+    }
+
+    public void setItem(Item item) {
+        this.item = item;
+    }
+
+    public NotifyServiceEntity getNotifyService() {
+        return notifyService;
+    }
+
+    public void setNotifyService(NotifyServiceEntity notifyService) {
+        this.notifyService = notifyService;
+    }
+
+    public String getPattern() {
+        return pattern;
+    }
+
+    public void setPattern(String pattern) {
+        this.pattern = pattern;
+    }
+
+    @Override
+    public Integer getID() {
+        return id;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/NotifyServiceEntity.java b/dspace-api/src/main/java/org/dspace/app/ldn/NotifyServiceEntity.java
new file mode 100644
index 0000000000..206ed16fa0
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/NotifyServiceEntity.java
@@ -0,0 +1,156 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+import java.math.BigDecimal;
+import java.util.List;
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.GeneratedValue;
+import javax.persistence.GenerationType;
+import javax.persistence.Id;
+import javax.persistence.OneToMany;
+import javax.persistence.SequenceGenerator;
+import javax.persistence.Table;
+
+import org.dspace.core.ReloadableEntity;
+
+/**
+ * Database object representing notify services
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@Entity
+@Table(name = "notifyservice")
+public class NotifyServiceEntity implements ReloadableEntity<Integer> {
+
+    @Id
+    @Column(name = "id")
+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "notifyservice_id_seq")
+    @SequenceGenerator(name = "notifyservice_id_seq", sequenceName = "notifyservice_id_seq",
+        allocationSize = 1)
+    private Integer id;
+
+    @Column(name = "name", nullable = false)
+    private String name;
+
+    @Column(name = "description", columnDefinition = "text")
+    private String description;
+
+    @Column(name = "url")
+    private String url;
+
+    @Column(name = "ldn_url")
+    private String ldnUrl;
+
+    @OneToMany(mappedBy = "notifyService")
+    private List<NotifyServiceInboundPattern> inboundPatterns;
+
+    @Column(name = "enabled")
+    private boolean enabled = false;
+
+    @Column(name = "score")
+    private BigDecimal score;
+
+    @Column(name = "lower_ip")
+    private String lowerIp;
+
+    @Column(name = "upper_ip")
+    private String upperIp;
+
+    public void setId(Integer id) {
+        this.id = id;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    /**
+     * @return URL of an informative website
+     */
+    public String getUrl() {
+        return url;
+    }
+
+    public void setUrl(String url) {
+        this.url = url;
+    }
+
+    /**
+     * @return URL of the LDN InBox
+     */
+    public String getLdnUrl() {
+        return ldnUrl;
+    }
+
+    public void setLdnUrl(String ldnUrl) {
+        this.ldnUrl = ldnUrl;
+    }
+
+    /**
+     * @return The list of the inbound patterns configuration supported by the service
+     */
+    public List<NotifyServiceInboundPattern> getInboundPatterns() {
+        return inboundPatterns;
+    }
+
+    public void setInboundPatterns(List<NotifyServiceInboundPattern> inboundPatterns) {
+        this.inboundPatterns = inboundPatterns;
+    }
+
+    @Override
+    public Integer getID() {
+        return id;
+    }
+
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    public void setEnabled(boolean enabled) {
+        this.enabled = enabled;
+    }
+
+    public BigDecimal getScore() {
+        return score;
+    }
+
+    public void setScore(BigDecimal score) {
+        this.score = score;
+    }
+
+    public String getLowerIp() {
+        return lowerIp;
+    }
+
+    public void setLowerIp(String lowerIp) {
+        this.lowerIp = lowerIp;
+    }
+
+    public String getUpperIp() {
+        return upperIp;
+    }
+
+    public void setUpperIp(String upperIp) {
+        this.upperIp = upperIp;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/NotifyServiceInboundPattern.java b/dspace-api/src/main/java/org/dspace/app/ldn/NotifyServiceInboundPattern.java
new file mode 100644
index 0000000000..0c367d5051
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/NotifyServiceInboundPattern.java
@@ -0,0 +1,104 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.GeneratedValue;
+import javax.persistence.GenerationType;
+import javax.persistence.Id;
+import javax.persistence.JoinColumn;
+import javax.persistence.ManyToOne;
+import javax.persistence.SequenceGenerator;
+import javax.persistence.Table;
+
+import org.dspace.core.ReloadableEntity;
+
+/**
+ * Database object representing notify service inbound patterns. Every {@link org.dspace.app.ldn.NotifyServiceEntity}
+ * may have inbounds and outbounds. Inbounds are to be sent to the external service.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@Entity
+@Table(name = "notifyservice_inbound_pattern")
+public class NotifyServiceInboundPattern implements ReloadableEntity<Integer> {
+
+    @Id
+    @Column(name = "id")
+    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "notifyservice_inbound_pattern_id_seq")
+    @SequenceGenerator(name = "notifyservice_inbound_pattern_id_seq",
+        sequenceName = "notifyservice_inbound_pattern_id_seq",
+        allocationSize = 1)
+    private Integer id;
+
+    @ManyToOne
+    @JoinColumn(name = "service_id", referencedColumnName = "id")
+    private NotifyServiceEntity notifyService;
+
+    @Column(name = "pattern")
+    private String pattern;
+
+    @Column(name = "constraint_name")
+    private String constraint;
+
+    @Column(name = "automatic")
+    private boolean automatic;
+
+    @Override
+    public Integer getID() {
+        return id;
+    }
+
+    public void setId(Integer id) {
+        this.id = id;
+    }
+
+    public NotifyServiceEntity getNotifyService() {
+        return notifyService;
+    }
+
+    public void setNotifyService(NotifyServiceEntity notifyService) {
+        this.notifyService = notifyService;
+    }
+
+    /**
+     * @see <a href="https://notify.coar-repositories.org/patterns">coar documentation</a>
+     * @return pattern of the inbound notification
+     */
+    public String getPattern() {
+        return pattern;
+    }
+
+    public void setPattern(String pattern) {
+        this.pattern = pattern;
+    }
+
+    /**
+     * @return the condition checked for automatic evaluation
+     */
+    public String getConstraint() {
+        return constraint;
+    }
+
+    public void setConstraint(String constraint) {
+        this.constraint = constraint;
+    }
+
+    /**
+     * when true - the notification is automatically when constraints are respected.
+     * @return the automatic flag
+     */
+    public boolean isAutomatic() {
+        return automatic;
+    }
+
+    public void setAutomatic(boolean automatic) {
+        this.automatic = automatic;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNAction.java b/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNAction.java
new file mode 100644
index 0000000000..b0c895de99
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNAction.java
@@ -0,0 +1,31 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.action;
+
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+
+/**
+ * An action that is run after a notification has been processed.
+ */
+public interface LDNAction {
+
+    /**
+     * Execute action for provided notification and item corresponding to the
+     * notification context.
+     *
+     *@param context  the context
+     * @param notification the processed notification to perform action against
+     * @param item         the item corresponding to the notification context
+     * @return ActionStatus the resulting status of the action
+     * @throws Exception general exception that can be thrown while executing action
+     */
+    public LDNActionStatus execute(Context context, Notification notification, Item item) throws Exception;
+
+}
\ No newline at end of file
diff --git a/dspace-services/src/main/java/org/dspace/servicemanager/servlet/package-info.java b/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNActionStatus.java
similarity index 55%
rename from dspace-services/src/main/java/org/dspace/servicemanager/servlet/package-info.java
rename to dspace-api/src/main/java/org/dspace/app/ldn/action/LDNActionStatus.java
index 652c887e04..86f56ed9ba 100644
--- a/dspace-services/src/main/java/org/dspace/servicemanager/servlet/package-info.java
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNActionStatus.java
@@ -5,10 +5,11 @@
  *
  * http://www.dspace.org/license/
  */
+package org.dspace.app.ldn.action;
 
 /**
- * Support for using DSpace Services in a servlet context.  This is how the
- * kernel and services get started by the servlet container.
+ * Resulting status of an execution of an action.
  */
-
-package org.dspace.servicemanager.servlet;
+public enum LDNActionStatus {
+    CONTINUE, ABORT;
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNCorrectionAction.java b/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNCorrectionAction.java
new file mode 100644
index 0000000000..5ce3804bce
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNCorrectionAction.java
@@ -0,0 +1,108 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.action;
+
+import java.math.BigDecimal;
+import java.sql.SQLException;
+import java.util.Date;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.handle.service.HandleService;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.qaevent.service.dto.NotifyMessageDTO;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+
+/**
+ * Implementation for LDN Correction Action. It creates a QA Event according to the LDN Message received *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ *
+ */
+public class LDNCorrectionAction implements LDNAction {
+
+    private static final Logger log = LogManager.getLogger(LDNEmailAction.class);
+
+    private String qaEventTopic;
+
+    @Autowired
+    private ConfigurationService configurationService;
+    @Autowired
+    protected ItemService itemService;
+    @Autowired
+    private QAEventService qaEventService;
+    @Autowired
+    private LDNMessageService ldnMessageService;
+    @Autowired
+    private HandleService handleService;
+
+    @Override
+    public LDNActionStatus execute(Context context, Notification notification, Item item) throws Exception {
+        LDNActionStatus result = LDNActionStatus.ABORT;
+        String itemName = itemService.getName(item);
+        QAEvent qaEvent = null;
+        if (notification.getObject() != null) {
+            String citeAs = notification.getObject().getIetfCiteAs();
+            if (citeAs == null || citeAs.isEmpty()) {
+                citeAs = notification.getObject().getId();
+            }
+            NotifyMessageDTO message = new NotifyMessageDTO();
+            message.setHref(citeAs);
+            message.setRelationship(notification.getObject().getAsRelationship());
+            if (notification.getOrigin() != null) {
+                message.setServiceId(notification.getOrigin().getId());
+                message.setServiceName(notification.getOrigin().getInbox());
+            }
+            BigDecimal score = getScore(context, notification);
+            double doubleScoreValue = score != null ? score.doubleValue() : 0d;
+            ObjectMapper mapper = new ObjectMapper();
+            qaEvent = new QAEvent(QAEvent.COAR_NOTIFY_SOURCE,
+                handleService.findHandle(context, item), item.getID().toString(), itemName,
+                this.getQaEventTopic(), doubleScoreValue,
+                mapper.writeValueAsString(message),
+                new Date());
+            qaEventService.store(context, qaEvent);
+            result = LDNActionStatus.CONTINUE;
+        }
+
+        return result;
+    }
+
+    private BigDecimal getScore(Context context, Notification notification) throws SQLException {
+
+        if (notification.getOrigin() == null) {
+            return BigDecimal.ZERO;
+        }
+
+        NotifyServiceEntity service = ldnMessageService.findNotifyService(context, notification.getOrigin());
+
+        if (service == null) {
+            return BigDecimal.ZERO;
+        }
+
+        return service.getScore();
+    }
+
+    public String getQaEventTopic() {
+        return qaEventTopic;
+    }
+
+    public void setQaEventTopic(String qaEventTopic) {
+        this.qaEventTopic = qaEventTopic;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNEmailAction.java b/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNEmailAction.java
new file mode 100644
index 0000000000..b87001f815
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNEmailAction.java
@@ -0,0 +1,155 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.action;
+
+import static java.lang.String.format;
+
+import java.text.SimpleDateFormat;
+import java.util.Arrays;
+import java.util.Calendar;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Locale;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+import org.dspace.core.Email;
+import org.dspace.core.I18nUtil;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Action to send email to receipients provided in actionSendFilter. The email
+ * body will be result of templating actionSendFilter.
+ */
+public class LDNEmailAction implements LDNAction {
+
+    private static final Logger log = LogManager.getLogger(LDNEmailAction.class);
+
+    private final static String DATE_PATTERN = "dd-MM-yyyy HH:mm:ss";
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    /*
+     * Supported for actionSendFilter are:
+     * - <single email>
+     * - GROUP:<group_name>
+     * - SUBMITTER
+     */
+    private String actionSendFilter;
+
+    // The file name for the requested email
+    private String actionSendEmailTextFile;
+
+    /**
+     * Execute sending an email.
+     *
+     * Template context parameters:
+     *
+     * {0} Service Name
+     * {1} Item Name
+     * {2} Service URL
+     * {3} Item URL
+     * {4} Submitter's Name
+     * {5} Date of the received LDN notification
+     * {6} LDN notification
+     * {7} Item
+     *
+     * @param notification
+     * @param item
+     * @return ActionStatus
+     * @throws Exception
+     */
+    @Override
+    public LDNActionStatus execute(Context context, Notification notification, Item item) throws Exception {
+        try {
+            Locale supportedLocale = I18nUtil.getEPersonLocale(context.getCurrentUser());
+            Email email = Email.getEmail(I18nUtil.getEmailFilename(supportedLocale, actionSendEmailTextFile));
+
+            // Setting recipients email
+            for (String recipient : retrieveRecipientsEmail(item)) {
+                email.addRecipient(recipient);
+            }
+
+            String date = new SimpleDateFormat(DATE_PATTERN).format(Calendar.getInstance().getTime());
+
+            email.addArgument(notification.getActor().getName());
+            email.addArgument(item.getName());
+            email.addArgument(notification.getActor().getId());
+            email.addArgument(notification.getContext() != null ?
+                notification.getContext().getId() : notification.getObject().getId());
+            email.addArgument(item.getSubmitter().getFullName());
+            email.addArgument(date);
+            email.addArgument(notification);
+            email.addArgument(item);
+
+            email.send();
+        } catch (Exception e) {
+            log.error("An Error Occurred while sending a notification email", e);
+        }
+
+        return LDNActionStatus.CONTINUE;
+    }
+
+    /**
+     * @return String
+     */
+    public String getActionSendFilter() {
+        return actionSendFilter;
+    }
+
+    /**
+     * @param actionSendFilter
+     */
+    public void setActionSendFilter(String actionSendFilter) {
+        this.actionSendFilter = actionSendFilter;
+    }
+
+    /**
+     * @return String
+     */
+    public String getActionSendEmailTextFile() {
+        return actionSendEmailTextFile;
+    }
+
+    /**
+     * @param actionSendEmailTextFile
+     */
+    public void setActionSendEmailTextFile(String actionSendEmailTextFile) {
+        this.actionSendEmailTextFile = actionSendEmailTextFile;
+    }
+
+    /**
+     * Parses actionSendFilter for reserved tokens and returns list of email
+     * recipients.
+     *
+     * @param item the item which to get submitter email
+     * @return List<String> list of email recipients
+     */
+    private List<String> retrieveRecipientsEmail(Item item) {
+        List<String> recipients = new LinkedList<String>();
+
+        if (actionSendFilter.startsWith("SUBMITTER")) {
+            recipients.add(item.getSubmitter().getEmail());
+        } else if (actionSendFilter.startsWith("GROUP:")) {
+            String groupName = actionSendFilter.replace("GROUP:", "");
+            String property = format("email.%s.list", groupName);
+            String[] groupEmails = configurationService.getArrayProperty(property);
+            recipients = Arrays.asList(groupEmails);
+        } else {
+            recipients.add(actionSendFilter);
+        }
+
+        return recipients;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNRelationCorrectionAction.java b/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNRelationCorrectionAction.java
new file mode 100644
index 0000000000..f11a42ab2f
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/action/LDNRelationCorrectionAction.java
@@ -0,0 +1,110 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.action;
+
+import java.math.BigDecimal;
+import java.sql.SQLException;
+import java.util.Date;
+import java.util.Set;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.handle.service.HandleService;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.qaevent.service.dto.NotifyMessageDTO;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+
+/**
+ * Implementation for LDN Correction Action. It creates a QA Event according to the LDN Message received *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ *
+ */
+public class LDNRelationCorrectionAction implements LDNAction {
+
+    private static final Logger log = LogManager.getLogger(LDNEmailAction.class);
+
+    private String qaEventTopic;
+
+    @Autowired
+    private ConfigurationService configurationService;
+    @Autowired
+    protected ItemService itemService;
+    @Autowired
+    private QAEventService qaEventService;
+    @Autowired
+    private LDNMessageService ldnMessageService;
+    @Autowired
+    private HandleService handleService;
+
+    @Override
+    public LDNActionStatus execute(Context context, Notification notification, Item item) throws Exception {
+        LDNActionStatus result = LDNActionStatus.ABORT;
+        String itemName = itemService.getName(item);
+        QAEvent qaEvent = null;
+        if (notification.getObject() != null) {
+            NotifyMessageDTO message = new NotifyMessageDTO();
+            if (notification.getType().containsAll(Set.of("Announce",
+                "coar-notify:RelationshipAction"))) {
+                message.setHref(notification.getObject().getAsSubject());
+            } else {
+                message.setHref(notification.getObject().getAsObject());
+            }
+            message.setRelationship(notification.getObject().getAsRelationship());
+            if (notification.getOrigin() != null) {
+                message.setServiceId(notification.getOrigin().getId());
+                message.setServiceName(notification.getOrigin().getInbox());
+            }
+            BigDecimal score = getScore(context, notification);
+            double doubleScoreValue = score != null ? score.doubleValue() : 0d;
+            ObjectMapper mapper = new ObjectMapper();
+            qaEvent = new QAEvent(QAEvent.COAR_NOTIFY_SOURCE,
+                handleService.findHandle(context, item), item.getID().toString(), itemName,
+                this.getQaEventTopic(), doubleScoreValue,
+                mapper.writeValueAsString(message),
+                new Date());
+            qaEventService.store(context, qaEvent);
+            result = LDNActionStatus.CONTINUE;
+        }
+
+        return result;
+    }
+
+    private BigDecimal getScore(Context context, Notification notification) throws SQLException {
+
+        if (notification.getOrigin() == null) {
+            return BigDecimal.ZERO;
+        }
+
+        NotifyServiceEntity service = ldnMessageService.findNotifyService(context, notification.getOrigin());
+
+        if (service == null) {
+            return BigDecimal.ZERO;
+        }
+
+        return service.getScore();
+    }
+
+    public String getQaEventTopic() {
+        return qaEventTopic;
+    }
+
+    public void setQaEventTopic(String qaEventTopic) {
+        this.qaEventTopic = qaEventTopic;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/action/SendLDNMessageAction.java b/dspace-api/src/main/java/org/dspace/app/ldn/action/SendLDNMessageAction.java
new file mode 100644
index 0000000000..c0ecf04304
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/action/SendLDNMessageAction.java
@@ -0,0 +1,118 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.action;
+
+import java.net.URI;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.http.Header;
+import org.apache.http.HttpException;
+import org.apache.http.HttpHeaders;
+import org.apache.http.HttpStatus;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClientBuilder;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+
+/**
+ * Action to send LDN Message
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class SendLDNMessageAction implements LDNAction {
+
+    private static final Logger log = LogManager.getLogger(SendLDNMessageAction.class);
+
+    private CloseableHttpClient client = null;
+
+    public SendLDNMessageAction() {
+        HttpClientBuilder builder = HttpClientBuilder.create();
+        client = builder
+            .disableAutomaticRetries()
+            .setMaxConnTotal(5)
+            .build();
+    }
+
+    public SendLDNMessageAction(CloseableHttpClient client) {
+        this();
+        if (client != null) {
+            this.client = client;
+        }
+    }
+
+    @Override
+    public LDNActionStatus execute(Context context, Notification notification, Item item) throws Exception {
+        //TODO authorization with Bearer token should be supported.
+
+        String url = notification.getTarget().getInbox();
+
+        HttpPost httpPost = new HttpPost(url);
+        httpPost.addHeader("Content-Type", "application/ld+json");
+        ObjectMapper mapper = new ObjectMapper();
+        httpPost.setEntity(new StringEntity(mapper.writeValueAsString(notification), "UTF-8"));
+
+        LDNActionStatus result = LDNActionStatus.ABORT;
+        // NOTE: Github believes there is a "Potential server-side request forgery due to a user-provided value"
+        // This is a false positive because the LDN Service URL is configured by the user from DSpace.
+        // See the frontend configuration at [dspace.ui.url]/admin/ldn/services
+        try (
+            CloseableHttpResponse response = client.execute(httpPost);
+            ) {
+            if (isSuccessful(response.getStatusLine().getStatusCode())) {
+                result = LDNActionStatus.CONTINUE;
+            } else if (isRedirect(response.getStatusLine().getStatusCode())) {
+                result = handleRedirect(response, httpPost);
+            }
+        } catch (Exception e) {
+            log.error(e);
+        }
+        return result;
+    }
+
+    private boolean isSuccessful(int statusCode) {
+        return statusCode == HttpStatus.SC_ACCEPTED ||
+            statusCode == HttpStatus.SC_CREATED;
+    }
+
+    private boolean isRedirect(int statusCode) {
+        //org.apache.http.HttpStatus has no enum value for 308!
+        return statusCode == (HttpStatus.SC_TEMPORARY_REDIRECT + 1) ||
+            statusCode == HttpStatus.SC_TEMPORARY_REDIRECT;
+    }
+
+    private LDNActionStatus handleRedirect(CloseableHttpResponse oldresponse,
+                                        HttpPost request) throws HttpException {
+        Header[] urls = oldresponse.getHeaders(HttpHeaders.LOCATION);
+        String url = urls.length > 0 && urls[0] != null ? urls[0].getValue() : null;
+        if (url == null) {
+            throw new HttpException("Error following redirect, unable to reach"
+                + " the correct url.");
+        }
+        LDNActionStatus result = LDNActionStatus.ABORT;
+        try {
+            request.setURI(new URI(url));
+            try (
+                CloseableHttpResponse response = client.execute(request);
+                ) {
+                if (isSuccessful(response.getStatusLine().getStatusCode())) {
+                    return LDNActionStatus.CONTINUE;
+                }
+            }
+        } catch (Exception e) {
+            log.error("Error following redirect:", e);
+        }
+
+        return LDNActionStatus.ABORT;
+    }
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/dao/LDNMessageDao.java b/dspace-api/src/main/java/org/dspace/app/ldn/dao/LDNMessageDao.java
new file mode 100644
index 0000000000..fcbb485aca
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/dao/LDNMessageDao.java
@@ -0,0 +1,76 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.dao;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+import org.dspace.core.GenericDAO;
+
+/**
+ * Database Access Object interface class for the LDNMessage object.
+ *
+ * The implementation of this class is responsible for all database calls for
+ * the LDNMessage object and is autowired by spring
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public interface LDNMessageDao extends GenericDAO<LDNMessageEntity> {
+
+    /**
+     * load the oldest ldn messages considering their {@link org.dspace.app.ldn.LDNMessageEntity#queueLastStartTime}
+     * @param context
+     * @param max_attempts consider ldn_message entity with queue_attempts <= max_attempts
+     * @return ldn message entities to be routed
+     * @throws SQLException
+     */
+    public List<LDNMessageEntity> findOldestMessageToProcess(Context context, int max_attempts) throws SQLException;
+
+    /**
+     * find ldn message entties in processing status and already timed out.
+     * @param context
+     * @param max_attempts consider ldn_message entity with queue_attempts <= max_attempts
+     * @return ldn message entities
+     * @throws SQLException
+     */
+    public List<LDNMessageEntity> findProcessingTimedoutMessages(Context context, int max_attempts) throws SQLException;
+
+    /**
+     * find all ldn messages related to an item
+     * @param context
+     * @param item item related to the returned ldn messages
+     * @param activities involves only this specific group of activities
+     * @return all ldn messages related to the given item
+     * @throws SQLException
+     */
+    public List<LDNMessageEntity> findAllMessagesByItem(
+        Context context, Item item, String... activities) throws SQLException;
+
+    /**
+     * find all ldn messages related to an item and to a specific ldn message
+     * @param context
+     * @param msg the referring ldn message
+     * @param item the referring repository item
+     * @param relatedTypes filter for @see org.dspace.app.ldn.LDNMessageEntity#activityStreamType
+     * @return all related ldn messages
+     * @throws SQLException
+     */
+    public List<LDNMessageEntity> findAllRelatedMessagesByItem(
+        Context context, LDNMessageEntity msg, Item item, String... relatedTypes) throws SQLException;
+
+    /**
+     *
+     * @param context
+     * @return the list of messages in need to be reprocessed - with queue_status as QUEUE_STATUS_QUEUED_FOR_RETRY
+     * @throws SQLException
+     */
+    public List<LDNMessageEntity> findMessagesToBeReprocessed(Context context) throws SQLException;
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/dao/NotifyPatternToTriggerDao.java b/dspace-api/src/main/java/org/dspace/app/ldn/dao/NotifyPatternToTriggerDao.java
new file mode 100644
index 0000000000..9ecd1b728a
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/dao/NotifyPatternToTriggerDao.java
@@ -0,0 +1,49 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.dao;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyPatternToTrigger;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+import org.dspace.core.GenericDAO;
+
+/**
+ * This is the Data Access Object for the {@link NotifyPatternToTrigger} object
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public interface NotifyPatternToTriggerDao extends GenericDAO<NotifyPatternToTrigger> {
+
+    /**
+     * find the NotifyPatternToTrigger matched with the provided item
+     *
+     * @param context the context
+     * @param item the item
+     * @return the NotifyPatternToTrigger matched the provided item
+     * @throws SQLException if database error
+     */
+    public List<NotifyPatternToTrigger> findByItem(Context context, Item item) throws SQLException;
+
+    /**
+     * find the NotifyPatternToTrigger matched with the provided
+     * item and pattern
+     *
+     * @param context the context
+     * @param item the item
+     * @param pattern the pattern
+     * @return the NotifyPatternToTrigger matched the provided
+     * item and pattern
+     * @throws SQLException if database error
+     */
+    public List<NotifyPatternToTrigger> findByItemAndPattern(Context context, Item item, String pattern)
+        throws SQLException;
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/dao/NotifyServiceDao.java b/dspace-api/src/main/java/org/dspace/app/ldn/dao/NotifyServiceDao.java
new file mode 100644
index 0000000000..9751b30382
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/dao/NotifyServiceDao.java
@@ -0,0 +1,45 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.dao;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.core.Context;
+import org.dspace.core.GenericDAO;
+
+/**
+ * This is the Data Access Object for the {@link NotifyServiceEntity} object
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public interface NotifyServiceDao extends GenericDAO<NotifyServiceEntity> {
+    /**
+     * find the NotifyServiceEntity matched with the provided ldnUrl
+     *
+     * @param context the context
+     * @param ldnUrl the ldnUrl
+     * @return the NotifyServiceEntity matched the provided ldnUrl
+     * @throws SQLException if database error
+     */
+    public NotifyServiceEntity findByLdnUrl(Context context, String ldnUrl) throws SQLException;
+
+    /**
+     * find all NotifyServiceEntity matched the provided inbound pattern
+     * from the related notifyServiceInboundPatterns
+     * also with 'automatic' equals to false
+     *
+     * @param context the context
+     * @param pattern the ldnUrl
+     * @return all NotifyServiceEntity matched the provided pattern
+     * @throws SQLException if database error
+     */
+    public List<NotifyServiceEntity> findManualServicesByInboundPattern(Context context, String pattern)
+        throws SQLException;
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/dao/NotifyServiceInboundPatternDao.java b/dspace-api/src/main/java/org/dspace/app/ldn/dao/NotifyServiceInboundPatternDao.java
new file mode 100644
index 0000000000..194d30e795
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/dao/NotifyServiceInboundPatternDao.java
@@ -0,0 +1,47 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.dao;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.core.Context;
+import org.dspace.core.GenericDAO;
+
+/**
+ * This is the Data Access Object for the {@link NotifyServiceInboundPattern} object
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public interface NotifyServiceInboundPatternDao extends GenericDAO<NotifyServiceInboundPattern> {
+
+    /**
+     * find all notifyServiceInboundPatterns matched with
+     * the provided notifyServiceEntity and pattern
+     *
+     * @param context the context
+     * @param notifyServiceEntity the notifyServiceEntity
+     * @param pattern the pattern
+     * @return all notifyServiceInboundPatterns matched with
+     * the provided notifyServiceEntity and pattern
+     * @throws SQLException if database error
+     */
+    public NotifyServiceInboundPattern findByServiceAndPattern(Context context,
+                                                               NotifyServiceEntity notifyServiceEntity,
+                                                               String pattern) throws SQLException;
+    /**
+     * find all automatic notifyServiceInboundPatterns
+     *
+     * @param context the context
+     * @return all automatic notifyServiceInboundPatterns
+     * @throws SQLException if database error
+     */
+    List<NotifyServiceInboundPattern> findAutomaticPatterns(Context context) throws SQLException;
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/LDNMessageDaoImpl.java b/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/LDNMessageDaoImpl.java
new file mode 100644
index 0000000000..f3b620a706
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/LDNMessageDaoImpl.java
@@ -0,0 +1,169 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.dao.impl;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Date;
+import java.util.LinkedList;
+import java.util.List;
+import javax.persistence.criteria.CriteriaBuilder;
+import javax.persistence.criteria.CriteriaQuery;
+import javax.persistence.criteria.Order;
+import javax.persistence.criteria.Predicate;
+import javax.persistence.criteria.Root;
+
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.LDNMessageEntity_;
+import org.dspace.app.ldn.dao.LDNMessageDao;
+import org.dspace.content.Item;
+import org.dspace.core.AbstractHibernateDAO;
+import org.dspace.core.Context;
+
+/**
+ * Hibernate implementation of the Database Access Object interface class for
+ * the LDNMessage object. This class is responsible for all database calls for
+ * the LDNMessage object and is autowired by spring
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class LDNMessageDaoImpl extends AbstractHibernateDAO<LDNMessageEntity> implements LDNMessageDao {
+
+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(LDNMessageDaoImpl.class);
+
+    @Override
+    public List<LDNMessageEntity> findOldestMessageToProcess(Context context, int max_attempts) throws SQLException {
+        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
+        CriteriaQuery<LDNMessageEntity> criteriaQuery = getCriteriaQuery(criteriaBuilder, LDNMessageEntity.class);
+        Root<LDNMessageEntity> root = criteriaQuery.from(LDNMessageEntity.class);
+        criteriaQuery.select(root);
+        List<Predicate> andPredicates = new ArrayList<>(3);
+        andPredicates
+            .add(criteriaBuilder.equal(root.get(LDNMessageEntity_.queueStatus), LDNMessageEntity.QUEUE_STATUS_QUEUED));
+        andPredicates.add(criteriaBuilder.lessThan(root.get(LDNMessageEntity_.queueAttempts), max_attempts));
+        andPredicates.add(criteriaBuilder.lessThan(root.get(LDNMessageEntity_.queueTimeout), new Date()));
+        criteriaQuery.where(criteriaBuilder.and(andPredicates.toArray(new Predicate[] {})));
+        List<Order> orderList = new LinkedList<>();
+        orderList.add(criteriaBuilder.desc(root.get(LDNMessageEntity_.queueAttempts)));
+        orderList.add(criteriaBuilder.asc(root.get(LDNMessageEntity_.queueLastStartTime)));
+        criteriaQuery.orderBy(orderList);
+        List<LDNMessageEntity> result = list(context, criteriaQuery, false, LDNMessageEntity.class, -1, -1);
+        if (result == null || result.isEmpty()) {
+            log.debug("No LDN messages found to be processed");
+        }
+        return result;
+    }
+
+    @Override
+    public List<LDNMessageEntity> findMessagesToBeReprocessed(Context context) throws SQLException {
+        // looking for LDN Messages to be reprocessed message
+        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
+        CriteriaQuery<LDNMessageEntity> criteriaQuery = getCriteriaQuery(criteriaBuilder, LDNMessageEntity.class);
+        Root<LDNMessageEntity> root = criteriaQuery.from(LDNMessageEntity.class);
+        criteriaQuery.select(root);
+        List<Predicate> andPredicates = new ArrayList<>(1);
+        andPredicates
+            .add(criteriaBuilder.equal(root.get(LDNMessageEntity_.queueStatus),
+                LDNMessageEntity.QUEUE_STATUS_QUEUED_FOR_RETRY));
+        criteriaQuery.where(criteriaBuilder.and(andPredicates.toArray(new Predicate[] {})));
+        List<Order> orderList = new LinkedList<>();
+        orderList.add(criteriaBuilder.desc(root.get(LDNMessageEntity_.queueAttempts)));
+        orderList.add(criteriaBuilder.asc(root.get(LDNMessageEntity_.queueLastStartTime)));
+        criteriaQuery.orderBy(orderList);
+        List<LDNMessageEntity> result = list(context, criteriaQuery, false, LDNMessageEntity.class, -1, -1);
+        if (result == null || result.isEmpty()) {
+            log.debug("No LDN messages found to be processed");
+        }
+        return result;
+    }
+
+    @Override
+    public List<LDNMessageEntity> findProcessingTimedoutMessages(Context context, int max_attempts)
+        throws SQLException {
+        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
+        CriteriaQuery<LDNMessageEntity> criteriaQuery = getCriteriaQuery(criteriaBuilder, LDNMessageEntity.class);
+        Root<LDNMessageEntity> root = criteriaQuery.from(LDNMessageEntity.class);
+        criteriaQuery.select(root);
+        List<Predicate> andPredicates = new ArrayList<>(3);
+        andPredicates.add(
+            criteriaBuilder.equal(root.get(LDNMessageEntity_.queueStatus), LDNMessageEntity.QUEUE_STATUS_PROCESSING));
+        andPredicates.add(criteriaBuilder.lessThanOrEqualTo(root.get(LDNMessageEntity_.queueAttempts), max_attempts));
+        andPredicates.add(criteriaBuilder.lessThan(root.get(LDNMessageEntity_.queueTimeout), new Date()));
+        criteriaQuery.where(criteriaBuilder.and(andPredicates.toArray(new Predicate[] {})));
+        List<Order> orderList = new LinkedList<>();
+        orderList.add(criteriaBuilder.desc(root.get(LDNMessageEntity_.queueAttempts)));
+        orderList.add(criteriaBuilder.asc(root.get(LDNMessageEntity_.queueLastStartTime)));
+        criteriaQuery.orderBy(orderList);
+        List<LDNMessageEntity> result = list(context, criteriaQuery, false, LDNMessageEntity.class, -1, -1);
+        if (result == null || result.isEmpty()) {
+            log.debug("No LDN messages found to be processed");
+        }
+        return result;
+    }
+
+    @Override
+    public List<LDNMessageEntity> findAllRelatedMessagesByItem(
+        Context context, LDNMessageEntity msg, Item item, String... relatedTypes) throws SQLException {
+        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
+        CriteriaQuery<LDNMessageEntity> criteriaQuery = getCriteriaQuery(criteriaBuilder, LDNMessageEntity.class);
+        Root<LDNMessageEntity> root = criteriaQuery.from(LDNMessageEntity.class);
+        criteriaQuery.select(root);
+        List<Predicate> andPredicates = new ArrayList<>();
+        Predicate relatedtypePredicate = null;
+        andPredicates.add(
+            criteriaBuilder.equal(root.get(LDNMessageEntity_.queueStatus), LDNMessageEntity.QUEUE_STATUS_PROCESSED));
+        andPredicates.add(
+            criteriaBuilder.isNull(root.get(LDNMessageEntity_.target)));
+        andPredicates.add(
+            criteriaBuilder.equal(root.get(LDNMessageEntity_.inReplyTo), msg));
+        if (relatedTypes != null && relatedTypes.length > 0) {
+            relatedtypePredicate = root.get(LDNMessageEntity_.activityStreamType).in(relatedTypes);
+            andPredicates.add(relatedtypePredicate);
+        }
+        criteriaQuery.where(criteriaBuilder.and(andPredicates.toArray(new Predicate[] {})));
+        List<Order> orderList = new LinkedList<>();
+        orderList.add(criteriaBuilder.asc(root.get(LDNMessageEntity_.queueLastStartTime)));
+        orderList.add(criteriaBuilder.desc(root.get(LDNMessageEntity_.queueAttempts)));
+        criteriaQuery.orderBy(orderList);
+        List<LDNMessageEntity> result = list(context, criteriaQuery, false, LDNMessageEntity.class, -1, -1);
+        if (result == null || result.isEmpty()) {
+            log.debug("No LDN messages ACK found to be processed");
+        }
+        return result;
+    }
+
+    @Override
+    public List<LDNMessageEntity> findAllMessagesByItem(
+        Context context, Item item, String... activities) throws SQLException {
+        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
+        CriteriaQuery<LDNMessageEntity> criteriaQuery = getCriteriaQuery(criteriaBuilder, LDNMessageEntity.class);
+        Root<LDNMessageEntity> root = criteriaQuery.from(LDNMessageEntity.class);
+        criteriaQuery.select(root);
+        List<Predicate> andPredicates = new ArrayList<>();
+        Predicate activityPredicate = null;
+        andPredicates.add(
+            criteriaBuilder.equal(root.get(LDNMessageEntity_.queueStatus), LDNMessageEntity.QUEUE_STATUS_PROCESSED));
+        andPredicates.add(
+            criteriaBuilder.equal(root.get(LDNMessageEntity_.object), item));
+        if (activities != null && activities.length > 0) {
+            activityPredicate = root.get(LDNMessageEntity_.activityStreamType).in(activities);
+            andPredicates.add(activityPredicate);
+        }
+        criteriaQuery.where(criteriaBuilder.and(andPredicates.toArray(new Predicate[] {})));
+        List<Order> orderList = new LinkedList<>();
+        orderList.add(criteriaBuilder.asc(root.get(LDNMessageEntity_.queueLastStartTime)));
+        orderList.add(criteriaBuilder.desc(root.get(LDNMessageEntity_.queueAttempts)));
+        criteriaQuery.orderBy(orderList);
+        List<LDNMessageEntity> result = list(context, criteriaQuery, false, LDNMessageEntity.class, -1, -1);
+        if (result == null || result.isEmpty()) {
+            log.debug("No LDN messages found");
+        }
+        return result;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/NotifyPatternToTriggerDaoImpl.java b/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/NotifyPatternToTriggerDaoImpl.java
new file mode 100644
index 0000000000..47c584518b
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/NotifyPatternToTriggerDaoImpl.java
@@ -0,0 +1,58 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.dao.impl;
+
+import java.sql.SQLException;
+import java.util.List;
+import javax.persistence.criteria.CriteriaBuilder;
+import javax.persistence.criteria.CriteriaQuery;
+import javax.persistence.criteria.Root;
+
+import org.dspace.app.ldn.NotifyPatternToTrigger;
+import org.dspace.app.ldn.NotifyPatternToTrigger_;
+import org.dspace.app.ldn.dao.NotifyPatternToTriggerDao;
+import org.dspace.content.Item;
+import org.dspace.core.AbstractHibernateDAO;
+import org.dspace.core.Context;
+
+/**
+ * Implementation of {@link NotifyPatternToTriggerDao}.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyPatternToTriggerDaoImpl extends AbstractHibernateDAO<NotifyPatternToTrigger>
+    implements NotifyPatternToTriggerDao {
+
+    @Override
+    public List<NotifyPatternToTrigger> findByItem(Context context, Item item)
+        throws SQLException {
+        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
+        CriteriaQuery criteriaQuery = getCriteriaQuery(criteriaBuilder, NotifyPatternToTrigger.class);
+        Root<NotifyPatternToTrigger> notifyServiceEntityRoot = criteriaQuery.from(NotifyPatternToTrigger.class);
+        criteriaQuery.select(notifyServiceEntityRoot);
+        criteriaQuery.where(criteriaBuilder.equal(
+            notifyServiceEntityRoot.get(NotifyPatternToTrigger_.item), item));
+        return list(context, criteriaQuery, false, NotifyPatternToTrigger.class, -1, -1);
+    }
+    @Override
+    public List<NotifyPatternToTrigger> findByItemAndPattern(Context context, Item item, String pattern)
+        throws SQLException {
+        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
+        CriteriaQuery criteriaQuery = getCriteriaQuery(criteriaBuilder, NotifyPatternToTrigger.class);
+        Root<NotifyPatternToTrigger> notifyServiceEntityRoot = criteriaQuery.from(NotifyPatternToTrigger.class);
+        criteriaQuery.select(notifyServiceEntityRoot);
+        criteriaQuery.where(criteriaBuilder.and(
+            criteriaBuilder.equal(
+            notifyServiceEntityRoot.get(NotifyPatternToTrigger_.item), item),
+            criteriaBuilder.equal(
+                notifyServiceEntityRoot.get(NotifyPatternToTrigger_.pattern), pattern)
+            ));
+        return list(context, criteriaQuery, false, NotifyPatternToTrigger.class, -1, -1);
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/NotifyServiceDaoImpl.java b/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/NotifyServiceDaoImpl.java
new file mode 100644
index 0000000000..cac804ef0c
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/NotifyServiceDaoImpl.java
@@ -0,0 +1,62 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.dao.impl;
+
+import java.sql.SQLException;
+import java.util.List;
+import javax.persistence.criteria.CriteriaBuilder;
+import javax.persistence.criteria.CriteriaQuery;
+import javax.persistence.criteria.Join;
+import javax.persistence.criteria.Root;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceEntity_;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.NotifyServiceInboundPattern_;
+import org.dspace.app.ldn.dao.NotifyServiceDao;
+import org.dspace.core.AbstractHibernateDAO;
+import org.dspace.core.Context;
+
+/**
+ * Implementation of {@link NotifyServiceDao}.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyServiceDaoImpl extends AbstractHibernateDAO<NotifyServiceEntity> implements NotifyServiceDao {
+
+    @Override
+    public NotifyServiceEntity findByLdnUrl(Context context, String ldnUrl) throws SQLException {
+        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
+        CriteriaQuery criteriaQuery = getCriteriaQuery(criteriaBuilder, NotifyServiceEntity.class);
+        Root<NotifyServiceEntity> notifyServiceEntityRoot = criteriaQuery.from(NotifyServiceEntity.class);
+        criteriaQuery.select(notifyServiceEntityRoot);
+        criteriaQuery.where(criteriaBuilder.equal(
+            notifyServiceEntityRoot.get(NotifyServiceEntity_.ldnUrl), ldnUrl));
+        return uniqueResult(context, criteriaQuery, false, NotifyServiceEntity.class);
+    }
+
+    @Override
+    public List<NotifyServiceEntity> findManualServicesByInboundPattern(Context context, String pattern)
+        throws SQLException {
+        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
+        CriteriaQuery criteriaQuery = getCriteriaQuery(criteriaBuilder, NotifyServiceEntity.class);
+        Root<NotifyServiceEntity> notifyServiceEntityRoot = criteriaQuery.from(NotifyServiceEntity.class);
+
+        Join<NotifyServiceEntity, NotifyServiceInboundPattern> notifyServiceInboundPatternJoin =
+            notifyServiceEntityRoot.join(NotifyServiceEntity_.inboundPatterns);
+
+        criteriaQuery.select(notifyServiceEntityRoot);
+        criteriaQuery.where(criteriaBuilder.and(
+                criteriaBuilder.equal(
+                    notifyServiceInboundPatternJoin.get(NotifyServiceInboundPattern_.pattern), pattern),
+                criteriaBuilder.equal(
+                    notifyServiceInboundPatternJoin.get(NotifyServiceInboundPattern_.automatic), false)));
+
+        return list(context, criteriaQuery, false, NotifyServiceEntity.class, -1, -1);
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/NotifyServiceInboundPatternDaoImpl.java b/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/NotifyServiceInboundPatternDaoImpl.java
new file mode 100644
index 0000000000..5168fd0bed
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/dao/impl/NotifyServiceInboundPatternDaoImpl.java
@@ -0,0 +1,59 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.dao.impl;
+
+import java.sql.SQLException;
+import java.util.List;
+import javax.persistence.criteria.CriteriaBuilder;
+import javax.persistence.criteria.CriteriaQuery;
+import javax.persistence.criteria.Root;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.NotifyServiceInboundPattern_;
+import org.dspace.app.ldn.dao.NotifyServiceInboundPatternDao;
+import org.dspace.core.AbstractHibernateDAO;
+import org.dspace.core.Context;
+
+/**
+ * Implementation of {@link NotifyServiceInboundPatternDao}.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyServiceInboundPatternDaoImpl
+    extends AbstractHibernateDAO<NotifyServiceInboundPattern> implements NotifyServiceInboundPatternDao {
+
+    @Override
+    public NotifyServiceInboundPattern findByServiceAndPattern(Context context, NotifyServiceEntity notifyServiceEntity,
+                                                               String pattern) throws SQLException {
+        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
+        CriteriaQuery criteriaQuery = getCriteriaQuery(criteriaBuilder, NotifyServiceInboundPattern.class);
+        Root<NotifyServiceInboundPattern> inboundPatternRoot = criteriaQuery.from(NotifyServiceInboundPattern.class);
+        criteriaQuery.select(inboundPatternRoot);
+        criteriaQuery.where(criteriaBuilder.and(
+            criteriaBuilder.equal(
+                inboundPatternRoot.get(NotifyServiceInboundPattern_.notifyService), notifyServiceEntity),
+            criteriaBuilder.equal(
+                inboundPatternRoot.get(NotifyServiceInboundPattern_.pattern), pattern)
+        ));
+        return uniqueResult(context, criteriaQuery, false, NotifyServiceInboundPattern.class);
+    }
+
+    @Override
+    public List<NotifyServiceInboundPattern> findAutomaticPatterns(Context context) throws SQLException {
+        CriteriaBuilder criteriaBuilder = getCriteriaBuilder(context);
+        CriteriaQuery criteriaQuery = getCriteriaQuery(criteriaBuilder, NotifyServiceInboundPattern.class);
+        Root<NotifyServiceInboundPattern> inboundPatternRoot = criteriaQuery.from(NotifyServiceInboundPattern.class);
+        criteriaQuery.select(inboundPatternRoot);
+        criteriaQuery.where(
+            criteriaBuilder.equal(
+                inboundPatternRoot.get(NotifyServiceInboundPattern_.automatic), true)
+        );
+        return list(context, criteriaQuery, false, NotifyServiceInboundPattern.class, -1, -1);
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNMessageServiceFactory.java b/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNMessageServiceFactory.java
new file mode 100644
index 0000000000..bbf521123b
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNMessageServiceFactory.java
@@ -0,0 +1,29 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.factory;
+
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.services.factory.DSpaceServicesFactory;
+
+/**
+ * Abstract factory to get services for the NotifyService package,
+ * use NotifyServiceFactory.getInstance() to retrieve an implementation
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.com)
+ */
+public abstract class LDNMessageServiceFactory {
+
+    public abstract LDNMessageService getLDNMessageService();
+
+    public static LDNMessageServiceFactory getInstance() {
+        return DSpaceServicesFactory.getInstance()
+                .getServiceManager()
+                .getServiceByName("ldnMessageServiceFactory",
+                    LDNMessageServiceFactory.class);
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNMessageServiceFactoryImpl.java b/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNMessageServiceFactoryImpl.java
new file mode 100644
index 0000000000..a001ece040
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNMessageServiceFactoryImpl.java
@@ -0,0 +1,29 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.factory;
+
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Factory implementation to get services for the notifyservices package, use
+ * NotifyServiceFactory.getInstance() to retrieve an implementation
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.com)
+ */
+public class LDNMessageServiceFactoryImpl extends LDNMessageServiceFactory {
+
+    @Autowired(required = true)
+    private LDNMessageService ldnMessageService;
+
+    @Override
+    public LDNMessageService getLDNMessageService() {
+        return ldnMessageService;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNRouterFactory.java b/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNRouterFactory.java
new file mode 100644
index 0000000000..4b0f107d24
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNRouterFactory.java
@@ -0,0 +1,29 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.factory;
+
+import org.dspace.app.ldn.LDNRouter;
+import org.dspace.services.factory.DSpaceServicesFactory;
+
+/**
+ * Abstract factory to get services for the ldn package, use
+ * LDNRouterFactory.getInstance() to retrieve an implementation
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.com)
+ */
+public abstract class LDNRouterFactory {
+
+    public abstract LDNRouter getLDNRouter();
+
+    public static LDNRouterFactory getInstance() {
+        return DSpaceServicesFactory.getInstance()
+            .getServiceManager()
+            .getServiceByName("ldnRouter",
+                LDNRouterFactory.class);
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNRouterFactoryImpl.java b/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNRouterFactoryImpl.java
new file mode 100644
index 0000000000..f411b9d935
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/factory/LDNRouterFactoryImpl.java
@@ -0,0 +1,28 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.factory;
+
+import org.dspace.app.ldn.LDNRouter;
+import org.springframework.beans.factory.annotation.Autowired;
+/**
+ * Factory implementation to get services for the ldn package,
+ * use ldnRouter spring bean instance to retrieve an implementation
+ *
+ * @author Francesco Bacchelli (mohamed.eskander at 4science.com)
+ */
+public class LDNRouterFactoryImpl extends LDNRouterFactory {
+
+    @Autowired(required = true)
+    private LDNRouter ldnRouter;
+
+    @Override
+    public LDNRouter getLDNRouter() {
+        return ldnRouter;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/factory/NotifyServiceFactory.java b/dspace-api/src/main/java/org/dspace/app/ldn/factory/NotifyServiceFactory.java
new file mode 100644
index 0000000000..ea488ca250
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/factory/NotifyServiceFactory.java
@@ -0,0 +1,36 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.factory;
+
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.ldn.service.NotifyPatternToTriggerService;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.services.factory.DSpaceServicesFactory;
+
+/**
+ * Abstract factory to get services for the NotifyService package,
+ * use NotifyServiceFactory.getInstance() to retrieve an implementation
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public abstract class NotifyServiceFactory {
+
+    public abstract NotifyService getNotifyService();
+
+    public abstract NotifyServiceInboundPatternService getNotifyServiceInboundPatternService();
+
+    public abstract NotifyPatternToTriggerService getNotifyPatternToTriggerService();
+
+    public abstract LDNMessageService getLDNMessageService();
+
+    public static NotifyServiceFactory getInstance() {
+        return DSpaceServicesFactory.getInstance().getServiceManager().getServiceByName(
+            "notifyServiceFactory", NotifyServiceFactory.class);
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/factory/NotifyServiceFactoryImpl.java b/dspace-api/src/main/java/org/dspace/app/ldn/factory/NotifyServiceFactoryImpl.java
new file mode 100644
index 0000000000..84e15ee261
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/factory/NotifyServiceFactoryImpl.java
@@ -0,0 +1,56 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.factory;
+
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.ldn.service.NotifyPatternToTriggerService;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Factory implementation to get services for the notifyservices package,
+ * use NotifyServiceFactory.getInstance() to retrieve an implementation
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyServiceFactoryImpl extends NotifyServiceFactory {
+
+    @Autowired(required = true)
+    private NotifyService notifyService;
+
+    @Autowired(required = true)
+    private NotifyServiceInboundPatternService notifyServiceInboundPatternService;
+
+    @Autowired(required = true)
+    private NotifyPatternToTriggerService notifyPatternToTriggerService;
+
+    @Autowired(required = true)
+    private LDNMessageService ldnMessageService;
+
+    @Override
+    public NotifyService getNotifyService() {
+        return notifyService;
+    }
+
+    @Override
+    public NotifyServiceInboundPatternService getNotifyServiceInboundPatternService() {
+        return notifyServiceInboundPatternService;
+    }
+
+    @Override
+    public NotifyPatternToTriggerService getNotifyPatternToTriggerService() {
+        return notifyPatternToTriggerService;
+    }
+
+    @Override
+    public LDNMessageService getLDNMessageService() {
+        return ldnMessageService;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/model/Actor.java b/dspace-api/src/main/java/org/dspace/app/ldn/model/Actor.java
new file mode 100644
index 0000000000..a81cc3f800
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/model/Actor.java
@@ -0,0 +1,41 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.model;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+/**
+ * used to map @see org.dspace.app.ldn.model.Notification
+ */
+public class Actor extends Base {
+
+    @JsonProperty("name")
+    private String name;
+
+    /**
+     * 
+     */
+    public Actor() {
+        super();
+    }
+
+    /**
+     * @return String
+     */
+    public String getName() {
+        return name;
+    }
+
+    /**
+     * @param name
+     */
+    public void setName(String name) {
+        this.name = name;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/model/Base.java b/dspace-api/src/main/java/org/dspace/app/ldn/model/Base.java
new file mode 100644
index 0000000000..6ddaae110e
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/model/Base.java
@@ -0,0 +1,115 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.model;
+
+import java.util.Collection;
+import java.util.HashSet;
+import java.util.Set;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonInclude;
+import com.fasterxml.jackson.annotation.JsonInclude.Include;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+/**
+ * used to map @see org.dspace.app.ldn.model.Notification
+ */
+@JsonInclude(Include.NON_EMPTY)
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class Base {
+
+    @JsonProperty("id")
+    private String id;
+
+    @JsonProperty("type")
+    private Set<String> type;
+
+    /**
+     * 
+     */
+    public Base() {
+        type = new HashSet<>();
+    }
+
+    /**
+     * @return String
+     */
+    public String getId() {
+        return id;
+    }
+
+    /**
+     * @param id
+     */
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    /**
+     * @return Set<String>
+     */
+    public Set<String> getType() {
+        return type;
+    }
+
+    /**
+     * @param type
+     */
+    public void setType(java.lang.Object type) {
+        if (type instanceof String) {
+            this.type.add((String) type);
+        } else if (type instanceof Collection) {
+            this.type.addAll((Collection) type);
+        }
+    }
+
+    /**
+     * @param type
+     */
+    public void addType(String type) {
+        this.type.add(type);
+    }
+
+    /**
+     * @return int
+     */
+    @Override
+    public int hashCode() {
+        final int prime = 31;
+        int result = 1;
+        result = prime * result + ((id == null) ? 0 : id.hashCode());
+        return result;
+    }
+
+    /**
+     * @param obj
+     * @return boolean
+     */
+    @Override
+    public boolean equals(java.lang.Object obj) {
+        if (this == obj) {
+            return true;
+        }
+        if (obj == null) {
+            return false;
+        }
+        if (getClass() != obj.getClass()) {
+            return false;
+        }
+        Base other = (Base) obj;
+        if (id == null) {
+            if (other.id != null) {
+                return false;
+            }
+        } else if (!id.equals(other.id)) {
+            return false;
+        }
+        return true;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/model/Citation.java b/dspace-api/src/main/java/org/dspace/app/ldn/model/Citation.java
new file mode 100644
index 0000000000..7abe5c8ef4
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/model/Citation.java
@@ -0,0 +1,59 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.model;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+
+/**
+ * used to map @see org.dspace.app.ldn.model.Notification
+ */
+public class Citation extends Base {
+
+    @JsonProperty("ietf:cite-as")
+    private String ietfCiteAs;
+
+    @JsonProperty("ietf:item")
+    private Url url;
+
+    /**
+     * 
+     */
+    public Citation() {
+        super();
+    }
+
+    /**
+     * @return String
+     */
+    public String getIetfCiteAs() {
+        return ietfCiteAs;
+    }
+
+    /**
+     * @param ietfCiteAs
+     */
+    public void setIetfCiteAs(String ietfCiteAs) {
+        this.ietfCiteAs = ietfCiteAs;
+    }
+
+    /**
+     * @return Url
+     */
+    public Url getUrl() {
+        return url;
+    }
+
+    /**
+     * @param url
+     */
+    public void setUrl(Url url) {
+        this.url = url;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/model/Context.java b/dspace-api/src/main/java/org/dspace/app/ldn/model/Context.java
new file mode 100644
index 0000000000..78fe373416
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/model/Context.java
@@ -0,0 +1,61 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.model;
+
+import java.util.List;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+
+/**
+ * used to map @see org.dspace.app.ldn.model.Notification
+ */
+public class Context extends Citation {
+
+    @JsonProperty("IsSupplementedBy")
+    private List<Context> isSupplementedBy;
+
+    @JsonProperty("IsSupplementTo")
+    private List<Context> isSupplementTo;
+
+    /**
+     * 
+     */
+    public Context() {
+        super();
+    }
+
+    /**
+     * @return List<Context>
+     */
+    public List<Context> getIsSupplementedBy() {
+        return isSupplementedBy;
+    }
+
+    /**
+     * @param isSupplementedBy
+     */
+    public void setIsSupplementedBy(List<Context> isSupplementedBy) {
+        this.isSupplementedBy = isSupplementedBy;
+    }
+
+    /**
+     * @return List<Context>
+     */
+    public List<Context> getIsSupplementTo() {
+        return isSupplementTo;
+    }
+
+    /**
+     * @param isSupplementTo
+     */
+    public void setIsSupplementTo(List<Context> isSupplementTo) {
+        this.isSupplementTo = isSupplementTo;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/model/Notification.java b/dspace-api/src/main/java/org/dspace/app/ldn/model/Notification.java
new file mode 100644
index 0000000000..52bc9840f4
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/model/Notification.java
@@ -0,0 +1,159 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.model;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonPropertyOrder;
+
+/**
+ * the json object from witch @see org.dspace.app.ldn.LDNMessageEntity are created.
+ * <a href="https://notify.coar-repositories.org/patterns/">see official coar doc</a>
+ */
+@JsonPropertyOrder(value = {
+    "@context",
+    "id",
+    "type",
+    "actor",
+    "context",
+    "object",
+    "origin",
+    "target",
+    "inReplyTo"
+})
+public class Notification extends Base {
+
+    @JsonProperty("@context")
+    private String[] c = new String[] {
+        "https://purl.org/coar/notify",
+        "https://www.w3.org/ns/activitystreams"
+    };
+
+    @JsonProperty("actor")
+    private Actor actor;
+
+    @JsonProperty("context")
+    private Context context;
+
+    @JsonProperty("object")
+    private Object object;
+
+    @JsonProperty("origin")
+    private Service origin;
+
+    @JsonProperty("target")
+    private Service target;
+
+    @JsonProperty("inReplyTo")
+    private String inReplyTo;
+
+    /**
+     * 
+     */
+    public Notification() {
+        super();
+    }
+
+    /**
+     * @return String[]
+     */
+    public String[] getC() {
+        return c;
+    }
+
+    /**
+     * @param c
+     */
+    public void setC(String[] c) {
+        this.c = c;
+    }
+
+    /**
+     * @return Actor
+     */
+    public Actor getActor() {
+        return actor;
+    }
+
+    /**
+     * @param actor
+     */
+    public void setActor(Actor actor) {
+        this.actor = actor;
+    }
+
+    /**
+     * @return Context
+     */
+    public Context getContext() {
+        return context;
+    }
+
+    /**
+     * @param context
+     */
+    public void setContext(Context context) {
+        this.context = context;
+    }
+
+    /**
+     * @return Object
+     */
+    public Object getObject() {
+        return object;
+    }
+
+    /**
+     * @param object
+     */
+    public void setObject(Object object) {
+        this.object = object;
+    }
+
+    /**
+     * @return Service
+     */
+    public Service getOrigin() {
+        return origin;
+    }
+
+    /**
+     * @param origin
+     */
+    public void setOrigin(Service origin) {
+        this.origin = origin;
+    }
+
+    /**
+     * @return Service
+     */
+    public Service getTarget() {
+        return target;
+    }
+
+    /**
+     * @param target
+     */
+    public void setTarget(Service target) {
+        this.target = target;
+    }
+
+    /**
+     * @return String
+     */
+    public String getInReplyTo() {
+        return inReplyTo;
+    }
+
+    /**
+     * @param inReplyTo
+     */
+    public void setInReplyTo(String inReplyTo) {
+        this.inReplyTo = inReplyTo;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/model/NotifyRequestStatus.java b/dspace-api/src/main/java/org/dspace/app/ldn/model/NotifyRequestStatus.java
new file mode 100644
index 0000000000..0302b528aa
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/model/NotifyRequestStatus.java
@@ -0,0 +1,63 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.model;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+
+import com.fasterxml.jackson.annotation.JsonPropertyOrder;
+
+@JsonPropertyOrder(value = {
+    "itemuuid",
+    "notifyStatus"
+})
+
+/**
+ * item requests of LDN messages of type
+ *
+ *    "Offer", "coar-notify:EndorsementAction"
+ *    "Offer", "coar-notify:IngestAction"
+ *    "Offer", "coar-notify:ReviewAction"
+ * 
+ * and their acknownledgements - if any
+ * 
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science dot it)
+ */
+public class NotifyRequestStatus extends Base {
+
+    private UUID itemUuid;
+
+    private List<RequestStatus> notifyStatus;
+
+    public NotifyRequestStatus() {
+        super();
+        this.notifyStatus = new ArrayList<RequestStatus>();
+    }
+
+    public UUID getItemUuid() {
+        return itemUuid;
+    }
+
+    public void setItemUuid(UUID itemUuid) {
+        this.itemUuid = itemUuid;
+    }
+
+    public void addRequestStatus(RequestStatus rs) {
+        this.notifyStatus.add(rs);
+    }
+
+    public List<RequestStatus> getNotifyStatus() {
+        return notifyStatus;
+    }
+
+    public void setNotifyStatus(List<RequestStatus> notifyStatus) {
+        this.notifyStatus = notifyStatus;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/model/NotifyRequestStatusEnum.java b/dspace-api/src/main/java/org/dspace/app/ldn/model/NotifyRequestStatusEnum.java
new file mode 100644
index 0000000000..437c624f84
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/model/NotifyRequestStatusEnum.java
@@ -0,0 +1,18 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.model;
+/**
+ * REQUESTED means acknowledgements not received yet
+ * ACCEPTED means acknowledgements of "Accept" type received
+ * REJECTED means ack of "TentativeReject" type received
+ * 
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.com)
+ */
+public enum NotifyRequestStatusEnum {
+    REJECTED, ACCEPTED, REQUESTED
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/model/Object.java b/dspace-api/src/main/java/org/dspace/app/ldn/model/Object.java
new file mode 100644
index 0000000000..8913af47da
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/model/Object.java
@@ -0,0 +1,74 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.model;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+/**
+ * used to map @see org.dspace.app.ldn.model.Notification
+ */
+public class Object extends Citation {
+
+    @JsonProperty("as:object")
+    private String asObject;
+
+    @JsonProperty("as:relationship")
+    private String asRelationship;
+
+    @JsonProperty("as:subject")
+    private String asSubject;
+
+    @JsonProperty("sorg:name")
+    private String title;
+
+    /**
+     * 
+     */
+    public Object() {
+        super();
+    }
+
+    /**
+     * @return String
+     */
+    public String getTitle() {
+        return title;
+    }
+
+    /**
+     * @param title
+     */
+    public void setTitle(String title) {
+        this.title = title;
+    }
+
+    public String getAsObject() {
+        return asObject;
+    }
+
+    public void setAsObject(String asObject) {
+        this.asObject = asObject;
+    }
+
+    public String getAsRelationship() {
+        return asRelationship;
+    }
+
+    public void setAsRelationship(String asRelationship) {
+        this.asRelationship = asRelationship;
+    }
+
+    public String getAsSubject() {
+        return asSubject;
+    }
+
+    public void setAsSubject(String asSubject) {
+        this.asSubject = asSubject;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/model/RequestStatus.java b/dspace-api/src/main/java/org/dspace/app/ldn/model/RequestStatus.java
new file mode 100644
index 0000000000..d193698307
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/model/RequestStatus.java
@@ -0,0 +1,47 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.model;
+
+/**
+ * Informations about the Offer and Acknowledgements targeting a specified Item
+ * 
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.com)
+ */
+public class RequestStatus {
+
+    private String serviceName;
+    private String serviceUrl;
+    private String offerType;
+    private NotifyRequestStatusEnum status;
+
+    public String getServiceName() {
+        return serviceName;
+    }
+    public void setServiceName(String serviceName) {
+        this.serviceName = serviceName;
+    }
+    public String getServiceUrl() {
+        return serviceUrl;
+    }
+    public void setServiceUrl(String serviceUrl) {
+        this.serviceUrl = serviceUrl;
+    }
+    public NotifyRequestStatusEnum getStatus() {
+        return status;
+    }
+    public void setStatus(NotifyRequestStatusEnum status) {
+        this.status = status;
+    }
+    public String getOfferType() {
+        return offerType;
+    }
+    public void setOfferType(String offerType) {
+        this.offerType = offerType;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/model/Service.java b/dspace-api/src/main/java/org/dspace/app/ldn/model/Service.java
new file mode 100644
index 0000000000..cdd3ba5bb5
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/model/Service.java
@@ -0,0 +1,41 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.model;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+/**
+ * used to map @see org.dspace.app.ldn.model.Notification
+ */
+public class Service extends Base {
+
+    @JsonProperty("inbox")
+    private String inbox;
+
+    /**
+     * 
+     */
+    public Service() {
+        super();
+    }
+
+    /**
+     * @return String
+     */
+    public String getInbox() {
+        return inbox;
+    }
+
+    /**
+     * @param inbox
+     */
+    public void setInbox(String inbox) {
+        this.inbox = inbox;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/model/Url.java b/dspace-api/src/main/java/org/dspace/app/ldn/model/Url.java
new file mode 100644
index 0000000000..47093e02e4
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/model/Url.java
@@ -0,0 +1,41 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.model;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+/**
+ * used to map @see org.dspace.app.ldn.model.Citation
+ */
+public class Url extends Base {
+
+    @JsonProperty("mediaType")
+    private String mediaType;
+
+    /**
+     * 
+     */
+    public Url() {
+        super();
+    }
+
+    /**
+     * @return String
+     */
+    public String getMediaType() {
+        return mediaType;
+    }
+
+    /**
+     * @param mediaType
+     */
+    public void setMediaType(String mediaType) {
+        this.mediaType = mediaType;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/processor/LDNContextRepeater.java b/dspace-api/src/main/java/org/dspace/app/ldn/processor/LDNContextRepeater.java
new file mode 100644
index 0000000000..a5ef0957ff
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/processor/LDNContextRepeater.java
@@ -0,0 +1,141 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.processor;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Objects;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.node.ArrayNode;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.model.Context;
+import org.dspace.app.ldn.model.Notification;
+
+/**
+ * Context repeater to iterate over array context properties of a received
+ * notification. The returned notification iterator is a notification with
+ * context array elements hoisted onto the root of the notification context.
+ */
+public class LDNContextRepeater {
+
+    private final static Logger log = LogManager.getLogger(LDNContextRepeater.class);
+
+    private final static String CONTEXT = "context";
+
+    private String repeatOver;
+
+    /**
+     * @return String
+     */
+    public String getRepeatOver() {
+        return repeatOver;
+    }
+
+    /**
+     * @param repeatOver
+     */
+    public void setRepeatOver(String repeatOver) {
+        this.repeatOver = repeatOver;
+    }
+
+    /**
+     * @param  notification
+     * @return Iterator<Notification>
+     */
+    public Iterator<Notification> iterator(Notification notification) {
+        return new NotificationIterator(notification, repeatOver);
+    }
+
+    /**
+     * Private inner class defining the notification iterator.
+     */
+    private class NotificationIterator implements Iterator<Notification> {
+
+        private final List<Notification> notifications;
+
+        /**
+         * Convert notification to JsonNode in order to clone for each context array
+         * element. Each element is then hoisted to the root of the cloned notification
+         * context.
+         *
+         * @param notification received notification
+         * @param repeatOver   which context property to repeat over
+         */
+        private NotificationIterator(Notification notification, String repeatOver) {
+            this.notifications = new ArrayList<>();
+
+            if (Objects.nonNull(repeatOver)) {
+                ObjectMapper objectMapper = new ObjectMapper();
+
+                JsonNode notificationNode = objectMapper.valueToTree(notification);
+
+                log.debug("Notification {}", notificationNode);
+
+                JsonNode topContextNode = notificationNode.get(CONTEXT);
+                if (topContextNode.isNull()) {
+                    log.warn("Notification is missing context");
+                    return;
+                }
+
+                JsonNode contextArrayNode = topContextNode.get(repeatOver);
+                if (contextArrayNode == null || contextArrayNode.isNull()) {
+                    log.error("Notification context {} is not defined", repeatOver);
+                    return;
+                }
+
+                if (contextArrayNode.isArray()) {
+
+                    for (JsonNode contextNode : ((ArrayNode) contextArrayNode)) {
+
+                        try {
+                            Context context = objectMapper.treeToValue(contextNode, Context.class);
+
+                            Notification copy = objectMapper.treeToValue(notificationNode, Notification.class);
+
+                            copy.setContext(context);
+
+                            this.notifications.add(copy);
+                        } catch (JsonProcessingException e) {
+                            log.error("Failed to copy notification");
+                        }
+
+                    }
+
+                } else {
+                    log.error("Notification context {} is not an array", repeatOver);
+                }
+
+            } else {
+                this.notifications.add(notification);
+            }
+        }
+
+        /**
+         * @return boolean
+         */
+        @Override
+        public boolean hasNext() {
+            return !this.notifications.isEmpty();
+        }
+
+        /**
+         * @return Notification
+         */
+        @Override
+        public Notification next() {
+            return this.notifications.remove(0);
+        }
+
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/processor/LDNMetadataProcessor.java b/dspace-api/src/main/java/org/dspace/app/ldn/processor/LDNMetadataProcessor.java
new file mode 100644
index 0000000000..43c50173ee
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/processor/LDNMetadataProcessor.java
@@ -0,0 +1,231 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.processor;
+
+import static java.lang.String.format;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Objects;
+import java.util.Set;
+import java.util.UUID;
+
+import org.apache.http.HttpStatus;
+import org.apache.http.client.HttpResponseException;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.action.LDNAction;
+import org.dspace.app.ldn.action.LDNActionStatus;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.ldn.utility.LDNUtils;
+import org.dspace.content.DSpaceObject;
+import org.dspace.content.Item;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Constants;
+import org.dspace.core.Context;
+import org.dspace.handle.service.HandleService;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Linked Data Notification metadata processor for consuming notifications. The
+ * storage of notification details are within item metadata.
+ */
+public class LDNMetadataProcessor implements LDNProcessor {
+
+    private final static Logger log = LogManager.getLogger(LDNMetadataProcessor.class);
+
+    @Autowired
+    private ItemService itemService;
+
+    @Autowired
+    private LDNMessageService ldnMessageService;
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    private static final Set<String> OBJECT_SUBJECT_ITEM_TYPES = Set.of(
+        "Announce",
+        "coar-notify:RelationshipAction");
+
+    private static final Set<String> CONTEXT_ID_ITEM_TYPES = Set.of(
+        "Announce",
+        "TentativeReject",
+        "Accept",
+        "coar-notify:ReviewAction",
+        "coar-notify:IngestAction",
+        "coar-notify:EndorsementAction");
+
+    private static final Set<String> OBJECT_ID_ITEM_TYPES = Set.of(
+        "Offer",
+        "coar-notify:ReviewAction",
+        "coar-notify:EndorsementAction",
+        "coar-notify:IngestAction");
+
+    @Autowired
+    private HandleService handleService;
+
+    private LDNContextRepeater repeater = new LDNContextRepeater();
+
+    private List<LDNAction> actions = new ArrayList<>();
+
+    /**
+     * Initialize velocity engine for templating.
+     */
+    private LDNMetadataProcessor() {
+
+    }
+
+    /**
+     * Process notification by repeating over context, processing each context
+     * notification, and running actions post processing.
+     *
+     * @param notification received notification
+     * @throws Exception something went wrong processing the notification
+     */
+    @Override
+    public void process(Context context, Notification notification) throws Exception {
+        Item item = lookupItem(context, notification);
+        runActions(context, notification, item);
+    }
+
+    /**
+     * Run all actions defined for the processor.
+     *
+     * @param notification current context notification
+     * @param item         associated item
+     *
+     * @return ActionStatus result status of running the action
+     *
+     * @throws Exception failed execute the action
+     */
+    private LDNActionStatus runActions(Context context, Notification notification, Item item) throws Exception {
+        LDNActionStatus operation = LDNActionStatus.CONTINUE;
+        for (LDNAction action : actions) {
+            log.info("Running action {} for notification {} {}",
+                    action.getClass().getSimpleName(),
+                    notification.getId(),
+                    notification.getType());
+
+            operation = action.execute(context, notification, item);
+            if (operation == LDNActionStatus.ABORT) {
+                break;
+            }
+        }
+
+        return operation;
+    }
+
+    /**
+     * @return LDNContextRepeater
+     */
+    public LDNContextRepeater getRepeater() {
+        return repeater;
+    }
+
+    /**
+     * @param repeater
+     */
+    public void setRepeater(LDNContextRepeater repeater) {
+        this.repeater = repeater;
+    }
+
+    /**
+     * @return List<LDNAction>
+     */
+    public List<LDNAction> getActions() {
+        return actions;
+    }
+
+    /**
+     * @param actions
+     */
+    public void setActions(List<LDNAction> actions) {
+        this.actions = actions;
+    }
+
+    /**
+     * Lookup associated item to the notification context. If UUID in URL, lookup bu
+     * UUID, else lookup by handle.
+     *
+     * @param context      current context
+     * @param notification current context notification
+     *
+     * @return Item associated item
+     *
+     * @throws SQLException failed to lookup item
+     * @throws HttpResponseException redirect failure
+     */
+    private Item lookupItem(Context context, Notification notification) throws SQLException, HttpResponseException {
+        Item item = null;
+        String url = null;
+
+        if (CONTEXT_ID_ITEM_TYPES.containsAll(notification.getType())) {
+            url = notification.getContext().getId();
+        } else if (OBJECT_ID_ITEM_TYPES.containsAll(notification.getType())) {
+            url = notification.getObject().getId();
+        } else if (OBJECT_SUBJECT_ITEM_TYPES.containsAll(notification.getType())) {
+            // need to understand if we're sender or receiver
+            if (ldnMessageService.isTargetCurrent(notification)) {
+                // this means we're sending the notification
+                url = notification.getObject().getAsObject();
+                // use as:object for sender
+            } else {
+                // this means we're receiving the notification
+                url = notification.getObject().getAsSubject();
+                // use as:subject for receiver
+            }
+        }
+
+        log.info("Looking up item {}", url);
+
+        item = resolveItemByUrl(context, url, notification);
+
+        return item;
+    }
+
+    private Item resolveItemByUrl(Context context, String url, Notification notification)
+        throws SQLException, HttpResponseException {
+        Item item = null;
+        if (LDNUtils.hasUUIDInURL(url)) {
+            UUID uuid = LDNUtils.getUUIDFromURL(url);
+
+            item = itemService.find(context, uuid);
+
+            if (Objects.isNull(item)) {
+                throw new HttpResponseException(HttpStatus.SC_NOT_FOUND,
+                    format("Item with uuid %s not found", uuid));
+            }
+            return item;
+        }
+        String handle = handleService.resolveUrlToHandle(context, url);
+
+        if (Objects.isNull(handle)) {
+            throw new HttpResponseException(HttpStatus.SC_NOT_FOUND,
+                format("Handle not found for %s", url));
+        }
+
+        DSpaceObject object = handleService.resolveToObject(context, handle);
+
+        if (Objects.isNull(object)) {
+            throw new HttpResponseException(HttpStatus.SC_NOT_FOUND,
+                format("Item with handle %s not found", handle));
+        }
+
+        if (object.getType() == Constants.ITEM) {
+            item = (Item) object;
+        } else {
+            throw new HttpResponseException(HttpStatus.SC_UNPROCESSABLE_ENTITY,
+                format("Handle %s does not resolve to an item", handle));
+        }
+        return item;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/processor/LDNProcessor.java b/dspace-api/src/main/java/org/dspace/app/ldn/processor/LDNProcessor.java
new file mode 100644
index 0000000000..279ec5cedc
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/processor/LDNProcessor.java
@@ -0,0 +1,25 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.processor;
+
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.core.Context;
+
+/**
+ * Processor interface to allow for custom implementations of process.
+ */
+public interface LDNProcessor {
+
+    /**
+     * Process received notification.
+     *
+     * @param notification received notification
+     * @throws Exception something went wrong processing the notification
+     */
+    public void process(Context context, Notification notification) throws Exception;
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/service/LDNMessageService.java b/dspace-api/src/main/java/org/dspace/app/ldn/service/LDNMessageService.java
new file mode 100644
index 0000000000..eb18c6a69a
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/service/LDNMessageService.java
@@ -0,0 +1,165 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.service;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.model.NotifyRequestStatus;
+import org.dspace.app.ldn.model.Service;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+
+/**
+ * Service interface class for the {@link LDNMessageEntity} object.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science dot it)
+ */
+public interface LDNMessageService {
+
+    /**
+     * find the ldn message by id
+     *
+     * @param context the context
+     * @param id the uri
+     * @return the ldn message by id
+     * @throws SQLException If something goes wrong in the database
+     */
+    public LDNMessageEntity find(Context context, String id) throws SQLException;
+
+    /**
+     * find all ldn messages
+     *
+     * @param context the context
+     * @return all ldn messages by id
+     * @throws SQLException If something goes wrong in the database
+     */
+    public List<LDNMessageEntity> findAll(Context context) throws SQLException;
+
+    /**
+     * Creates a new LDNMessage
+     *
+     * @param context The DSpace context
+     * @param id the uri
+     * @return the created LDN Message
+     * @throws SQLException If something goes wrong in the database
+     */
+    public LDNMessageEntity create(Context context, String id) throws SQLException;
+
+    /**
+     * Creates a new LDNMessage
+     *
+     * @param context The DSpace context
+     * @param notification the requested notification
+     * @param sourceIp the source ip
+     * @return the created LDN Message
+     * @throws SQLException If something goes wrong in the database
+     */
+    public LDNMessageEntity create(Context context, Notification notification, String sourceIp) throws SQLException;
+
+    /**
+     * Update the provided LDNMessage
+     *
+     * @param context The DSpace context
+     * @param ldnMessage the LDNMessage
+     * @throws SQLException If something goes wrong in the database
+     */
+    public void update(Context context, LDNMessageEntity ldnMessage) throws SQLException;
+
+    /**
+     * Find the oldest queued LDNMessages that still can be elaborated
+     *
+     * @return list of LDN messages
+     * @param context The DSpace context
+     * @throws SQLException If something goes wrong in the database
+     */
+    public List<LDNMessageEntity> findOldestMessagesToProcess(Context context) throws SQLException;
+
+    /**
+     * Find all messages in the queue with the Processing status but timed-out
+     * 
+     * @return all the LDN Messages to be fixed on their queue_ attributes
+     * @param context The DSpace context
+     * @throws SQLException If something goes wrong in the database
+     */
+    public List<LDNMessageEntity> findProcessingTimedoutMessages(Context context) throws SQLException;
+
+    /**
+     * Find all messages in the queue with the Processing status but timed-out and modify their queue_status
+     * considering the queue_attempts
+     * 
+     * @return number of messages fixed
+     * @param context The DSpace context
+     * @throws SQLException
+     */
+    public int checkQueueMessageTimeout(Context context) throws SQLException;
+
+    /**
+     * Elaborates the oldest enqueued message
+     * 
+     * @return number of messages fixed
+     * @param context The DSpace context
+     */
+    public int extractAndProcessMessageFromQueue(Context context) throws SQLException;
+
+    /**
+     * find the related notify service entity
+     *
+     * @param context the context
+     * @param service the service
+     * @return the NotifyServiceEntity
+     * @throws SQLException if something goes wrong
+     */
+    public NotifyServiceEntity findNotifyService(Context context, Service service) throws SQLException;
+
+    /**
+     * find the ldn messages of Requests by item uuid
+     *
+     * @param context the context
+     * @param item the item
+     * @return the item requests object
+     * @throws SQLException If something goes wrong in the database
+     */
+    public NotifyRequestStatus findRequestsByItem(Context context, Item item) throws SQLException;
+
+    /**
+     * delete the provided ldn message
+     *
+     * @param context the context
+     * @param ldnMessage the ldn message
+     * @throws SQLException if something goes wrong
+     */
+    public void delete(Context context, LDNMessageEntity ldnMessage) throws SQLException;
+
+    /**
+     * find the ldn messages to be reprocessed
+     *
+     * @param context the context
+     * @throws SQLException if something goes wrong
+     */
+    public List<LDNMessageEntity> findMessagesToBeReprocessed(Context context) throws SQLException;
+
+    /**
+     * check if IP number is included in the configured ip-range on the Notify
+     * Service
+     * 
+     * @param origin   the Notify Service entity
+     * @param sourceIp the ip to evaluate
+     */
+    public boolean isValidIp(NotifyServiceEntity origin, String sourceIp);
+
+    /**
+     * check if the notification is targeting the current system
+     * 
+     * @param notification   the LDN Message entity
+     */
+    boolean isTargetCurrent(Notification notification);
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/service/NotifyPatternToTriggerService.java b/dspace-api/src/main/java/org/dspace/app/ldn/service/NotifyPatternToTriggerService.java
new file mode 100644
index 0000000000..c2c3de7e06
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/service/NotifyPatternToTriggerService.java
@@ -0,0 +1,84 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.service;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyPatternToTrigger;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+
+/**
+ * Service interface class for the {@link NotifyPatternToTrigger} object.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public interface NotifyPatternToTriggerService {
+
+    /**
+     * find all notify patterns to be triggered
+     *
+     * @param context the context
+     * @return all notify patterns to be trigger
+     * @throws SQLException if database error
+     */
+    public List<NotifyPatternToTrigger> findAll(Context context) throws SQLException;
+
+    /**
+     * find list of Notify Patterns To be Triggered by item
+     *
+     * @param context the context
+     * @param item the item of NotifyPatternToTrigger
+     * @return the matched NotifyPatternToTrigger list by item
+     * @throws SQLException if database error
+     */
+    public List<NotifyPatternToTrigger> findByItem(Context context, Item item)
+        throws SQLException;
+
+    /**
+     * find list of Notify Patterns To be Triggered by item and pattern
+     *
+     * @param context the context
+     * @param item the item of NotifyPatternToTrigger
+     * @param pattern the pattern of NotifyPatternToTrigger
+     *
+     * @return the matched NotifyPatternToTrigger list by item and pattern
+     * @throws SQLException if database error
+     */
+    public List<NotifyPatternToTrigger> findByItemAndPattern(Context context, Item item, String pattern)
+        throws SQLException;
+
+    /**
+     * create new notifyPatternToTrigger
+     *
+     * @param context the context
+     * @return the created NotifyPatternToTrigger
+     * @throws SQLException if database error
+     */
+    public NotifyPatternToTrigger create(Context context) throws SQLException;
+
+    /**
+     * update the provided notifyPatternToTrigger
+     *
+     * @param context the context
+     * @param notifyPatternToTrigger the notifyPatternToTrigger
+     * @throws SQLException if database error
+     */
+    public void update(Context context, NotifyPatternToTrigger notifyPatternToTrigger) throws SQLException;
+
+    /**
+     * delete the provided notifyPatternToTrigger
+     *
+     * @param context the context
+     * @param notifyPatternToTrigger the notifyPatternToTrigger
+     * @throws SQLException if database error
+     */
+    public void delete(Context context, NotifyPatternToTrigger notifyPatternToTrigger) throws SQLException;
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/service/NotifyService.java b/dspace-api/src/main/java/org/dspace/app/ldn/service/NotifyService.java
new file mode 100644
index 0000000000..6ff4c34780
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/service/NotifyService.java
@@ -0,0 +1,91 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.service;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.core.Context;
+
+/**
+ * Service interface class for the {@link NotifyServiceEntity} object.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public interface NotifyService {
+
+    /**
+     * find all notify service entities
+     *
+     * @param context the context
+     * @return all notify service entities
+     * @throws SQLException if database error
+     */
+    public List<NotifyServiceEntity> findAll(Context context) throws SQLException;
+
+    /**
+     * find one NotifyServiceEntity by id
+     *
+     * @param context the context
+     * @param id the id of NotifyServiceEntity
+     * @return the matched NotifyServiceEntity by id
+     * @throws SQLException if database error
+     */
+    public NotifyServiceEntity find(Context context, Integer id) throws SQLException;
+
+    /**
+     * create new notifyServiceEntity
+     *
+     * @param context the context
+     * @return the created NotifyServiceEntity
+     * @throws SQLException if database error
+     */
+    public NotifyServiceEntity create(Context context) throws SQLException;
+
+    /**
+     * update the provided notifyServiceEntity
+     *
+     * @param context the context
+     * @param notifyServiceEntity the notifyServiceEntity
+     * @throws SQLException if database error
+     */
+    public void update(Context context, NotifyServiceEntity notifyServiceEntity) throws SQLException;
+
+    /**
+     * delete the provided notifyServiceEntity
+     *
+     * @param context the context
+     * @param notifyServiceEntity the notifyServiceEntity
+     * @throws SQLException if database error
+     */
+    public void delete(Context context, NotifyServiceEntity notifyServiceEntity) throws SQLException;
+
+    /**
+     * find the NotifyServiceEntity matched with the provided ldnUrl
+     *
+     * @param context the context
+     * @param ldnUrl the ldnUrl
+     * @return the NotifyServiceEntity matched the provided ldnUrl
+     * @throws SQLException if database error
+     */
+    public NotifyServiceEntity findByLdnUrl(Context context, String ldnUrl) throws SQLException;
+
+    /**
+     * find all NotifyServiceEntity matched the provided inbound pattern
+     * from its related notifyServiceInboundPatterns
+     * also with 'automatic' equals to false
+     *
+     * @param context the context
+     * @param pattern the ldnUrl
+     * @return all NotifyServiceEntity matched the provided pattern
+     * @throws SQLException if database error
+     */
+    public List<NotifyServiceEntity> findManualServicesByInboundPattern(Context context, String pattern)
+        throws SQLException;
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/service/NotifyServiceInboundPatternService.java b/dspace-api/src/main/java/org/dspace/app/ldn/service/NotifyServiceInboundPatternService.java
new file mode 100644
index 0000000000..8cd92d45dd
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/service/NotifyServiceInboundPatternService.java
@@ -0,0 +1,76 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.service;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.core.Context;
+
+/**
+ * Service interface class for the {@link NotifyServiceInboundPattern} object.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public interface NotifyServiceInboundPatternService {
+
+    /**
+     * find all notifyServiceInboundPatterns matched with
+     * the provided notifyServiceEntity and pattern
+     *
+     * @param context the context
+     * @param notifyServiceEntity the notifyServiceEntity
+     * @param pattern the pattern
+     * @return all notifyServiceInboundPatterns matched with
+     * the provided notifyServiceEntity and pattern
+     * @throws SQLException if database error
+     */
+    public NotifyServiceInboundPattern findByServiceAndPattern(Context context,
+                                                               NotifyServiceEntity notifyServiceEntity,
+                                                               String pattern) throws SQLException;
+
+    /**
+     * find all automatic notifyServiceInboundPatterns
+     *
+     * @param context the context
+     * @return all automatic notifyServiceInboundPatterns
+     * @throws SQLException if database error
+     */
+    public List<NotifyServiceInboundPattern> findAutomaticPatterns(Context context) throws SQLException;
+
+    /**
+     * create new notifyServiceInboundPattern
+     *
+     * @param context the context
+     * @param notifyServiceEntity the notifyServiceEntity
+     * @return the created notifyServiceInboundPattern
+     * @throws SQLException if database error
+     */
+    public NotifyServiceInboundPattern create(Context context, NotifyServiceEntity notifyServiceEntity)
+        throws SQLException;
+
+    /**
+     * update the provided notifyServiceInboundPattern
+     *
+     * @param context the context
+     * @param inboundPattern the notifyServiceInboundPattern
+     * @throws SQLException if database error
+     */
+    public void update(Context context, NotifyServiceInboundPattern inboundPattern) throws SQLException;
+
+    /**
+     * delete the provided notifyServiceInboundPattern
+     *
+     * @param context the context
+     * @param inboundPattern the notifyServiceInboundPattern
+     * @throws SQLException if database error
+     */
+    public void delete(Context context, NotifyServiceInboundPattern inboundPattern) throws SQLException;
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/LDNMessageServiceImpl.java b/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/LDNMessageServiceImpl.java
new file mode 100644
index 0000000000..15f07a5561
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/LDNMessageServiceImpl.java
@@ -0,0 +1,404 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.service.impl;
+
+import java.net.InetAddress;
+import java.net.UnknownHostException;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Collections;
+import java.util.Date;
+import java.util.List;
+import java.util.Optional;
+import java.util.Set;
+import java.util.UUID;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.google.gson.JsonSyntaxException;
+import org.apache.commons.lang.time.DateUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.LDNRouter;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.dao.LDNMessageDao;
+import org.dspace.app.ldn.dao.NotifyServiceDao;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.model.NotifyRequestStatus;
+import org.dspace.app.ldn.model.NotifyRequestStatusEnum;
+import org.dspace.app.ldn.model.RequestStatus;
+import org.dspace.app.ldn.model.Service;
+import org.dspace.app.ldn.processor.LDNProcessor;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.ldn.utility.LDNUtils;
+import org.dspace.content.DSpaceObject;
+import org.dspace.content.Item;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Constants;
+import org.dspace.core.Context;
+import org.dspace.discovery.indexobject.IndexableLDNNotification;
+import org.dspace.event.Event;
+import org.dspace.handle.service.HandleService;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+
+/**
+ * Implementation of {@link LDNMessageService}
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science dot it)
+ */
+public class LDNMessageServiceImpl implements LDNMessageService {
+
+    @Autowired(required = true)
+    private LDNMessageDao ldnMessageDao;
+    @Autowired(required = true)
+    private NotifyServiceDao notifyServiceDao;
+    @Autowired(required = true)
+    private ConfigurationService configurationService;
+    @Autowired(required = true)
+    private HandleService handleService;
+    @Autowired(required = true)
+    private ItemService itemService;
+    @Autowired(required = true)
+    private LDNRouter ldnRouter;
+
+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(LDNMessageServiceImpl.class);
+    private static final String LDN_ID_PREFIX = "urn:uuid:";
+
+    protected LDNMessageServiceImpl() {
+
+    }
+
+    @Override
+    public LDNMessageEntity find(Context context, String id) throws SQLException {
+
+        if (id == null) {
+            return null;
+        }
+
+        id = id.startsWith(LDN_ID_PREFIX) ? id : LDN_ID_PREFIX + id;
+        return ldnMessageDao.findByID(context, LDNMessageEntity.class, id);
+    }
+
+    @Override
+    public List<LDNMessageEntity> findAll(Context context) throws SQLException {
+        return ldnMessageDao.findAll(context, LDNMessageEntity.class);
+    }
+
+    @Override
+    public LDNMessageEntity create(Context context, String id) throws SQLException {
+        LDNMessageEntity result = ldnMessageDao.findByID(context, LDNMessageEntity.class, id);
+        if (result != null) {
+            throw new SQLException("Duplicate LDN Message ID [" + id + "] detected. This message is rejected.");
+        }
+        return ldnMessageDao.create(context, new LDNMessageEntity(id));
+    }
+
+    @Override
+    public LDNMessageEntity create(Context context, Notification notification, String sourceIp) throws SQLException {
+        LDNMessageEntity ldnMessage = create(context, notification.getId());
+        DSpaceObject obj = findDspaceObjectByUrl(context, notification.getObject().getId());
+        if (obj == null) {
+            if (isTargetCurrent(notification)) {
+                // this means we're sending the notification
+                obj = findDspaceObjectByUrl(context, notification.getObject().getAsObject());
+                // use as:object for sender
+            } else {
+                // this means we're receiving the notification
+                obj = findDspaceObjectByUrl(context, notification.getObject().getAsSubject());
+                // use as:subject for receiver
+            }
+        }
+        ldnMessage.setObject(obj);
+        if (null != notification.getContext()) {
+            ldnMessage.setContext(findDspaceObjectByUrl(context, notification.getContext().getId()));
+        }
+        ldnMessage.setOrigin(findNotifyService(context, notification.getOrigin()));
+        ldnMessage.setInReplyTo(find(context, notification.getInReplyTo()));
+        ObjectMapper mapper = new ObjectMapper();
+        String message = null;
+        try {
+            message = mapper.writeValueAsString(notification);
+            ldnMessage.setMessage(message);
+        } catch (JsonProcessingException e) {
+            log.error("Notification json can't be correctly processed " +
+                "and stored inside the LDN Message Entity" + ldnMessage);
+            log.error(e);
+        }
+        ldnMessage.setType(StringUtils.joinWith(",", notification.getType()));
+        Set<String> notificationType = notification.getType();
+        if (notificationType == null) {
+            log.error("Notification has no notificationType attribute! " + notification);
+            return null;
+        }
+        ArrayList<String> notificationTypeArrayList = new ArrayList<String>(notificationType);
+        // sorting the list
+        Collections.sort(notificationTypeArrayList);
+        ldnMessage.setActivityStreamType(notificationTypeArrayList.get(0));
+        if (notificationTypeArrayList.size() > 1) {
+            ldnMessage.setCoarNotifyType(notificationTypeArrayList.get(1));
+        }
+        ldnMessage.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_QUEUED);
+        ldnMessage.setSourceIp(sourceIp);
+        if (ldnMessage.getOrigin() == null && !"Offer".equalsIgnoreCase(ldnMessage.getActivityStreamType())) {
+            ldnMessage.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_UNTRUSTED);
+        } else {
+
+            boolean ipCheckRangeEnabled = configurationService.getBooleanProperty("ldn.ip-range.enabled", true);
+            if (ipCheckRangeEnabled && !isValidIp(ldnMessage.getOrigin(), sourceIp)) {
+                ldnMessage.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_UNTRUSTED_IP);
+            }
+        }
+        ldnMessage.setQueueTimeout(new Date());
+
+        update(context, ldnMessage);
+        return ldnMessage;
+    }
+
+    @Override
+    public boolean isValidIp(NotifyServiceEntity origin, String sourceIp) {
+
+        String lowerIp = origin.getLowerIp();
+        String upperIp = origin.getUpperIp();
+
+        try {
+            InetAddress ip = InetAddress.getByName(sourceIp);
+            InetAddress lowerBoundAddress = InetAddress.getByName(lowerIp);
+            InetAddress upperBoundAddress = InetAddress.getByName(upperIp);
+
+            long ipLong = ipToLong(ip);
+            long lowerBoundLong = ipToLong(lowerBoundAddress);
+            long upperBoundLong = ipToLong(upperBoundAddress);
+
+            return ipLong >= lowerBoundLong && ipLong <= upperBoundLong;
+        } catch (UnknownHostException e) {
+            return false;
+        }
+    }
+
+    private long ipToLong(InetAddress ip) {
+        byte[] octets = ip.getAddress();
+        long result = 0;
+        for (byte octet : octets) {
+            result <<= 8;
+            result |= octet & 0xff;
+        }
+        return result;
+    }
+
+    @Override
+    public void update(Context context, LDNMessageEntity ldnMessage) throws SQLException {
+        // move the queue_status from UNTRUSTED to QUEUED if origin is a known NotifyService
+        if (ldnMessage.getOrigin() != null &&
+            LDNMessageEntity.QUEUE_STATUS_UNTRUSTED.compareTo(ldnMessage.getQueueStatus()) == 0) {
+            ldnMessage.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_QUEUED);
+        }
+        ldnMessageDao.save(context, ldnMessage);
+        UUID notificationUUID = UUID.fromString(ldnMessage.getID().replace(LDN_ID_PREFIX, ""));
+        ArrayList<String> identifiersList = new ArrayList<String>();
+        identifiersList.add(ldnMessage.getID());
+        context.addEvent(
+            new Event(Event.MODIFY, Constants.LDN_MESSAGE,
+                notificationUUID,
+                IndexableLDNNotification.TYPE, identifiersList));
+    }
+
+    private DSpaceObject findDspaceObjectByUrl(Context context, String url) throws SQLException {
+        String dspaceUrl = configurationService.getProperty("dspace.ui.url") + "/handle/";
+
+        if (StringUtils.startsWith(url, dspaceUrl)) {
+            return handleService.resolveToObject(context, url.substring(dspaceUrl.length()));
+        }
+
+        String handleResolver = configurationService.getProperty("handle.canonical.prefix", "https://hdl.handle.net/");
+        if (StringUtils.startsWith(url, handleResolver)) {
+            return handleService.resolveToObject(context, url.substring(handleResolver.length()));
+        }
+
+        dspaceUrl = configurationService.getProperty("dspace.ui.url") + "/items/";
+        if (StringUtils.startsWith(url, dspaceUrl)) {
+            return itemService.find(context, UUID.fromString(url.substring(dspaceUrl.length())));
+        }
+
+        return null;
+    }
+
+    public NotifyServiceEntity findNotifyService(Context context, Service service) throws SQLException {
+        return notifyServiceDao.findByLdnUrl(context, service.getInbox());
+    }
+
+    @Override
+    public List<LDNMessageEntity> findOldestMessagesToProcess(Context context) throws SQLException {
+        List<LDNMessageEntity> result = null;
+        int max_attempts = configurationService.getIntProperty("ldn.processor.max.attempts");
+        result = ldnMessageDao.findOldestMessageToProcess(context, max_attempts);
+        return result;
+    }
+
+    @Override
+    public List<LDNMessageEntity> findMessagesToBeReprocessed(Context context) throws SQLException {
+        List<LDNMessageEntity> result = null;
+        result = ldnMessageDao.findMessagesToBeReprocessed(context);
+        return result;
+    }
+
+    @Override
+    public List<LDNMessageEntity> findProcessingTimedoutMessages(Context context) throws SQLException {
+        List<LDNMessageEntity> result = null;
+        int max_attempts = configurationService.getIntProperty("ldn.processor.max.attempts");
+        result = ldnMessageDao.findProcessingTimedoutMessages(context, max_attempts);
+        return result;
+    }
+
+    @Override
+    public int extractAndProcessMessageFromQueue(Context context) throws SQLException {
+        int count = 0;
+        int timeoutInMinutes = configurationService.getIntProperty("ldn.processor.queue.msg.timeout", 60);
+
+        List<LDNMessageEntity> messages = findOldestMessagesToProcess(context);
+        messages.addAll(findMessagesToBeReprocessed(context));
+
+        Optional<LDNMessageEntity> msgOpt = getSingleMessageEntity(messages);
+
+        while (msgOpt.isPresent()) {
+            LDNProcessor processor = null;
+            LDNMessageEntity msg = msgOpt.get();
+            processor = ldnRouter.route(msg);
+            try {
+                boolean isServiceDisabled = !isServiceEnabled(msg);
+                if (processor == null || isServiceDisabled) {
+                    log.warn("No processor found for LDN message " + msg);
+                    Integer status = isServiceDisabled ? LDNMessageEntity.QUEUE_STATUS_UNTRUSTED
+                        : LDNMessageEntity.QUEUE_STATUS_UNMAPPED_ACTION;
+                    msg.setQueueStatus(status);
+                    msg.setQueueAttempts(msg.getQueueAttempts() + 1);
+                    update(context, msg);
+                } else {
+                    msg.setQueueLastStartTime(new Date());
+                    msg.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_PROCESSING);
+                    msg.setQueueTimeout(DateUtils.addMinutes(new Date(), timeoutInMinutes));
+                    update(context, msg);
+                    ObjectMapper mapper = new ObjectMapper();
+                    Notification notification = mapper.readValue(msg.getMessage(), Notification.class);
+                    processor.process(context, notification);
+                    msg.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_PROCESSED);
+                    count++;
+                }
+            } catch (JsonSyntaxException jse) {
+                log.error("Unable to read JSON notification from LdnMessage " + msg, jse);
+                msg.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_FAILED);
+            } catch (Exception e) {
+                log.error(e);
+                msg.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_FAILED);
+            } finally {
+                msg.setQueueAttempts(msg.getQueueAttempts() + 1);
+                update(context, msg);
+            }
+
+            messages = findOldestMessagesToProcess(context);
+            messages.addAll(findMessagesToBeReprocessed(context));
+            msgOpt = getSingleMessageEntity(messages);
+        }
+        return count;
+    }
+
+    private boolean isServiceEnabled(LDNMessageEntity msg) {
+        String localInboxUrl = configurationService.getProperty("ldn.notify.inbox");
+        if (msg.getTarget() == null || StringUtils.equals(msg.getTarget().getLdnUrl(), localInboxUrl)) {
+            return msg.getOrigin().isEnabled();
+        }
+        return msg.getTarget().isEnabled();
+    }
+
+    @Override
+    public int checkQueueMessageTimeout(Context context) throws SQLException {
+        int count = 0;
+        int maxAttempts = configurationService.getIntProperty("ldn.processor.max.attempts", 5);
+        /*
+         * put failed on processing messages with timed-out timeout and
+         * attempts >= configured_max_attempts put queue on processing messages with
+         * timed-out timeout and attempts < configured_max_attempts
+         */
+        Optional<LDNMessageEntity> msgOpt = getSingleMessageEntity(findProcessingTimedoutMessages(context));
+
+        while (msgOpt.isPresent()) {
+            LDNMessageEntity msg = msgOpt.get();
+            try {
+                if (msg.getQueueAttempts() >= maxAttempts) {
+                    msg.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_FAILED);
+                } else {
+                    msg.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_QUEUED);
+                }
+                update(context, msg);
+                count++;
+            } catch (SQLException e) {
+                log.error("Can't update LDN message " + msg, e);
+            }
+            msgOpt = getSingleMessageEntity(findProcessingTimedoutMessages(context));
+        }
+        return count;
+    }
+
+    public Optional<LDNMessageEntity> getSingleMessageEntity(Collection<LDNMessageEntity> messages) {
+        return messages.stream().findFirst();
+    }
+
+    @Override
+    public NotifyRequestStatus findRequestsByItem(Context context, Item item) throws SQLException {
+        NotifyRequestStatus result = new NotifyRequestStatus();
+        result.setItemUuid(item.getID());
+        List<LDNMessageEntity> msgs = ldnMessageDao.findAllMessagesByItem(
+            context, item, "Offer");
+        if (msgs != null && !msgs.isEmpty()) {
+            for (LDNMessageEntity msg : msgs) {
+                RequestStatus offer = new RequestStatus();
+                NotifyServiceEntity nse = msg.getOrigin();
+                if (nse == null) {
+                    nse = msg.getTarget();
+                }
+                offer.setServiceName(nse == null ? "Unknown Service" : nse.getName());
+                offer.setServiceUrl(nse == null ? "" : nse.getUrl());
+                offer.setOfferType(LDNUtils.getNotifyType(msg.getCoarNotifyType()));
+                List<LDNMessageEntity> acks = ldnMessageDao.findAllRelatedMessagesByItem(
+                    context, msg, item, "Accept", "TentativeReject", "TentativeAccept", "Announce");
+                if (acks == null || acks.isEmpty()) {
+                    offer.setStatus(NotifyRequestStatusEnum.REQUESTED);
+                } else if (acks.stream()
+                    .filter(c -> (c.getActivityStreamType().equalsIgnoreCase("TentativeAccept") ||
+                        c.getActivityStreamType().equalsIgnoreCase("Accept")))
+                    .findAny().isPresent()) {
+                    offer.setStatus(NotifyRequestStatusEnum.ACCEPTED);
+                } else if (acks.stream()
+                    .filter(c -> c.getActivityStreamType().equalsIgnoreCase("TentativeReject"))
+                    .findAny().isPresent()) {
+                    offer.setStatus(NotifyRequestStatusEnum.REJECTED);
+                }
+                if (acks.stream().filter(
+                    c -> c.getActivityStreamType().equalsIgnoreCase("Announce"))
+                    .findAny().isEmpty()) {
+                    result.addRequestStatus(offer);
+                }
+            }
+        }
+        return result;
+    }
+
+    public void delete(Context context, LDNMessageEntity ldnMessage) throws SQLException {
+        ldnMessageDao.delete(context, ldnMessage);
+    }
+
+    @Override
+    public boolean isTargetCurrent(Notification notification) {
+        String localInboxUrl = configurationService.getProperty("ldn.notify.inbox");
+        return StringUtils.equals(notification.getTarget().getInbox(), localInboxUrl);
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/NotifyPatternToTriggerImpl.java b/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/NotifyPatternToTriggerImpl.java
new file mode 100644
index 0000000000..89ec4abe58
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/NotifyPatternToTriggerImpl.java
@@ -0,0 +1,62 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.service.impl;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyPatternToTrigger;
+import org.dspace.app.ldn.dao.NotifyPatternToTriggerDao;
+import org.dspace.app.ldn.service.NotifyPatternToTriggerService;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implementation of {@link NotifyPatternToTriggerService}.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyPatternToTriggerImpl implements NotifyPatternToTriggerService {
+
+    @Autowired(required = true)
+    private NotifyPatternToTriggerDao notifyPatternToTriggerDao;
+
+    @Override
+    public List<NotifyPatternToTrigger> findAll(Context context) throws SQLException {
+        return notifyPatternToTriggerDao.findAll(context, NotifyPatternToTrigger.class);
+    }
+
+    @Override
+    public List<NotifyPatternToTrigger> findByItem(Context context, Item item) throws SQLException {
+        return notifyPatternToTriggerDao.findByItem(context, item);
+    }
+
+    @Override
+    public List<NotifyPatternToTrigger> findByItemAndPattern(Context context, Item item, String pattern)
+        throws SQLException {
+        return notifyPatternToTriggerDao.findByItemAndPattern(context, item, pattern);
+    }
+
+    @Override
+    public NotifyPatternToTrigger create(Context context) throws SQLException {
+        NotifyPatternToTrigger notifyPatternToTrigger = new NotifyPatternToTrigger();
+        return notifyPatternToTriggerDao.create(context, notifyPatternToTrigger);
+    }
+
+    @Override
+    public void update(Context context, NotifyPatternToTrigger notifyPatternToTrigger) throws SQLException {
+        notifyPatternToTriggerDao.save(context, notifyPatternToTrigger);
+    }
+
+    @Override
+    public void delete(Context context, NotifyPatternToTrigger notifyPatternToTrigger) throws SQLException {
+        notifyPatternToTriggerDao.delete(context, notifyPatternToTrigger);
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/NotifyServiceImpl.java b/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/NotifyServiceImpl.java
new file mode 100644
index 0000000000..d2289fd77a
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/NotifyServiceImpl.java
@@ -0,0 +1,66 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.service.impl;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.dao.NotifyServiceDao;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implementation of {@link NotifyService}.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyServiceImpl implements NotifyService {
+
+    @Autowired(required = true)
+    private NotifyServiceDao notifyServiceDao;
+
+    @Override
+    public List<NotifyServiceEntity> findAll(Context context) throws SQLException {
+        return notifyServiceDao.findAll(context, NotifyServiceEntity.class);
+    }
+
+    @Override
+    public NotifyServiceEntity find(Context context, Integer id) throws SQLException {
+        return notifyServiceDao.findByID(context, NotifyServiceEntity.class, id);
+    }
+
+    @Override
+    public NotifyServiceEntity create(Context context) throws SQLException {
+        NotifyServiceEntity notifyServiceEntity = new NotifyServiceEntity();
+        return notifyServiceDao.create(context, notifyServiceEntity);
+    }
+
+    @Override
+    public void update(Context context, NotifyServiceEntity notifyServiceEntity) throws SQLException {
+        notifyServiceDao.save(context, notifyServiceEntity);
+    }
+
+    @Override
+    public void delete(Context context, NotifyServiceEntity notifyServiceEntity) throws SQLException {
+        notifyServiceDao.delete(context, notifyServiceEntity);
+    }
+
+    @Override
+    public NotifyServiceEntity findByLdnUrl(Context context, String ldnUrl) throws SQLException {
+        return notifyServiceDao.findByLdnUrl(context, ldnUrl);
+    }
+
+    @Override
+    public List<NotifyServiceEntity> findManualServicesByInboundPattern(Context context, String pattern)
+        throws SQLException {
+        return notifyServiceDao.findManualServicesByInboundPattern(context, pattern);
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/NotifyServiceInboundPatternServiceImpl.java b/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/NotifyServiceInboundPatternServiceImpl.java
new file mode 100644
index 0000000000..c699d9fd03
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/service/impl/NotifyServiceInboundPatternServiceImpl.java
@@ -0,0 +1,59 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.service.impl;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.dao.NotifyServiceInboundPatternDao;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implementation Service class for the {@link NotifyServiceInboundPatternService}.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyServiceInboundPatternServiceImpl implements NotifyServiceInboundPatternService {
+
+    @Autowired
+    private NotifyServiceInboundPatternDao inboundPatternDao;
+
+    @Override
+    public NotifyServiceInboundPattern findByServiceAndPattern(Context context,
+                                                               NotifyServiceEntity notifyServiceEntity,
+                                                               String pattern) throws SQLException {
+        return inboundPatternDao.findByServiceAndPattern(context, notifyServiceEntity, pattern);
+    }
+
+    @Override
+    public List<NotifyServiceInboundPattern> findAutomaticPatterns(Context context) throws SQLException {
+        return inboundPatternDao.findAutomaticPatterns(context);
+    }
+
+    @Override
+    public NotifyServiceInboundPattern create(Context context, NotifyServiceEntity notifyServiceEntity)
+        throws SQLException {
+        NotifyServiceInboundPattern inboundPattern = new NotifyServiceInboundPattern();
+        inboundPattern.setNotifyService(notifyServiceEntity);
+        return inboundPatternDao.create(context, inboundPattern);
+    }
+
+    @Override
+    public void update(Context context, NotifyServiceInboundPattern inboundPattern) throws SQLException {
+        inboundPatternDao.save(context, inboundPattern);
+    }
+
+    @Override
+    public void delete(Context context, NotifyServiceInboundPattern inboundPattern) throws SQLException {
+        inboundPatternDao.delete(context, inboundPattern);
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/ldn/utility/LDNUtils.java b/dspace-api/src/main/java/org/dspace/app/ldn/utility/LDNUtils.java
new file mode 100644
index 0000000000..949da655bc
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/ldn/utility/LDNUtils.java
@@ -0,0 +1,96 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.utility;
+
+import static org.apache.commons.lang3.StringUtils.EMPTY;
+
+import java.util.UUID;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+/**
+ * Some linked data notification utilities.
+ */
+public class LDNUtils {
+
+    private final static Pattern UUID_REGEX_PATTERN = Pattern.compile(
+            "\\p{XDigit}{8}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{4}-\\p{XDigit}{12}");
+
+    private final static String SIMPLE_PROTOCOL_REGEX = "^(http[s]?://www\\.|http[s]?://|www\\.)";
+
+    /**
+     * 
+     */
+    private LDNUtils() {
+
+    }
+
+    /**
+     * Whether the URL contains an UUID. Used to determine item id from item URL.
+     *
+     * @param url item URL
+     * @return boolean true if URL has UUID, false otherwise
+     */
+    public static boolean hasUUIDInURL(String url) {
+        Matcher matcher = UUID_REGEX_PATTERN.matcher(url);
+
+        return matcher.find();
+    }
+
+    /**
+     * Extract UUID from URL.
+     *
+     * @param url item URL
+     * @return UUID item id
+     */
+    public static UUID getUUIDFromURL(String url) {
+        Matcher matcher = UUID_REGEX_PATTERN.matcher(url);
+        StringBuilder handle = new StringBuilder();
+        if (matcher.find()) {
+            handle.append(matcher.group(0));
+        }
+        return UUID.fromString(handle.toString());
+    }
+
+    /**
+     * Remove http or https protocol from URL.
+     *
+     * @param url URL
+     * @return String URL without protocol
+     */
+    public static String removedProtocol(String url) {
+        return url.replaceFirst(SIMPLE_PROTOCOL_REGEX, EMPTY);
+    }
+
+    /**
+     * Custom context resolver processing. Currently converting DOI URL to DOI id.
+     *
+     * @param value context ietf:cite-as
+     * @return String ietf:cite-as identifier
+     */
+    public static String processContextResolverId(String value) {
+        String resolverId = value;
+        resolverId = resolverId.replace("https://doi.org/", "doi:");
+
+        return resolverId;
+    }
+
+    /**
+     * Clear the coarNotifyType from the source code.
+     *
+     * @param coarNotifyType coar Notify Type to sanitize
+     * @return String just the notify type
+     */
+    public static String getNotifyType(String coarNotifyType) {
+        String justNotifyType = coarNotifyType;
+        justNotifyType = justNotifyType.substring(justNotifyType.lastIndexOf(":") + 1);
+        justNotifyType = justNotifyType.replace("Action",  "");
+        return justNotifyType;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/SolrSuggestionProvider.java b/dspace-api/src/main/java/org/dspace/app/suggestion/SolrSuggestionProvider.java
new file mode 100644
index 0000000000..f5acd2ccbc
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/SolrSuggestionProvider.java
@@ -0,0 +1,140 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.UUID;
+
+import org.apache.logging.log4j.Logger;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.external.model.ExternalDataObject;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Suggestion provider that read the suggestion from the local suggestion solr
+ * core
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science dot it)
+ *
+ */
+public abstract class SolrSuggestionProvider implements SuggestionProvider {
+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SolrSuggestionProvider.class);
+
+    @Autowired
+    protected ItemService itemService;
+
+    @Autowired
+    protected SolrSuggestionStorageService solrSuggestionStorageService;
+
+    private String sourceName;
+
+    public String getSourceName() {
+        return sourceName;
+    }
+
+    public void setSourceName(String sourceName) {
+        this.sourceName = sourceName;
+    }
+
+    public void setItemService(ItemService itemService) {
+        this.itemService = itemService;
+    }
+
+    @Override
+    public long countAllTargets(Context context) {
+        try {
+            return this.solrSuggestionStorageService.countAllTargets(context, sourceName);
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public long countUnprocessedSuggestionByTarget(Context context, UUID target) {
+        try {
+            return this.solrSuggestionStorageService.countUnprocessedSuggestionByTarget(context, sourceName, target);
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public List<Suggestion> findAllUnprocessedSuggestions(Context context, UUID target, int pageSize, long offset,
+            boolean ascending) {
+
+        try {
+            return this.solrSuggestionStorageService.findAllUnprocessedSuggestions(context, sourceName,
+                target, pageSize, offset, ascending);
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+
+    @Override
+    public List<SuggestionTarget> findAllTargets(Context context, int pageSize, long offset) {
+        try {
+            return this.solrSuggestionStorageService.findAllTargets(context, sourceName, pageSize, offset);
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public Suggestion findUnprocessedSuggestion(Context context, UUID target, String id) {
+        try {
+            return this.solrSuggestionStorageService.findUnprocessedSuggestion(context, sourceName, target, id);
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public SuggestionTarget findTarget(Context context, UUID target) {
+        try {
+            return this.solrSuggestionStorageService.findTarget(context, sourceName, target);
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void rejectSuggestion(Context context, UUID target, String idPart) {
+        Suggestion suggestion = findUnprocessedSuggestion(context, target, idPart);
+        try {
+            solrSuggestionStorageService.flagSuggestionAsProcessed(suggestion);
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void flagRelatedSuggestionsAsProcessed(Context context, ExternalDataObject externalDataObject) {
+        if (!isExternalDataObjectPotentiallySuggested(context, externalDataObject)) {
+            return;
+        }
+        try {
+            solrSuggestionStorageService.flagAllSuggestionAsProcessed(sourceName, externalDataObject.getId());
+        } catch (SolrServerException | IOException e) {
+            log.error(e.getMessage(), e);
+        }
+    }
+
+    /**
+     * check if the externalDataObject may have suggestion
+     * @param context
+     * @param externalDataObject
+     * @return true if the externalDataObject could be suggested by this provider
+     *         (i.e. it comes from a DataProvider used by this suggestor)
+     */
+    protected abstract boolean isExternalDataObjectPotentiallySuggested(Context context,
+            ExternalDataObject externalDataObject);
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/SolrSuggestionStorageService.java b/dspace-api/src/main/java/org/dspace/app/suggestion/SolrSuggestionStorageService.java
new file mode 100644
index 0000000000..b7de6146f2
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/SolrSuggestionStorageService.java
@@ -0,0 +1,191 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import java.io.IOException;
+import java.util.List;
+import java.util.UUID;
+
+import org.apache.solr.client.solrj.SolrServerException;
+import org.dspace.core.Context;
+
+/**
+ * Service to deal with the local suggestion solr core used by the
+ * SolrSuggestionProvider(s)
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science dot it)
+ * @author Luca Giamminonni (luca.giamminonni at 4science dot it)
+ *
+ */
+public interface SolrSuggestionStorageService {
+    public static final String SOURCE = "source";
+    /** This is the URI Part of the suggestion source:target:id */
+    public static final String SUGGESTION_FULLID = "suggestion_fullid";
+    public static final String SUGGESTION_ID = "suggestion_id";
+    public static final String TARGET_ID = "target_id";
+    public static final String TITLE = "title";
+    public static final String DATE = "date";
+    public static final String DISPLAY = "display";
+    public static final String CONTRIBUTORS = "contributors";
+    public static final String ABSTRACT = "abstract";
+    public static final String CATEGORY = "category";
+    public static final String EXTERNAL_URI = "external-uri";
+    public static final String PROCESSED = "processed";
+    public static final String SCORE = "trust";
+    public static final String EVIDENCES = "evidences";
+
+    /**
+     * Add a new suggestion to SOLR
+     * 
+     * @param suggestion
+     * @param force true if the suggestion must be reindexed
+     * @param commit
+     * @throws IOException
+     * @throws SolrServerException
+     */
+    public void addSuggestion(Suggestion suggestion, boolean force, boolean commit)
+            throws SolrServerException, IOException;
+
+    /**
+     * Return true if the suggestion is already in SOLR and flagged as processed
+     * 
+     * @param suggestion
+     * @return true if the suggestion is already in SOLR and flagged as processed
+     * @throws IOException
+     * @throws SolrServerException
+     */
+    public boolean exist(Suggestion suggestion) throws SolrServerException, IOException;
+
+    /**
+     * Delete a suggestion from SOLR if any
+     * 
+     * @param suggestion
+     * @throws IOException
+     * @throws SolrServerException
+     */
+    public void deleteSuggestion(Suggestion suggestion) throws SolrServerException, IOException;
+
+    /**
+     * Flag a suggestion as processed in SOLR if any
+     * 
+     * @param suggestion
+     * @throws IOException
+     * @throws SolrServerException
+     */
+    public void flagSuggestionAsProcessed(Suggestion suggestion) throws SolrServerException, IOException;
+
+    /**
+     * Delete all the suggestions from SOLR if any related to a specific target
+     * 
+     * @param target
+     * @throws IOException
+     * @throws SolrServerException
+     */
+    public void deleteTarget(SuggestionTarget target) throws SolrServerException, IOException;
+
+    /**
+     * Performs an explicit commit, causing pending documents to be committed for
+     * indexing.
+     *
+     * @throws SolrServerException
+     * @throws IOException
+     */
+    void commit() throws SolrServerException, IOException;
+
+    /**
+     * Flag all the suggestion related to the given source and id as processed.
+     *
+     * @param  source              the source name
+     * @param  idPart              the id's last part
+     * @throws SolrServerException
+     * @throws IOException
+     */
+    void flagAllSuggestionAsProcessed(String source, String idPart) throws SolrServerException, IOException;
+
+    /**
+     * Count all the targets related to the given source.
+     *
+     * @param  source              the source name
+     * @return                     the target's count
+     * @throws IOException
+     * @throws SolrServerException
+     */
+    long countAllTargets(Context context, String source) throws SolrServerException, IOException;
+
+    /**
+     * Count all the unprocessed suggestions related to the given source and target.
+     *
+     * @param  context             the DSpace Context
+     * @param  source              the source name
+     * @param  target              the target id
+     * @return                     the suggestion count
+     * @throws SolrServerException
+     * @throws IOException
+     */
+    long countUnprocessedSuggestionByTarget(Context context, String source, UUID target)
+        throws SolrServerException, IOException;
+
+    /**
+     * Find all the unprocessed suggestions related to the given source and target.
+     *
+     * @param  context             the DSpace Context
+     * @param  source              the source name
+     * @param  target              the target id
+     * @param  pageSize            the page size
+     * @param  offset              the page offset
+     * @param  ascending           true to retrieve the suggestions ordered by score
+     *                             ascending
+     * @return                     the found suggestions
+     * @throws SolrServerException
+     * @throws IOException
+     */
+    List<Suggestion> findAllUnprocessedSuggestions(Context context, String source, UUID target,
+        int pageSize, long offset, boolean ascending) throws SolrServerException, IOException;
+
+    /**
+     *
+     * Find all the suggestion targets related to the given source.
+     *
+     * @param  context             the DSpace Context
+     * @param  source              the source name
+     * @param  pageSize            the page size
+     * @param  offset              the page offset
+     * @return                     the found suggestion targets
+     * @throws SolrServerException
+     * @throws IOException
+     */
+    List<SuggestionTarget> findAllTargets(Context context, String source, int pageSize, long offset)
+        throws SolrServerException, IOException;
+
+    /**
+     * Find an unprocessed suggestion by the given source, target id and suggestion
+     * id.
+     *
+     * @param  context             the DSpace Context
+     * @param  source              the source name
+     * @param  target              the target id
+     * @param  id                  the suggestion id
+     * @return                     the suggestion, if any
+     * @throws SolrServerException
+     * @throws IOException
+     */
+    Suggestion findUnprocessedSuggestion(Context context, String source, UUID target, String id)
+        throws SolrServerException, IOException;
+
+    /**
+     * Find a suggestion target by the given source and target.
+     * 
+     * @param  context             the DSpace Context
+     * @param  source              the source name
+     * @param  target              the target id
+     * @return                     the suggestion target, if any
+     * @throws SolrServerException
+     * @throws IOException
+     */
+    SuggestionTarget findTarget(Context context, String source, UUID target) throws SolrServerException, IOException;
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/SolrSuggestionStorageServiceImpl.java b/dspace-api/src/main/java/org/dspace/app/suggestion/SolrSuggestionStorageServiceImpl.java
new file mode 100644
index 0000000000..3c2ad71846
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/SolrSuggestionStorageServiceImpl.java
@@ -0,0 +1,361 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import static org.apache.commons.collections.CollectionUtils.isEmpty;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.DeserializationFeature;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.json.JsonMapper;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.solr.client.solrj.SolrClient;
+import org.apache.solr.client.solrj.SolrQuery;
+import org.apache.solr.client.solrj.SolrQuery.SortClause;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.impl.HttpSolrClient;
+import org.apache.solr.client.solrj.response.FacetField;
+import org.apache.solr.client.solrj.response.FacetField.Count;
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.params.FacetParams;
+import org.dspace.content.Item;
+import org.dspace.content.dto.MetadataValueDTO;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.services.factory.DSpaceServicesFactory;
+import org.dspace.util.UUIDUtils;
+import org.springframework.beans.factory.annotation.Autowired;
+
+
+/**
+ * Service to deal with the local suggestion solr core used by the
+ * SolrSuggestionProvider(s)
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science dot it)
+ *
+ */
+public class SolrSuggestionStorageServiceImpl implements SolrSuggestionStorageService {
+
+    private static final Logger log = LogManager.getLogger(SolrSuggestionStorageServiceImpl.class);
+
+    protected SolrClient solrSuggestionClient;
+
+    @Autowired
+    private ItemService itemService;
+
+    /**
+     * Get solr client which use suggestion core
+     * 
+     * @return solr client
+     */
+    protected SolrClient getSolr() {
+        if (solrSuggestionClient == null) {
+            String solrService = DSpaceServicesFactory.getInstance().getConfigurationService()
+                    .getProperty("suggestion.solr.server", "http://localhost:8983/solr/suggestion");
+            solrSuggestionClient = new HttpSolrClient.Builder(solrService).build();
+        }
+        return solrSuggestionClient;
+    }
+
+    @Override
+    public void addSuggestion(Suggestion suggestion, boolean force, boolean commit)
+            throws SolrServerException, IOException {
+        if (force || !exist(suggestion)) {
+            ObjectMapper jsonMapper = new JsonMapper();
+            jsonMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
+            SolrInputDocument document = new SolrInputDocument();
+            document.addField(SOURCE, suggestion.getSource());
+            // suggestion id is written as concatenation of
+            // source + ":" + targetID + ":" + idPart (of externalDataObj)
+            String suggestionFullID = suggestion.getID();
+            document.addField(SUGGESTION_FULLID, suggestionFullID);
+            document.addField(SUGGESTION_ID, suggestionFullID.split(":", 3)[2]);
+            document.addField(TARGET_ID, suggestion.getTarget().getID().toString());
+            document.addField(DISPLAY, suggestion.getDisplay());
+            document.addField(TITLE, getFirstValue(suggestion, "dc", "title", null));
+            document.addField(DATE, getFirstValue(suggestion, "dc", "date", "issued"));
+            document.addField(CONTRIBUTORS, getAllValues(suggestion, "dc", "contributor", "author"));
+            document.addField(ABSTRACT, getFirstValue(suggestion, "dc", "description", "abstract"));
+            document.addField(CATEGORY, getAllValues(suggestion, "dc", "source", null));
+            document.addField(EXTERNAL_URI, suggestion.getExternalSourceUri());
+            document.addField(SCORE, suggestion.getScore());
+            document.addField(PROCESSED, false);
+            document.addField(EVIDENCES, jsonMapper.writeValueAsString(suggestion.getEvidences()));
+            getSolr().add(document);
+            if (commit) {
+                getSolr().commit();
+            }
+        }
+    }
+
+    @Override
+    public void commit() throws SolrServerException, IOException {
+        getSolr().commit();
+    }
+
+    private List<String> getAllValues(Suggestion suggestion, String schema, String element, String qualifier) {
+        return suggestion.getMetadata().stream()
+                .filter(st -> StringUtils.isNotBlank(st.getValue()) && StringUtils.equals(st.getSchema(), schema)
+                        && StringUtils.equals(st.getElement(), element)
+                        && StringUtils.equals(st.getQualifier(), qualifier))
+                .map(st -> st.getValue()).collect(Collectors.toList());
+    }
+
+    private String getFirstValue(Suggestion suggestion, String schema, String element, String qualifier) {
+        return suggestion.getMetadata().stream()
+            .filter(st -> StringUtils.isNotBlank(st.getValue())
+                && StringUtils.equals(st.getSchema(), schema)
+                        && StringUtils.equals(st.getElement(), element)
+                        && StringUtils.equals(st.getQualifier(), qualifier))
+                .map(st -> st.getValue()).findFirst().orElse(null);
+    }
+
+    @Override
+    public boolean exist(Suggestion suggestion) throws SolrServerException, IOException {
+        SolrQuery query = new SolrQuery(
+                SUGGESTION_FULLID + ":\"" + suggestion.getID() + "\" AND " + PROCESSED + ":true");
+        return getSolr().query(query).getResults().getNumFound() == 1;
+    }
+
+    @Override
+    public void deleteSuggestion(Suggestion suggestion) throws SolrServerException, IOException {
+        getSolr().deleteById(suggestion.getID());
+        getSolr().commit();
+    }
+
+    @Override
+    public void flagSuggestionAsProcessed(Suggestion suggestion) throws SolrServerException, IOException {
+        SolrInputDocument sdoc = new SolrInputDocument();
+        sdoc.addField(SUGGESTION_FULLID, suggestion.getID());
+        Map<String, Object> fieldModifier = new HashMap<>(1);
+        fieldModifier.put("set", true);
+        sdoc.addField(PROCESSED, fieldModifier); // add the map as the field value
+        getSolr().add(sdoc);
+        getSolr().commit();
+    }
+
+    @Override
+    public void flagAllSuggestionAsProcessed(String source, String idPart) throws SolrServerException, IOException {
+        SolrQuery query = new SolrQuery(SOURCE + ":" + source + " AND " + SUGGESTION_ID + ":\"" + idPart + "\"");
+        query.setRows(Integer.MAX_VALUE);
+        query.setFields(SUGGESTION_FULLID);
+        SolrDocumentList results = getSolr().query(query).getResults();
+        if (results.getNumFound() > 0) {
+            for (SolrDocument rDoc : results) {
+                SolrInputDocument sdoc = new SolrInputDocument();
+                sdoc.addField(SUGGESTION_FULLID, rDoc.getFieldValue(SUGGESTION_FULLID));
+                Map<String, Object> fieldModifier = new HashMap<>(1);
+                fieldModifier.put("set", true);
+                sdoc.addField(PROCESSED, fieldModifier); // add the map as the field value
+                getSolr().add(sdoc);
+            }
+        }
+        getSolr().commit();
+    }
+
+    @Override
+    public void deleteTarget(SuggestionTarget target) throws SolrServerException, IOException {
+        getSolr().deleteByQuery(
+                SOURCE + ":" + target.getSource() + " AND " + TARGET_ID + ":" + target.getTarget().getID().toString());
+        getSolr().commit();
+    }
+
+    @Override
+    public long countAllTargets(Context context, String source) throws SolrServerException, IOException {
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        solrQuery.setQuery(SOURCE + ":" + source);
+        solrQuery.addFilterQuery(PROCESSED + ":false");
+        solrQuery.setFacet(true);
+        solrQuery.setFacetMinCount(1);
+        solrQuery.addFacetField(TARGET_ID);
+        solrQuery.setFacetLimit(Integer.MAX_VALUE);
+        QueryResponse response = getSolr().query(solrQuery);
+        return response.getFacetField(TARGET_ID).getValueCount();
+    }
+
+    @Override
+    public long countUnprocessedSuggestionByTarget(Context context, String source, UUID target)
+        throws SolrServerException, IOException {
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        solrQuery.setQuery("*:*");
+        solrQuery.addFilterQuery(
+            SOURCE + ":" + source,
+            TARGET_ID + ":" + target.toString(),
+            PROCESSED + ":false");
+
+        QueryResponse response = getSolr().query(solrQuery);
+        return response.getResults().getNumFound();
+    }
+
+    @Override
+    public List<Suggestion> findAllUnprocessedSuggestions(Context context, String source, UUID target,
+        int pageSize, long offset, boolean ascending) throws SolrServerException, IOException {
+
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(pageSize);
+        solrQuery.setStart((int) offset);
+        solrQuery.setQuery("*:*");
+        solrQuery.addFilterQuery(
+            SOURCE + ":" + source,
+            TARGET_ID + ":" + target.toString(),
+            PROCESSED + ":false");
+
+        if (ascending) {
+            solrQuery.addSort(SortClause.asc("trust"));
+        } else {
+            solrQuery.addSort(SortClause.desc("trust"));
+        }
+
+        solrQuery.addSort(SortClause.desc("date"));
+        solrQuery.addSort(SortClause.asc("title"));
+
+        QueryResponse response = getSolr().query(solrQuery);
+        List<Suggestion> suggestions = new ArrayList<Suggestion>();
+        for (SolrDocument solrDoc : response.getResults()) {
+            suggestions.add(convertSolrDoc(context, solrDoc, source));
+        }
+        return suggestions;
+
+    }
+
+    @Override
+    public List<SuggestionTarget> findAllTargets(Context context, String source, int pageSize, long offset)
+        throws SolrServerException, IOException {
+
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        solrQuery.setQuery(SOURCE + ":" + source);
+        solrQuery.addFilterQuery(PROCESSED + ":false");
+        solrQuery.setFacet(true);
+        solrQuery.setFacetMinCount(1);
+        solrQuery.addFacetField(TARGET_ID);
+        solrQuery.setParam(FacetParams.FACET_OFFSET, String.valueOf(offset));
+        solrQuery.setFacetLimit((int) (pageSize));
+        QueryResponse response = getSolr().query(solrQuery);
+        FacetField facetField = response.getFacetField(TARGET_ID);
+        List<SuggestionTarget> suggestionTargets = new ArrayList<SuggestionTarget>();
+        int idx = 0;
+        for (Count c : facetField.getValues()) {
+            SuggestionTarget target = new SuggestionTarget();
+            target.setSource(source);
+            target.setTotal((int) c.getCount());
+            target.setTarget(findItem(context, c.getName()));
+            suggestionTargets.add(target);
+            idx++;
+        }
+        return suggestionTargets;
+
+    }
+
+    @Override
+    public Suggestion findUnprocessedSuggestion(Context context, String source, UUID target, String id)
+        throws SolrServerException, IOException {
+
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(1);
+        solrQuery.setQuery("*:*");
+        solrQuery.addFilterQuery(
+            SOURCE + ":" + source,
+            TARGET_ID + ":" + target.toString(),
+            SUGGESTION_ID + ":\"" + id + "\"",
+            PROCESSED + ":false");
+
+        SolrDocumentList results = getSolr().query(solrQuery).getResults();
+        return isEmpty(results) ? null : convertSolrDoc(context, results.get(0), source);
+    }
+
+    @Override
+    public SuggestionTarget findTarget(Context context, String source, UUID target)
+        throws SolrServerException, IOException {
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        solrQuery.setQuery(SOURCE + ":" + source);
+        solrQuery.addFilterQuery(
+            TARGET_ID + ":" + target.toString(),
+            PROCESSED + ":false");
+        QueryResponse response = getSolr().query(solrQuery);
+        SuggestionTarget sTarget = new SuggestionTarget();
+        sTarget.setSource(source);
+        sTarget.setTotal((int) response.getResults().getNumFound());
+        Item itemTarget = findItem(context, target);
+        if (itemTarget != null) {
+            sTarget.setTarget(itemTarget);
+        } else {
+            return null;
+        }
+        return sTarget;
+    }
+
+    private Suggestion convertSolrDoc(Context context, SolrDocument solrDoc, String sourceName) {
+        Item target = findItem(context, (String) solrDoc.getFieldValue(TARGET_ID));
+
+        Suggestion suggestion = new Suggestion(sourceName, target, (String) solrDoc.getFieldValue(SUGGESTION_ID));
+        suggestion.setDisplay((String) solrDoc.getFieldValue(DISPLAY));
+        suggestion.getMetadata()
+            .add(new MetadataValueDTO("dc", "title", null, null, (String) solrDoc.getFieldValue(TITLE)));
+        suggestion.getMetadata()
+            .add(new MetadataValueDTO("dc", "date", "issued", null, (String) solrDoc.getFieldValue(DATE)));
+        suggestion.getMetadata().add(
+            new MetadataValueDTO("dc", "description", "abstract", null, (String) solrDoc.getFieldValue(ABSTRACT)));
+
+        suggestion.setExternalSourceUri((String) solrDoc.getFieldValue(EXTERNAL_URI));
+        if (solrDoc.containsKey(CATEGORY)) {
+            for (Object o : solrDoc.getFieldValues(CATEGORY)) {
+                suggestion.getMetadata().add(
+                    new MetadataValueDTO("dc", "source", null, null, (String) o));
+            }
+        }
+        if (solrDoc.containsKey(CONTRIBUTORS)) {
+            for (Object o : solrDoc.getFieldValues(CONTRIBUTORS)) {
+                suggestion.getMetadata().add(
+                    new MetadataValueDTO("dc", "contributor", "author", null, (String) o));
+            }
+        }
+        String evidencesJson = (String) solrDoc.getFieldValue(EVIDENCES);
+        ObjectMapper jsonMapper = new JsonMapper();
+        jsonMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
+        List<SuggestionEvidence> evidences = new LinkedList<SuggestionEvidence>();
+        try {
+            evidences = jsonMapper.readValue(evidencesJson, new TypeReference<List<SuggestionEvidence>>() {});
+        } catch (JsonProcessingException e) {
+            log.error(e);
+        }
+        suggestion.getEvidences().addAll(evidences);
+        return suggestion;
+    }
+
+    private Item findItem(Context context, UUID itemId) {
+        try {
+            return itemService.find(context, itemId);
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private Item findItem(Context context, String itemId) {
+        return findItem(context, UUIDUtils.fromString(itemId));
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/Suggestion.java b/dspace-api/src/main/java/org/dspace/app/suggestion/Suggestion.java
new file mode 100644
index 0000000000..7812cbd522
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/Suggestion.java
@@ -0,0 +1,99 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import java.util.LinkedList;
+import java.util.List;
+
+import org.dspace.content.Item;
+import org.dspace.content.dto.MetadataValueDTO;
+
+/**
+ * This entity contains metadatas that should be added to the targeted Item
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+public class Suggestion {
+
+    /** id of the suggestion */
+    private String id;
+
+    /** the dc.title of the item */
+    private String display;
+
+    /** the external source name the suggestion comes from */
+    private String source;
+
+    /** external uri of the item */
+    private String externalSourceUri;
+
+    /** item targeted by this suggestion */
+    private Item target;
+
+    private List<SuggestionEvidence> evidences = new LinkedList<SuggestionEvidence>();
+
+    private List<MetadataValueDTO> metadata = new LinkedList<MetadataValueDTO>();
+
+    /** suggestion creation
+     * @param source name of the external source
+     * @param target the targeted item in repository
+     * @param idPart external item id, used mainly for suggestion @see #id creation
+     * */
+    public Suggestion(String source, Item target, String idPart) {
+        this.source = source;
+        this.target = target;
+        this.id = source + ":" + target.getID().toString() + ":" + idPart;
+    }
+
+    public String getDisplay() {
+        return display;
+    }
+
+    public void setDisplay(String display) {
+        this.display = display;
+    }
+
+    public String getSource() {
+        return source;
+    }
+
+    public String getExternalSourceUri() {
+        return externalSourceUri;
+    }
+
+    public void setExternalSourceUri(String externalSourceUri) {
+        this.externalSourceUri = externalSourceUri;
+    }
+
+    public List<SuggestionEvidence> getEvidences() {
+        return evidences;
+    }
+
+    public List<MetadataValueDTO> getMetadata() {
+        return metadata;
+    }
+
+    public Item getTarget() {
+        return target;
+    }
+
+    public String getID() {
+        return id;
+    }
+
+    public Double getScore() {
+        if (evidences != null && evidences.size() > 0) {
+            double score = 0;
+            for (SuggestionEvidence evidence : evidences) {
+                score += evidence.getScore();
+            }
+            return score;
+        }
+        return null;
+    }
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionEvidence.java b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionEvidence.java
new file mode 100644
index 0000000000..d7f04929a1
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionEvidence.java
@@ -0,0 +1,61 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+/**
+ * This DTO class is returned by an {@link org.dspace.app.suggestion.openaire.EvidenceScorer} to model the concept of
+ * an evidence / fact that has been used to evaluate the precision of a suggestion increasing or decreasing the score
+ * of the suggestion.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+public class SuggestionEvidence {
+
+    /** name of the evidence */
+    private String name;
+
+    /** positive or negative value to influence the score of the suggestion */
+    private double score;
+
+    /** additional notes */
+    private String notes;
+
+    public SuggestionEvidence() {
+    }
+
+    public SuggestionEvidence(String name, double score, String notes) {
+        this.name = name;
+        this.score = score;
+        this.notes = notes;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public double getScore() {
+        return score;
+    }
+
+    public void setScore(double score) {
+        this.score = score;
+    }
+
+    public String getNotes() {
+        return notes;
+    }
+
+    public void setNotes(String notes) {
+        this.notes = notes;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionProvider.java b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionProvider.java
new file mode 100644
index 0000000000..7cfc3cfb53
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionProvider.java
@@ -0,0 +1,54 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import java.util.List;
+import java.util.UUID;
+
+import org.dspace.core.Context;
+import org.dspace.external.model.ExternalDataObject;
+
+/**
+ * 
+ * Interface for suggestion management like finding and counting.
+ * @see org.dspace.app.suggestion.SuggestionTarget
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.com)
+ *
+ */
+public interface SuggestionProvider {
+
+    /** find all suggestion targets
+     * @see org.dspace.app.suggestion.SuggestionTarget
+     * */
+    public List<SuggestionTarget> findAllTargets(Context context, int pageSize, long offset);
+
+    /** count all suggestion targets */
+    public long countAllTargets(Context context);
+
+    /** find a suggestion target by UUID */
+    public SuggestionTarget findTarget(Context context, UUID target);
+
+    /** find unprocessed suggestions (paged) by target UUID
+     * @see org.dspace.app.suggestion.Suggestion
+     * */
+    public List<Suggestion> findAllUnprocessedSuggestions(Context context, UUID target, int pageSize, long offset,
+            boolean ascending);
+
+    /** find unprocessed suggestions by target UUID */
+    public long countUnprocessedSuggestionByTarget(Context context, UUID target);
+
+    /** find an unprocessed suggestion by target UUID and suggestion id */
+    public Suggestion findUnprocessedSuggestion(Context context, UUID target, String id);
+
+    /** reject a specific suggestion by target @param target and by suggestion id @param idPart */
+    public void rejectSuggestion(Context context, UUID target, String idPart);
+
+    /** flag a suggestion as processed */
+    public void flagRelatedSuggestionsAsProcessed(Context context, ExternalDataObject externalDataObject);
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionService.java b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionService.java
new file mode 100644
index 0000000000..41d33026ed
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionService.java
@@ -0,0 +1,61 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import java.util.List;
+import java.util.UUID;
+
+import org.dspace.core.Context;
+
+/**
+ * Service that handles {@link Suggestion}.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+public interface SuggestionService {
+
+    /** find a {@link SuggestionTarget } by source name and suggestion id */
+    public SuggestionTarget find(Context context, String source, UUID id);
+
+    /** count all suggetion targets by suggestion source */
+    public long countAll(Context context, String source);
+
+    /** find all suggestion targets by source (paged) */
+    public List<SuggestionTarget> findAllTargets(Context context, String source, int pageSize, long offset);
+
+    /** count all (unprocessed) suggestions by the given target uuid */
+    public long countAllByTarget(Context context, UUID target);
+
+    /** find suggestion target by targeted item (paged) */
+    public List<SuggestionTarget> findByTarget(Context context, UUID target, int pageSize, long offset);
+
+    /** find suggestion source by source name */
+    public SuggestionSource findSource(Context context, String source);
+
+    /** count all suggestion sources */
+    public long countSources(Context context);
+
+    /** find all suggestion sources (paged) */
+    public List<SuggestionSource> findAllSources(Context context, int pageSize, long offset);
+
+    /** find unprocessed suggestion by id */
+    public Suggestion findUnprocessedSuggestion(Context context, String id);
+
+    /** reject a specific suggestion by its id */
+    public void rejectSuggestion(Context context, String id);
+
+    /** find all suggestions by targeted item and external source */
+    public List<Suggestion> findByTargetAndSource(Context context, UUID target, String source, int pageSize,
+            long offset, boolean ascending);
+
+    /** count all suggestions by targeted item id and source name */
+    public long countAllByTargetAndSource(Context context, String source, UUID target);
+
+    /** returns all suggestion providers */
+    public List<SuggestionProvider> getSuggestionProviders();
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionServiceImpl.java b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionServiceImpl.java
new file mode 100644
index 0000000000..66773fbc12
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionServiceImpl.java
@@ -0,0 +1,194 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import java.util.ArrayList;
+import java.util.Comparator;
+import java.util.List;
+import java.util.Map;
+import java.util.UUID;
+import java.util.stream.Collectors;
+import javax.annotation.Resource;
+
+import org.apache.logging.log4j.Logger;
+import org.dspace.core.Context;
+import org.springframework.stereotype.Service;
+
+@Service
+public class SuggestionServiceImpl implements SuggestionService {
+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SuggestionServiceImpl.class);
+
+    @Resource(name = "suggestionProviders")
+    private Map<String, SuggestionProvider> providersMap;
+
+    @Override
+    public List<SuggestionProvider> getSuggestionProviders() {
+        if (providersMap != null) {
+            return providersMap.values().stream().collect(Collectors.toList());
+        }
+        return null;
+    }
+
+    @Override
+    public SuggestionTarget find(Context context, String source, UUID id) {
+        if (providersMap.containsKey(source)) {
+            return providersMap.get(source).findTarget(context, id);
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public long countAll(Context context, String source) {
+        if (providersMap.containsKey(source)) {
+            return providersMap.get(source).countAllTargets(context);
+        } else {
+            return 0;
+        }
+    }
+
+    @Override
+    public List<SuggestionTarget> findAllTargets(Context context, String source, int pageSize, long offset) {
+        if (providersMap.containsKey(source)) {
+            return providersMap.get(source).findAllTargets(context, pageSize, offset);
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public long countAllByTarget(Context context, UUID target) {
+        int count = 0;
+        for (String provider : providersMap.keySet()) {
+            if (providersMap.get(provider).countUnprocessedSuggestionByTarget(context, target) > 0) {
+                count++;
+            }
+        }
+        return count;
+    }
+
+    @Override
+    public List<SuggestionTarget> findByTarget(Context context, UUID target, int pageSize, long offset) {
+        List<SuggestionTarget> fullSourceTargets = new ArrayList<SuggestionTarget>();
+        for (String source : providersMap.keySet()) {
+            // all the suggestion target will be related to the same target (i.e. the same researcher - person item)
+            SuggestionTarget sTarget = providersMap.get(source).findTarget(context, target);
+            if (sTarget != null && sTarget.getTotal() > 0) {
+                fullSourceTargets.add(sTarget);
+            }
+        }
+        fullSourceTargets.sort(new Comparator<SuggestionTarget>() {
+            @Override
+            public int compare(SuggestionTarget arg0, SuggestionTarget arg1) {
+                return -(arg0.getTotal() - arg1.getTotal());
+            }
+        }
+        );
+        // this list will be as large as the number of sources available in the repository so it is unlikely that
+        // real pagination will occur
+        return fullSourceTargets.stream().skip(offset).limit(pageSize).collect(Collectors.toList());
+    }
+
+    @Override
+    public long countSources(Context context) {
+        return providersMap.size();
+    }
+
+    @Override
+    public SuggestionSource findSource(Context context, String source) {
+        if (providersMap.containsKey(source)) {
+            SuggestionSource ssource = new SuggestionSource(source);
+            ssource.setTotal((int) providersMap.get(source).countAllTargets(context));
+            return ssource;
+        } else {
+            return null;
+        }
+    }
+
+    @Override
+    public List<SuggestionSource> findAllSources(Context context, int pageSize, long offset) {
+        List<SuggestionSource> fullSources = getSources(context).stream().skip(offset).limit(pageSize)
+                .collect(Collectors.toList());
+        return fullSources;
+    }
+
+    private List<SuggestionSource> getSources(Context context) {
+        List<SuggestionSource> results = new ArrayList<SuggestionSource>();
+        for (String source : providersMap.keySet()) {
+            SuggestionSource ssource = new SuggestionSource(source);
+            ssource.setTotal((int) providersMap.get(source).countAllTargets(context));
+            results.add(ssource);
+        }
+        return results;
+    }
+
+    @Override
+    public long countAllByTargetAndSource(Context context, String source, UUID target) {
+        if (providersMap.containsKey(source)) {
+            return providersMap.get(source).countUnprocessedSuggestionByTarget(context, target);
+        }
+        return 0;
+    }
+
+    @Override
+    public List<Suggestion> findByTargetAndSource(Context context, UUID target, String source, int pageSize,
+            long offset, boolean ascending) {
+        if (providersMap.containsKey(source)) {
+            return providersMap.get(source).findAllUnprocessedSuggestions(context, target, pageSize, offset, ascending);
+        }
+        return null;
+    }
+
+    @Override
+    public Suggestion findUnprocessedSuggestion(Context context, String id) {
+        String source = null;
+        UUID target = null;
+        String idPart = null;
+        String[] split;
+        try {
+            split = id.split(":", 3);
+            source = split[0];
+            target = UUID.fromString(split[1]);
+            idPart = split[2];
+        } catch (Exception e) {
+            log.warn("findSuggestion got an invalid id " + id + ", return null");
+            return null;
+        }
+        if (split.length != 3) {
+            return null;
+        }
+        if (providersMap.containsKey(source)) {
+            return providersMap.get(source).findUnprocessedSuggestion(context, target, idPart);
+        }
+        return null;
+    }
+
+    @Override
+    public void rejectSuggestion(Context context, String id) {
+        String source = null;
+        UUID target = null;
+        String idPart = null;
+        String[] split;
+        try {
+            split = id.split(":", 3);
+            source = split[0];
+            target = UUID.fromString(split[1]);
+            idPart = split[2];
+        } catch (Exception e) {
+            log.warn("rejectSuggestion got an invalid id " + id + ", doing nothing");
+            return;
+        }
+        if (split.length != 3) {
+            return;
+        }
+        if (providersMap.containsKey(source)) {
+            providersMap.get(source).rejectSuggestion(context, target, idPart);
+        }
+
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionSource.java b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionSource.java
new file mode 100644
index 0000000000..6dcc3f7e1e
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionSource.java
@@ -0,0 +1,49 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+/**
+ * This DTO class is used to pass around the number of items interested by suggestion provided by a specific source
+ * (i.e. openaire)
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+public class SuggestionSource {
+
+    /** source name of the suggestion */
+    private String name;
+
+    /** number of targeted items */
+    private int total;
+
+    public SuggestionSource() {
+    }
+
+    /**
+     * Summarize the available suggestions from a source.
+     * 
+     * @param name the name must be not null
+     */
+    public SuggestionSource(String name) {
+        super();
+        this.name = name;
+    }
+
+    public String getID() {
+        return name;
+    }
+
+    public int getTotal() {
+        return total;
+    }
+
+    public void setTotal(int total) {
+        this.total = total;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionTarget.java b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionTarget.java
new file mode 100644
index 0000000000..db82aa8081
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionTarget.java
@@ -0,0 +1,75 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import org.dspace.content.Item;
+
+/**
+ * This DTO class is used to pass around the number of suggestions available from a specific source for a target
+ * repository item
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+public class SuggestionTarget {
+
+    /** the item targeted */
+    private Item target;
+
+    /** source name of the suggestion */
+    private String source;
+
+    /** total count of suggestions for same target and source */
+    private int total;
+
+    public SuggestionTarget() {
+    }
+
+    /**
+     * Wrap a target repository item (usually a person item) into a suggestion target.
+     * 
+     * @param item must be not null
+     */
+    public SuggestionTarget(Item item) {
+        super();
+        this.target = item;
+    }
+
+    /**
+     * The suggestion target uses the concatenation of the source and target uuid separated by colon as id
+     * 
+     * @return the source:uuid of the wrapped item
+     */
+    public String getID() {
+        return source + ":" + (target != null ? target.getID() : "");
+    }
+
+    public Item getTarget() {
+        return target;
+    }
+
+    public void setTarget(Item target) {
+        this.target = target;
+    }
+
+    public String getSource() {
+        return source;
+    }
+
+    public void setSource(String source) {
+        this.source = source;
+    }
+
+    public int getTotal() {
+        return total;
+    }
+
+    public void setTotal(int total) {
+        this.total = total;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionUtils.java b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionUtils.java
new file mode 100644
index 0000000000..30ced75fc9
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/SuggestionUtils.java
@@ -0,0 +1,111 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.external.model.ExternalDataObject;
+
+/**
+ * This utility class provides convenient methods to deal with the
+ * {@link ExternalDataObject} for the purpose of the Suggestion framework
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+public class SuggestionUtils {
+    private SuggestionUtils() {
+    }
+    /**
+     * This method receive an ExternalDataObject and a metadatum key.
+     * It return only the values of the Metadata associated with the key.
+     * 
+     * @param record the ExternalDataObject to extract metadata from
+     * @param schema schema of the searching record
+     * @param element element of the searching record
+     * @param qualifier qualifier of the searching record
+     * @return value of the first matching record
+     */
+    public static List<String> getAllEntriesByMetadatum(ExternalDataObject record, String schema, String element,
+            String qualifier) {
+        return record.getMetadata().stream()
+                .filter(x ->
+                    StringUtils.equals(x.getSchema(), schema)
+                        && StringUtils.equals(x.getElement(), element)
+                        && StringUtils.equals(x.getQualifier(), qualifier))
+                .map(x -> x.getValue()).collect(Collectors.toList());
+    }
+
+    /**
+     * This method receive an ExternalDataObject and a metadatum key.
+     * It return only the values of the Metadata associated with the key.
+     * 
+     * @param record the ExternalDataObject to extract metadata from
+     * @param metadataFieldKey the metadata field key (i.e. dc.title or dc.contributor.author),
+     *      the jolly char is not supported
+     * @return value of the first matching record
+     */
+    public static List<String> getAllEntriesByMetadatum(ExternalDataObject record, String metadataFieldKey) {
+        if (metadataFieldKey == null) {
+            return Collections.EMPTY_LIST;
+        }
+        String[] fields = metadataFieldKey.split("\\.");
+        String schema = fields[0];
+        String element = fields[1];
+        String qualifier = null;
+        if (fields.length == 3) {
+            qualifier = fields[2];
+        }
+        return getAllEntriesByMetadatum(record, schema, element, qualifier);
+    }
+
+    /**
+     * This method receive and ExternalDataObject and a metadatum key.
+     * It return only the value of the first Metadatum from the list associated with the key.
+     * 
+     * @param record the ExternalDataObject to extract metadata from
+     * @param schema schema of the searching record
+     * @param element element of the searching record
+     * @param qualifier qualifier of the searching record
+     * @return value of the first matching record
+     */
+    public static String getFirstEntryByMetadatum(ExternalDataObject record, String schema, String element,
+            String qualifier) {
+        return record.getMetadata().stream()
+                .filter(x ->
+                    StringUtils.equals(x.getSchema(), schema)
+                        && StringUtils.equals(x.getElement(), element)
+                        && StringUtils.equals(x.getQualifier(), qualifier))
+                .map(x -> x.getValue()).findFirst().orElse(null);
+    }
+
+    /**
+     * This method receive and ExternalDataObject and a metadatum key.
+     * It return only the value of the first Metadatum from the list associated with the key.
+     * 
+     * @param record the ExternalDataObject to extract metadata from
+     * @param metadataFieldKey the metadata field key (i.e. dc.title or dc.contributor.author),
+     *      the jolly char is not supported
+     * @return value of the first matching record
+     */
+    public static String getFirstEntryByMetadatum(ExternalDataObject record, String metadataFieldKey) {
+        if (metadataFieldKey == null) {
+            return null;
+        }
+        String[] fields = metadataFieldKey.split("\\.");
+        String schema = fields[0];
+        String element = fields[1];
+        String qualifier = null;
+        if (fields.length == 3) {
+            qualifier = fields[2];
+        }
+        return getFirstEntryByMetadatum(record, schema, element, qualifier);
+    }
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/AuthorNamesScorer.java b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/AuthorNamesScorer.java
new file mode 100644
index 0000000000..60b1521f7e
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/AuthorNamesScorer.java
@@ -0,0 +1,151 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion.openaire;
+
+import static org.dspace.app.suggestion.SuggestionUtils.getAllEntriesByMetadatum;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
+import java.util.Locale;
+import java.util.Optional;
+import java.util.stream.Collectors;
+
+import com.ibm.icu.text.CharsetDetector;
+import com.ibm.icu.text.CharsetMatch;
+import com.ibm.icu.text.Normalizer;
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.app.suggestion.SuggestionEvidence;
+import org.dspace.content.Item;
+import org.dspace.content.MetadataValue;
+import org.dspace.content.service.ItemService;
+import org.dspace.external.model.ExternalDataObject;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implementation of {@see org.dspace.app.suggestion.oaire.EvidenceScorer} which evaluate ImportRecords
+ * based on Author's name.
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science dot it)
+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)
+ *
+ */
+public class AuthorNamesScorer implements EvidenceScorer {
+
+    private List<String> contributorMetadata;
+
+    private List<String> names;
+
+    @Autowired
+    private ItemService itemService;
+
+    /**
+     * returns the metadata key of the Item which to base the filter on
+     * @return metadata key
+     */
+    public List<String> getContributorMetadata() {
+        return contributorMetadata;
+    }
+
+    /**
+     * set the metadata key of the Item which to base the filter on
+     */
+    public void setContributorMetadata(List<String> contributorMetadata) {
+        this.contributorMetadata = contributorMetadata;
+    }
+
+    /**
+     * return the metadata key of ImportRecord which to base the filter on
+     * @return
+     */
+    public List<String> getNames() {
+        return names;
+    }
+
+    /**
+     * set the metadata key of ImportRecord which to base the filter on
+     */
+    public void setNames(List<String> names) {
+        this.names = names;
+    }
+
+    /**
+     * Method which is responsible to evaluate ImportRecord based on authors name.
+     * This method extract the researcher name from Item using contributorMetadata fields
+     * and try to match them with values extract from ImportRecord using metadata keys defined
+     * in names.
+     * ImportRecords which don't match will be discarded.
+     * 
+     * @param importRecord the import record to check
+     * @param researcher DSpace item
+     * @return the generated evidence or null if the record must be discarded
+     */
+    @Override
+    public SuggestionEvidence computeEvidence(Item researcher, ExternalDataObject importRecord) {
+        List<String[]> names = searchMetadataValues(researcher);
+        int maxNameLenght = names.stream().mapToInt(n -> n[0].length()).max().orElse(1);
+        List<String> metadataAuthors = new ArrayList<>();
+        for (String contributorMetadatum : contributorMetadata) {
+            metadataAuthors.addAll(getAllEntriesByMetadatum(importRecord, contributorMetadatum));
+        }
+        List<String> normalizedMetadataAuthors = metadataAuthors.stream().map(x -> normalize(x))
+                .collect(Collectors.toList());
+        int idx = 0;
+        for (String nMetadataAuthor : normalizedMetadataAuthors) {
+            Optional<String[]> found = names.stream()
+                    .filter(a -> StringUtils.equalsIgnoreCase(a[0], nMetadataAuthor)).findFirst();
+            if (found.isPresent()) {
+                return new SuggestionEvidence(this.getClass().getSimpleName(),
+                        100 * ((double) nMetadataAuthor.length() / (double) maxNameLenght),
+                        "The author " + metadataAuthors.get(idx) + " at position " + (idx + 1)
+                                + " in the authors list matches the name " + found.get()[1]
+                                + " in the researcher profile");
+            }
+            idx++;
+        }
+        return null;
+    }
+
+    /**
+     * Return list of Item metadata values starting from metadata keys defined in class level variable names.
+     * 
+     * @param researcher DSpace item
+     * @return list of metadata values
+     */
+    private List<String[]> searchMetadataValues(Item researcher) {
+        List<String[]> authors = new ArrayList<String[]>();
+        for (String name : names) {
+            List<MetadataValue> values = itemService.getMetadataByMetadataString(researcher, name);
+            if (values != null) {
+                for (MetadataValue v : values) {
+                    authors.add(new String[] {normalize(v.getValue()), v.getValue()});
+                }
+            }
+        }
+        return authors;
+    }
+
+    /**
+     * cleans up undesired characters
+     * @param value the string to clean up
+     * @return cleaned up string
+     * */
+    private String normalize(String value) {
+        String norm = Normalizer.normalize(value, Normalizer.NFD);
+        CharsetDetector cd = new CharsetDetector();
+        cd.setText(value.getBytes());
+        CharsetMatch detect = cd.detect();
+        if (detect != null && detect.getLanguage() != null) {
+            norm = norm.replaceAll("[^\\p{L}]", " ").toLowerCase(new Locale(detect.getLanguage()));
+        } else {
+            norm = norm.replaceAll("[^\\p{L}]", " ").toLowerCase();
+        }
+        return Arrays.asList(norm.split("\\s+")).stream().sorted().collect(Collectors.joining());
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/DateScorer.java b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/DateScorer.java
new file mode 100644
index 0000000000..94f81715fa
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/DateScorer.java
@@ -0,0 +1,214 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion.openaire;
+
+import java.util.Calendar;
+import java.util.Collections;
+import java.util.Date;
+import java.util.GregorianCalendar;
+import java.util.List;
+
+import org.dspace.app.suggestion.SuggestionEvidence;
+import org.dspace.app.suggestion.SuggestionUtils;
+import org.dspace.content.Item;
+import org.dspace.content.MetadataValue;
+import org.dspace.content.service.ItemService;
+import org.dspace.external.model.ExternalDataObject;
+import org.dspace.util.MultiFormatDateParser;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implementation of {@see org.dspace.app.suggestion.oaire.EvidenceScorer} which evaluate ImportRecords
+ * based on the distance from a date extracted from the ResearcherProfile (birthday / graduation date)
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science dot it)
+ *
+ */
+public class DateScorer implements EvidenceScorer {
+
+    /**
+     * if available it should contains the metadata field key in the form (schema.element[.qualifier]) that contains
+     * the birth date of the researcher
+     */
+    private String birthDateMetadata;
+
+    /**
+     * if available it should contains the metadata field key in the form (schema.element[.qualifier]) that contains
+     * the date of graduation of the researcher. If the metadata has multiple values the min will be used
+     */
+    private String educationDateMetadata;
+
+    /**
+     * The minimal age that is expected for a researcher to be a potential author of a scholarly contribution
+     * (i.e. the minimum delta from the publication date and the birth date)
+     */
+    private int birthDateDelta = 20;
+
+    /**
+     * The maximum age that is expected for a researcher to be a potential author of a scholarly contribution
+     * (i.e. the maximum delta from the publication date and the birth date)
+     */
+    private int birthDateRange = 50;
+
+    /**
+     * The number of year from/before the graduation that is expected for a researcher to be a potential
+     * author of a scholarly contribution (i.e. the minimum delta from the publication date and the first
+     * graduation date)
+     */
+    private int educationDateDelta = -3;
+
+    /**
+     * The maximum scientific longevity that is expected for a researcher from its graduation to be a potential
+     * author of a scholarly contribution (i.e. the maximum delta from the publication date and the first
+     * graduation date)
+     */
+    private int educationDateRange = 50;
+
+    @Autowired
+    private ItemService itemService;
+
+    /**
+     * the metadata used in the publication to track the publication date (i.e. dc.date.issued)
+     */
+    private String publicationDateMetadata;
+
+    public void setItemService(ItemService itemService) {
+        this.itemService = itemService;
+    }
+
+    public void setBirthDateMetadata(String birthDate) {
+        this.birthDateMetadata = birthDate;
+    }
+
+    public String getBirthDateMetadata() {
+        return birthDateMetadata;
+    }
+
+    public void setEducationDateMetadata(String educationDate) {
+        this.educationDateMetadata = educationDate;
+    }
+
+    public String getEducationDateMetadata() {
+        return educationDateMetadata;
+    }
+
+    public void setBirthDateDelta(int birthDateDelta) {
+        this.birthDateDelta = birthDateDelta;
+    }
+
+    public void setBirthDateRange(int birthDateRange) {
+        this.birthDateRange = birthDateRange;
+    }
+
+    public void setEducationDateDelta(int educationDateDelta) {
+        this.educationDateDelta = educationDateDelta;
+    }
+
+    public void setEducationDateRange(int educationDateRange) {
+        this.educationDateRange = educationDateRange;
+    }
+
+    public void setPublicationDateMetadata(String publicationDateMetadata) {
+        this.publicationDateMetadata = publicationDateMetadata;
+    }
+
+    /**
+     * Method which is responsible to evaluate ImportRecord based on the publication date.
+     * ImportRecords which have a date outside the defined or calculated expected range will be discarded.
+     * {@link DateScorer#birthDateMetadata}, {@link DateScorer#educationDateMetadata}
+     * 
+     * @param importRecord the ExternalDataObject to check
+     * @param researcher DSpace item
+     * @return the generated evidence or null if the record must be discarded
+     */
+    @Override
+    public SuggestionEvidence computeEvidence(Item researcher, ExternalDataObject importRecord) {
+        Integer[] range = calculateRange(researcher);
+        if (range == null) {
+            return new SuggestionEvidence(this.getClass().getSimpleName(),
+                    0,
+                    "No assumption was possible about the publication year range. "
+                    + "Please consider setting your birthday in your profile.");
+        } else {
+            String optDate = SuggestionUtils.getFirstEntryByMetadatum(importRecord, publicationDateMetadata);
+            int year = getYear(optDate);
+            if (year > 0) {
+                if ((range[0] == null || year >= range[0]) &&
+                    (range[1] == null || year <= range[1])) {
+                    return new SuggestionEvidence(this.getClass().getSimpleName(),
+                            10,
+                            "The publication date is within the expected range [" + range[0] + ", "
+                                    + range[1] + "]");
+                } else {
+                    // outside the range, discard the suggestion
+                    return null;
+                }
+            } else {
+                return new SuggestionEvidence(this.getClass().getSimpleName(),
+                        0,
+                        "No assumption was possible as the publication date is " + (optDate != null
+                                ? "unprocessable [" + optDate + "]"
+                                : "unknown"));
+            }
+        }
+    }
+
+    /**
+     * returns min and max year interval in between it's probably that the researcher
+     * actually contributed to the suggested item
+     * @param researcher
+     * @return
+     */
+    private Integer[] calculateRange(Item researcher) {
+        String birthDateStr = getSingleValue(researcher, birthDateMetadata);
+        int birthDateYear = getYear(birthDateStr);
+        int educationDateYear = getListMetadataValues(researcher, educationDateMetadata).stream()
+                .mapToInt(x -> getYear(x.getValue())).filter(d -> d > 0).min().orElse(-1);
+        if (educationDateYear > 0) {
+            return new Integer[] {
+                educationDateYear + educationDateDelta,
+                educationDateYear + educationDateDelta + educationDateRange
+            };
+        } else if (birthDateYear > 0) {
+            return new Integer[] {
+                birthDateYear + birthDateDelta,
+                birthDateYear + birthDateDelta + birthDateRange
+            };
+        } else {
+            return null;
+        }
+    }
+
+    private List<MetadataValue> getListMetadataValues(Item researcher, String metadataKey) {
+        if (metadataKey != null) {
+            return itemService.getMetadataByMetadataString(researcher, metadataKey);
+        } else {
+            return Collections.EMPTY_LIST;
+        }
+    }
+
+    private String getSingleValue(Item researcher, String metadataKey) {
+        if (metadataKey != null) {
+            return itemService.getMetadata(researcher, metadataKey);
+        }
+        return null;
+    }
+
+    private int getYear(String birthDateStr) {
+        int birthDateYear = -1;
+        if (birthDateStr != null) {
+            Date birthDate = MultiFormatDateParser.parse(birthDateStr);
+            if (birthDate != null) {
+                Calendar calendar = new GregorianCalendar();
+                calendar.setTime(birthDate);
+                birthDateYear = calendar.get(Calendar.YEAR);
+            }
+        }
+        return birthDateYear;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/EvidenceScorer.java b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/EvidenceScorer.java
new file mode 100644
index 0000000000..027e9902f9
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/EvidenceScorer.java
@@ -0,0 +1,37 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion.openaire;
+
+import org.dspace.app.suggestion.SuggestionEvidence;
+import org.dspace.content.Item;
+import org.dspace.external.model.ExternalDataObject;
+
+/**
+ * Interface used in {@see org.dspace.app.suggestion.oaire.PublicationApproverServiceImpl}
+ * to construct filtering pipeline.
+ * 
+ * For each EvidenceScorer, the service call computeEvidence method.
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science dot it)
+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)
+ *
+ */
+public interface EvidenceScorer {
+
+    /**
+     * Method to compute the suggestion evidence of an ImportRecord, a null evidence
+     * would lead the record to be discarded.
+     * 
+     * @param researcher   DSpace item
+     * @param importRecord the record to evaluate
+     * @return the generated suggestion evidence or null if the record should be
+     *         discarded
+     */
+    public SuggestionEvidence computeEvidence(Item researcher, ExternalDataObject importRecord);
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoader.java b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoader.java
new file mode 100644
index 0000000000..7ad723af12
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoader.java
@@ -0,0 +1,256 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion.openaire;
+
+import static org.dspace.app.suggestion.SuggestionUtils.getAllEntriesByMetadatum;
+import static org.dspace.app.suggestion.SuggestionUtils.getFirstEntryByMetadatum;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.dspace.app.suggestion.SolrSuggestionProvider;
+import org.dspace.app.suggestion.Suggestion;
+import org.dspace.app.suggestion.SuggestionEvidence;
+import org.dspace.content.Item;
+import org.dspace.content.dto.MetadataValueDTO;
+import org.dspace.core.Context;
+import org.dspace.external.model.ExternalDataObject;
+import org.dspace.external.provider.ExternalDataProvider;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Class responsible to load and manage ImportRecords from OpenAIRE
+ *
+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)
+ *
+ */
+public class PublicationLoader extends SolrSuggestionProvider {
+
+    private List<String> names;
+
+    private ExternalDataProvider primaryProvider;
+
+    private List<ExternalDataProvider> otherProviders;
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    private List<EvidenceScorer> pipeline;
+
+    public void setPrimaryProvider(ExternalDataProvider primaryProvider) {
+        this.primaryProvider = primaryProvider;
+    }
+
+    public void setOtherProviders(List<ExternalDataProvider> otherProviders) {
+        this.otherProviders = otherProviders;
+    }
+
+    /**
+     * Set the pipeline of Approver
+     * @param pipeline list Approver
+     */
+    public void setPipeline(List<EvidenceScorer> pipeline) {
+        this.pipeline = pipeline;
+    }
+
+    /**
+     * This method filter a list of ImportRecords using a pipeline of AuthorNamesApprover
+     * and return a filtered list of ImportRecords.
+     * 
+     * @see org.dspace.app.suggestion.openaire.AuthorNamesScorer
+     * @param researcher the researcher Item
+     * @param importRecords List of import record
+     * @return a list of filtered import records
+     */
+    public List<Suggestion> reduceAndTransform(Item researcher, List<ExternalDataObject> importRecords) {
+        List<Suggestion> results = new ArrayList<>();
+        for (ExternalDataObject r : importRecords) {
+            boolean skip = false;
+            List<SuggestionEvidence> evidences = new ArrayList<SuggestionEvidence>();
+            for (EvidenceScorer authorNameApprover : pipeline) {
+                SuggestionEvidence evidence = authorNameApprover.computeEvidence(researcher, r);
+                if (evidence != null) {
+                    evidences.add(evidence);
+                } else {
+                    skip = true;
+                    break;
+                }
+            }
+            if (!skip) {
+                Suggestion suggestion = translateImportRecordToSuggestion(researcher, r);
+                suggestion.getEvidences().addAll(evidences);
+                results.add(suggestion);
+            }
+        }
+        return results;
+    }
+
+    /**
+     * Save a List of ImportRecord into Solr.
+     * ImportRecord will be translate into a SolrDocument by the method translateImportRecordToSolrDocument.
+     *
+     * @param context the DSpace Context
+     * @param researcher a DSpace Item
+     * @throws SolrServerException
+     * @throws IOException
+     */
+    public void importAuthorRecords(Context context, Item researcher)
+            throws SolrServerException, IOException {
+        int offset = 0;
+        int limit = 10;
+        int loaded = limit;
+        List<String> searchValues = searchMetadataValues(researcher);
+        while (loaded > 0) {
+            List<ExternalDataObject> metadata = getImportRecords(searchValues, researcher, offset, limit);
+            if (metadata.isEmpty()) {
+                loaded = 0;
+                continue;
+            }
+            offset += limit;
+            loaded = metadata.size();
+            List<Suggestion> records = reduceAndTransform(researcher, metadata);
+            for (Suggestion record : records) {
+                solrSuggestionStorageService.addSuggestion(record, false, false);
+            }
+        }
+        solrSuggestionStorageService.commit();
+    }
+
+    /**
+     * Translate an ImportRecord into a Suggestion
+     * @param item DSpace item
+     * @param record ImportRecord
+     * @return Suggestion
+     */
+    private Suggestion translateImportRecordToSuggestion(Item item, ExternalDataObject record) {
+        String openAireId = record.getId();
+        Suggestion suggestion = new Suggestion(getSourceName(), item, openAireId);
+        suggestion.setDisplay(getFirstEntryByMetadatum(record, "dc", "title", null));
+        suggestion.getMetadata().add(
+                new MetadataValueDTO("dc", "title", null, null, getFirstEntryByMetadatum(record, "dc", "title", null)));
+        suggestion.getMetadata().add(new MetadataValueDTO("dc", "date", "issued", null,
+                getFirstEntryByMetadatum(record, "dc", "date", "issued")));
+        suggestion.getMetadata().add(new MetadataValueDTO("dc", "description", "abstract", null,
+                getFirstEntryByMetadatum(record, "dc", "description", "abstract")));
+        suggestion.setExternalSourceUri(configurationService.getProperty("dspace.server.url")
+                + "/api/integration/externalsources/" + primaryProvider.getSourceIdentifier() + "/entryValues/"
+                + openAireId);
+        for (String o : getAllEntriesByMetadatum(record, "dc", "source", null)) {
+            suggestion.getMetadata().add(new MetadataValueDTO("dc", "source", null, null, o));
+        }
+        for (String o : getAllEntriesByMetadatum(record, "dc", "contributor", "author")) {
+            suggestion.getMetadata().add(new MetadataValueDTO("dc", "contributor", "author", null, o));
+        }
+        return suggestion;
+    }
+
+    public List<String> getNames() {
+        return names;
+    }
+
+    public void setNames(List<String> names) {
+        this.names = names;
+    }
+
+    /**
+     * Load metadata from OpenAIRE using the import service. The service use the value
+     * get from metadata key defined in class level variable names as author to query OpenAIRE.
+     * 
+     * @see org.dspace.importer.external.openaire.service.OpenAireImportMetadataSourceServiceImpl
+     * @param searchValues query
+     * @param researcher item to extract metadata from
+     * @param limit for pagination purpose
+     * @param offset for pagination purpose
+     * @return list of ImportRecord
+     */
+    private List<ExternalDataObject> getImportRecords(List<String> searchValues,
+        Item researcher, int offset, int limit) {
+        List<ExternalDataObject> matchingRecords = new ArrayList<>();
+        for (String searchValue : searchValues) {
+            matchingRecords.addAll(
+                primaryProvider.searchExternalDataObjects(searchValue, offset, limit));
+        }
+        List<ExternalDataObject> toReturn = removeDuplicates(matchingRecords);
+        return toReturn;
+    }
+
+    /**
+     * This method remove duplicates from importRecords list.
+     * An element is a duplicate if in the list exist another element
+     * with the same value of the metadatum 'dc.identifier.other'
+     *
+     * @param importRecords list of ImportRecord
+     * @return list of ImportRecords without duplicates
+     */
+    private List<ExternalDataObject> removeDuplicates(List<ExternalDataObject> importRecords) {
+        List<ExternalDataObject> filteredRecords = new ArrayList<>();
+        for (ExternalDataObject currentRecord : importRecords) {
+            if (!isDuplicate(currentRecord, filteredRecords)) {
+                filteredRecords.add(currentRecord);
+            }
+        }
+        return filteredRecords;
+    }
+
+
+    /**
+     * Check if the ImportRecord is already present in the list.
+     * The comparison is made on the value of metadatum with key 'dc.identifier.other'
+     * 
+     * @param dto An importRecord instance
+     * @param importRecords a list of importRecord
+     * @return true if dto is already present in importRecords, false otherwise
+     */
+    private boolean isDuplicate(ExternalDataObject dto, List<ExternalDataObject> importRecords) {
+        String currentItemId = dto.getId();
+        if (currentItemId == null) {
+            return true;
+        }
+        for (ExternalDataObject importRecord : importRecords) {
+            if (currentItemId.equals(importRecord.getId())) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+
+    /**
+     * Return list of Item metadata values starting from metadata keys defined in class level variable names.
+     * 
+     * @param researcher DSpace item
+     * @return list of metadata values
+     */
+    private List<String> searchMetadataValues(Item researcher) {
+        List<String> authors = new ArrayList<String>();
+        for (String name : names) {
+            String value = itemService.getMetadata(researcher, name);
+            if (value != null) {
+                authors.add(value);
+            }
+        }
+        return authors;
+    }
+
+    @Override
+    protected boolean isExternalDataObjectPotentiallySuggested(Context context, ExternalDataObject externalDataObject) {
+        if (StringUtils.equals(externalDataObject.getSource(), primaryProvider.getSourceIdentifier())) {
+            return true;
+        } else if (otherProviders != null) {
+            return otherProviders.stream()
+                    .anyMatch(x -> StringUtils.equals(externalDataObject.getSource(), x.getSourceIdentifier()));
+        } else {
+            return false;
+        }
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderCliScriptConfiguration.java b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderCliScriptConfiguration.java
new file mode 100644
index 0000000000..f5289fd99a
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderCliScriptConfiguration.java
@@ -0,0 +1,29 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion.openaire;
+
+import org.apache.commons.cli.Options;
+
+/**
+ * Extension of {@link PublicationLoaderScriptConfiguration} for CLI.
+ *
+ * @author Alessandro Martelli (alessandro.martelli at 4science.it)
+ */
+public class PublicationLoaderCliScriptConfiguration<T extends PublicationLoaderRunnable>
+    extends PublicationLoaderScriptConfiguration<T> {
+
+    @Override
+    public Options getOptions() {
+        Options options = super.getOptions();
+        options.addOption("h", "help", false, "help");
+        options.getOption("h").setType(boolean.class);
+        super.options = options;
+        return options;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderRunnable.java b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderRunnable.java
new file mode 100644
index 0000000000..76e8213cd7
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderRunnable.java
@@ -0,0 +1,115 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion.openaire;
+
+import java.util.ArrayList;
+import java.util.Iterator;
+import java.util.List;
+
+import org.apache.commons.cli.ParseException;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+import org.dspace.discovery.DiscoverQuery;
+import org.dspace.discovery.SearchService;
+import org.dspace.discovery.SearchServiceException;
+import org.dspace.discovery.SearchUtils;
+import org.dspace.discovery.utils.DiscoverQueryBuilder;
+import org.dspace.discovery.utils.parameter.QueryBuilderSearchFilter;
+import org.dspace.scripts.DSpaceRunnable;
+import org.dspace.sort.SortOption;
+import org.dspace.utils.DSpace;
+
+/**
+ * Runner responsible to import metadata about authors from OpenAIRE to Solr.
+ * This runner works in two ways:
+ * If -s parameter with a valid UUID is received, then the specific researcher
+ * with this UUID will be used.
+ * Invocation without any parameter results in massive import, processing all
+ * authors registered in DSpace.
+ *
+ * @author Alessandro Martelli (alessandro.martelli at 4science.it)
+ */
+public class PublicationLoaderRunnable
+    extends DSpaceRunnable<PublicationLoaderScriptConfiguration<PublicationLoaderRunnable>> {
+
+    private static final Logger LOGGER = LogManager.getLogger();
+
+    private PublicationLoader oairePublicationLoader = null;
+
+    protected Context context;
+
+    protected String profile;
+
+    @Override
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public PublicationLoaderScriptConfiguration<PublicationLoaderRunnable> getScriptConfiguration() {
+        PublicationLoaderScriptConfiguration configuration = new DSpace().getServiceManager()
+                .getServiceByName("import-openaire-suggestions", PublicationLoaderScriptConfiguration.class);
+        return configuration;
+    }
+
+    @Override
+    public void setup() throws ParseException {
+
+        oairePublicationLoader = new DSpace().getServiceManager().getServiceByName(
+                "OpenairePublicationLoader", PublicationLoader.class);
+
+        profile = commandLine.getOptionValue("s");
+        if (profile == null) {
+            LOGGER.info("No argument for -s, process all profiles");
+        } else {
+            LOGGER.info("Process eperson item with UUID {}", profile);
+        }
+    }
+
+    @Override
+    public void internalRun() throws Exception {
+
+        context = new Context();
+
+        Iterator<Item> researchers = getResearchers(profile);
+        while (researchers.hasNext()) {
+            Item researcher = researchers.next();
+            oairePublicationLoader.importAuthorRecords(context, researcher);
+        }
+
+    }
+
+    /**
+     * Get the Item(s) which map a researcher from Solr. If the uuid is specified,
+     * the researcher with this UUID will be chosen. If the uuid doesn't match any
+     * researcher, the method returns an empty array list. If uuid is null, all
+     * research will be return.
+     *
+     * @param  profileUUID uuid of the researcher. If null, all researcher will be
+     *                     returned.
+     * @return             the researcher with specified UUID or all researchers
+     */
+    @SuppressWarnings("rawtypes")
+    private Iterator<Item> getResearchers(String profileUUID) {
+        SearchService searchService = new DSpace().getSingletonService(SearchService.class);
+        DiscoverQueryBuilder queryBuilder = SearchUtils.getQueryBuilder();
+        List<QueryBuilderSearchFilter> filters = new ArrayList<>();
+        String query = "*:*";
+        if (profileUUID != null) {
+            query = "search.resourceid:" + profileUUID;
+        }
+        try {
+            DiscoverQuery discoverQuery = queryBuilder.buildQuery(context, null,
+                SearchUtils.getDiscoveryConfigurationByName("person"),
+                query, filters,
+                "Item", 10, Long.getLong("0"), null, SortOption.DESCENDING);
+            return searchService.iteratorSearch(context, null, discoverQuery);
+        } catch (SearchServiceException e) {
+            LOGGER.error("Unable to read researcher on solr", e);
+        }
+        return null;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderRunnableCli.java b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderRunnableCli.java
new file mode 100644
index 0000000000..6c59b725d5
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderRunnableCli.java
@@ -0,0 +1,36 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion.openaire;
+
+import org.apache.commons.cli.HelpFormatter;
+import org.apache.commons.cli.ParseException;
+import org.dspace.utils.DSpace;
+
+public class PublicationLoaderRunnableCli extends PublicationLoaderRunnable {
+
+    @Override
+    @SuppressWarnings({ "rawtypes", "unchecked" })
+    public PublicationLoaderCliScriptConfiguration getScriptConfiguration() {
+        PublicationLoaderCliScriptConfiguration configuration = new DSpace().getServiceManager()
+                .getServiceByName("import-openaire-suggestions", PublicationLoaderCliScriptConfiguration.class);
+        return configuration;
+    }
+
+    @Override
+    public void setup() throws ParseException {
+        super.setup();
+
+        // in case of CLI we show the help prompt
+        if (commandLine.hasOption('h')) {
+            HelpFormatter formatter = new HelpFormatter();
+            formatter.printHelp("Import Researchers Suggestions", getScriptConfiguration().getOptions());
+            System.exit(0);
+        }
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderScriptConfiguration.java b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderScriptConfiguration.java
new file mode 100644
index 0000000000..8bef7de40d
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/app/suggestion/openaire/PublicationLoaderScriptConfiguration.java
@@ -0,0 +1,56 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion.openaire;
+
+import org.apache.commons.cli.Options;
+import org.dspace.scripts.configuration.ScriptConfiguration;
+
+public class PublicationLoaderScriptConfiguration<T extends PublicationLoaderRunnable>
+    extends ScriptConfiguration<T> {
+
+    private Class<T> dspaceRunnableClass;
+
+    @Override
+    public Class<T> getDspaceRunnableClass() {
+        return dspaceRunnableClass;
+    }
+
+    /**
+     * Generic setter for the dspaceRunnableClass
+     * @param dspaceRunnableClass   The dspaceRunnableClass to be set on this PublicationLoaderScriptConfiguration
+     */
+    @Override
+    public void setDspaceRunnableClass(Class<T> dspaceRunnableClass) {
+        this.dspaceRunnableClass = dspaceRunnableClass;
+    }
+
+    /*
+    @Override
+    public boolean isAllowedToExecute(Context context) {
+        try {
+            return authorizeService.isAdmin(context);
+        } catch (SQLException e) {
+            throw new RuntimeException("SQLException occurred when checking if the current user is an admin", e);
+        }
+    }
+    */
+
+    @Override
+    public Options getOptions() {
+        if (options == null) {
+            Options options = new Options();
+
+            options.addOption("s", "single-researcher", true, "Single researcher UUID");
+            options.getOption("s").setType(String.class);
+
+            super.options = options;
+        }
+        return options;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/coarnotify/NotifyConfigurationService.java b/dspace-api/src/main/java/org/dspace/coarnotify/NotifyConfigurationService.java
new file mode 100644
index 0000000000..c9d65186b6
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/coarnotify/NotifyConfigurationService.java
@@ -0,0 +1,34 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.coarnotify;
+
+import java.util.List;
+import java.util.Map;
+
+/**
+ * Simple bean to manage different COAR Notify configuration
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyConfigurationService {
+
+    /**
+     * Mapping the submission step process identifier with the configuration
+     * (see configuration at coar-notify.xml)
+     */
+    private Map<String, List<NotifyPattern>> patterns;
+
+    public Map<String, List<NotifyPattern>> getPatterns() {
+        return patterns;
+    }
+
+    public void setPatterns(Map<String, List<NotifyPattern>> patterns) {
+        this.patterns = patterns;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/coarnotify/NotifyPattern.java b/dspace-api/src/main/java/org/dspace/coarnotify/NotifyPattern.java
new file mode 100644
index 0000000000..d678aa0523
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/coarnotify/NotifyPattern.java
@@ -0,0 +1,44 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.coarnotify;
+
+/**
+ * A collection of configured patterns to be met when adding COAR Notify services.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyPattern {
+
+    private String pattern;
+    private boolean multipleRequest;
+
+    public NotifyPattern() {
+
+    }
+
+    public NotifyPattern(String pattern, boolean multipleRequest) {
+        this.pattern = pattern;
+        this.multipleRequest = multipleRequest;
+    }
+
+    public String getPattern() {
+        return pattern;
+    }
+
+    public void setPattern(String pattern) {
+        this.pattern = pattern;
+    }
+
+    public boolean isMultipleRequest() {
+        return multipleRequest;
+    }
+
+    public void setMultipleRequest(boolean multipleRequest) {
+        this.multipleRequest = multipleRequest;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/coarnotify/NotifySubmissionConfiguration.java b/dspace-api/src/main/java/org/dspace/coarnotify/NotifySubmissionConfiguration.java
new file mode 100644
index 0000000000..ee23ee3465
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/coarnotify/NotifySubmissionConfiguration.java
@@ -0,0 +1,65 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.coarnotify;
+
+import java.util.List;
+
+/**
+ * this class represents the Configuration of Submission COAR Notify
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifySubmissionConfiguration {
+
+    /**
+     * the map key of configured bean of COARNotifyConfigurationService
+     * in coar-notify.xml
+     */
+    private String id;
+
+    /**
+     * the map values of configured bean of COARNotifyConfigurationService
+     * in coar-notify.xml
+     */
+    private List<NotifyPattern> patterns;
+
+    public NotifySubmissionConfiguration() {
+
+    }
+
+    public NotifySubmissionConfiguration(String id, List<NotifyPattern> patterns) {
+        super();
+        this.id = id;
+        this.patterns = patterns;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    /**
+     * Gets the list of configured COAR Notify Patterns
+     *
+     * @return the list of configured COAR Notify Patterns
+     */
+    public List<NotifyPattern> getPatterns() {
+        return patterns;
+    }
+
+    /**
+     * Sets the list of configured COAR Notify Patterns
+     * @param patterns
+     */
+    public void setPatterns(final List<NotifyPattern> patterns) {
+        this.patterns = patterns;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/coarnotify/SubmissionNotifyServiceImpl.java b/dspace-api/src/main/java/org/dspace/coarnotify/SubmissionNotifyServiceImpl.java
new file mode 100644
index 0000000000..afb771529f
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/coarnotify/SubmissionNotifyServiceImpl.java
@@ -0,0 +1,53 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.coarnotify;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.dspace.coarnotify.service.SubmissionNotifyService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Service implementation of {@link SubmissionNotifyService}
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class SubmissionNotifyServiceImpl implements SubmissionNotifyService {
+
+    @Autowired(required = true)
+    private NotifyConfigurationService coarNotifyConfigurationService;
+
+    protected SubmissionNotifyServiceImpl() {
+
+    }
+
+    @Override
+    public NotifySubmissionConfiguration findOne(String id) {
+        List<NotifyPattern> patterns =
+            coarNotifyConfigurationService.getPatterns().get(id);
+
+        if (patterns == null) {
+            return null;
+        }
+
+        return new NotifySubmissionConfiguration(id, patterns);
+    }
+
+    @Override
+    public List<NotifySubmissionConfiguration> findAll() {
+        List<NotifySubmissionConfiguration> coarNotifies = new ArrayList<>();
+
+        coarNotifyConfigurationService.getPatterns().forEach((id, patterns) ->
+            coarNotifies.add(new NotifySubmissionConfiguration(id, patterns)
+            ));
+
+        return coarNotifies;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/coarnotify/service/SubmissionNotifyService.java b/dspace-api/src/main/java/org/dspace/coarnotify/service/SubmissionNotifyService.java
new file mode 100644
index 0000000000..43f3ea1733
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/coarnotify/service/SubmissionNotifyService.java
@@ -0,0 +1,39 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.coarnotify.service;
+
+import java.util.List;
+
+import org.dspace.coarnotify.NotifySubmissionConfiguration;
+
+/**
+ * Service interface class for the Creative Submission COAR Notify.
+ * The implementation of this class is responsible for all business logic calls for the Creative Submission COAR Notify
+ * and is autowired by spring
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public interface SubmissionNotifyService {
+
+    /**
+     * Find the COARE Notify corresponding to the provided ID
+     * found in the configuration
+     *
+     * @param id - the ID of the COAR Notify to be found
+     * @return the corresponding COAR Notify if found or null when not found
+     */
+    public NotifySubmissionConfiguration findOne(String id);
+
+    /**
+     * Find all configured COAR Notifies
+     *
+     * @return all configured COAR Notifies
+     */
+    public List<NotifySubmissionConfiguration> findAll();
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/content/CollectionServiceImpl.java b/dspace-api/src/main/java/org/dspace/content/CollectionServiceImpl.java
index 84ca1692cc..78d86ca46e 100644
--- a/dspace-api/src/main/java/org/dspace/content/CollectionServiceImpl.java
+++ b/dspace-api/src/main/java/org/dspace/content/CollectionServiceImpl.java
@@ -1038,6 +1038,60 @@ public class CollectionServiceImpl extends DSpaceObjectServiceImpl<Collection> i
         }
         return collections;
     }
+    @Override
+    public Collection retrieveCollectionWithSubmitByEntityType(Context context, Item item,
+                                                               String entityType) throws SQLException {
+        Collection ownCollection = item.getOwningCollection();
+        return retrieveWithSubmitCollectionByEntityType(context, ownCollection.getCommunities(), entityType);
+    }
+
+    private Collection retrieveWithSubmitCollectionByEntityType(Context context, List<Community> communities,
+                                                                String entityType) {
+
+        for (Community community : communities) {
+            Collection collection = retrieveCollectionWithSubmitByCommunityAndEntityType(context, community,
+                    entityType);
+            if (collection != null) {
+                return collection;
+            }
+        }
+
+        for (Community community : communities) {
+            List<Community> parentCommunities = community.getParentCommunities();
+            Collection collection = retrieveWithSubmitCollectionByEntityType(context, parentCommunities, entityType);
+            if (collection != null) {
+                return collection;
+            }
+        }
+
+        return retrieveCollectionWithSubmitByCommunityAndEntityType(context, null, entityType);
+    }
+
+    @Override
+    public Collection retrieveCollectionWithSubmitByCommunityAndEntityType(Context context, Community community,
+                                                                           String entityType) {
+        context.turnOffAuthorisationSystem();
+        List<Collection> collections;
+        try {
+            collections = findCollectionsWithSubmit(null, context, community, entityType, 0, 1);
+        } catch (SQLException | SearchServiceException e) {
+            throw new RuntimeException(e);
+        }
+        context.restoreAuthSystemState();
+        if (collections != null && collections.size() > 0) {
+            return collections.get(0);
+        }
+        if (community != null) {
+            for (Community subCommunity : community.getSubcommunities()) {
+                Collection collection = retrieveCollectionWithSubmitByCommunityAndEntityType(context,
+                        subCommunity, entityType);
+                if (collection != null) {
+                    return collection;
+                }
+            }
+        }
+        return null;
+    }
 
     @Override
     public int countCollectionsWithSubmit(String q, Context context, Community community, String entityType)
diff --git a/dspace-api/src/main/java/org/dspace/content/ItemFilterService.java b/dspace-api/src/main/java/org/dspace/content/ItemFilterService.java
new file mode 100644
index 0000000000..8b664a9726
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/content/ItemFilterService.java
@@ -0,0 +1,33 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.content;
+
+import java.util.List;
+
+import org.dspace.app.ldn.ItemFilter;
+
+/**
+ * Service interface class for the Item Filter Object
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public interface ItemFilterService {
+
+    /**
+     * @param id the bean name of item filter
+     * @return one logical item filter by id
+     * defined in item-filter.xml
+     */
+    public ItemFilter findOne(String id);
+
+    /**
+     * @return all logical item filters
+     * defined in item-filter.xml
+     */
+    public List<ItemFilter> findAll();
+}
diff --git a/dspace-api/src/main/java/org/dspace/content/ItemFilterServiceImpl.java b/dspace-api/src/main/java/org/dspace/content/ItemFilterServiceImpl.java
new file mode 100644
index 0000000000..bdb23d6566
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/content/ItemFilterServiceImpl.java
@@ -0,0 +1,58 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.content;
+
+import java.util.List;
+import java.util.Map;
+import java.util.stream.Collectors;
+
+import org.dspace.app.ldn.ItemFilter;
+import org.dspace.content.logic.LogicalStatement;
+import org.dspace.kernel.ServiceManager;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Service implementation for {@link ItemFilterService}
+ *
+ * @author Mohamd Eskander (mohamed.eskander at 4science.com)
+ */
+public class ItemFilterServiceImpl implements ItemFilterService {
+
+    @Autowired
+    private ServiceManager serviceManager;
+
+    @Override
+    public ItemFilter findOne(String id) {
+        return findAll()
+            .stream()
+            .filter(itemFilter ->
+                itemFilter.getId().equals(id))
+            .findFirst()
+            .orElse(null);
+    }
+
+    @Override
+    public List<ItemFilter> findAll() {
+        Map<String, LogicalStatement> ldnFilters =
+            serviceManager.getServiceByName("ldnItemFilters", Map.class);
+        return ldnFilters.keySet()
+            .stream()
+            .sorted()
+            .map(ItemFilter::new)
+            .collect(Collectors.toList());
+    }
+
+    public ServiceManager getServiceManager() {
+        return serviceManager;
+    }
+
+    public void setServiceManager(ServiceManager serviceManager) {
+        this.serviceManager = serviceManager;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/content/ItemServiceImpl.java b/dspace-api/src/main/java/org/dspace/content/ItemServiceImpl.java
index ebea2aa5b8..f6144961c6 100644
--- a/dspace-api/src/main/java/org/dspace/content/ItemServiceImpl.java
+++ b/dspace-api/src/main/java/org/dspace/content/ItemServiceImpl.java
@@ -77,6 +77,7 @@ import org.dspace.orcid.service.OrcidQueueService;
 import org.dspace.orcid.service.OrcidSynchronizationService;
 import org.dspace.orcid.service.OrcidTokenService;
 import org.dspace.profile.service.ResearcherProfileService;
+import org.dspace.qaevent.dao.QAEventsDAO;
 import org.dspace.services.ConfigurationService;
 import org.dspace.versioning.service.VersioningService;
 import org.dspace.workflow.WorkflowItemService;
@@ -170,6 +171,9 @@ public class ItemServiceImpl extends DSpaceObjectServiceImpl<Item> implements It
     @Autowired(required = true)
     protected SubscribeService subscribeService;
 
+    @Autowired
+    private QAEventsDAO qaEventsDao;
+
     protected ItemServiceImpl() {
         super();
     }
@@ -819,6 +823,11 @@ public class ItemServiceImpl extends DSpaceObjectServiceImpl<Item> implements It
             orcidToken.setProfileItem(null);
         }
 
+        List<QAEventProcessed> qaEvents = qaEventsDao.findByItem(context, item);
+        for (QAEventProcessed qaEvent : qaEvents) {
+            qaEventsDao.delete(context, qaEvent);
+        }
+
         //Only clear collections after we have removed everything else from the item
         item.clearCollections();
         item.setOwningCollection(null);
diff --git a/dspace-api/src/main/java/org/dspace/content/QAEvent.java b/dspace-api/src/main/java/org/dspace/content/QAEvent.java
new file mode 100644
index 0000000000..0f2608ef70
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/content/QAEvent.java
@@ -0,0 +1,220 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.content;
+
+import java.io.UnsupportedEncodingException;
+import java.security.MessageDigest;
+import java.security.NoSuchAlgorithmException;
+import java.util.Date;
+
+import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
+import org.dspace.qaevent.service.dto.CorrectionTypeMessageDTO;
+import org.dspace.qaevent.service.dto.NotifyMessageDTO;
+import org.dspace.qaevent.service.dto.OpenaireMessageDTO;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+import org.dspace.util.RawJsonDeserializer;
+
+/**
+ * This class represent the Quality Assurance broker data as loaded in our solr
+ * qaevent core
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+public class QAEvent {
+    public static final char[] HEX_DIGITS = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e',
+        'f' };
+    public static final String ACCEPTED = "accepted";
+    public static final String REJECTED = "rejected";
+    public static final String DISCARDED = "discarded";
+
+    public static final String OPENAIRE_SOURCE = "openaire";
+    public static final String DSPACE_USERS_SOURCE = "DSpaceUsers";
+    public static final String COAR_NOTIFY_SOURCE = "coar-notify";
+
+    private String source;
+
+    private String eventId;
+    /**
+     * contains the targeted dspace object,
+     * ie: oai:www.openstarts.units.it:123456789/1120 contains the handle
+     * of the DSpace pbject in its final part 123456789/1120
+     * */
+    private String originalId;
+
+    /**
+     * evaluated with the targeted dspace object id
+     * 
+     * */
+    private String target;
+
+    private String related;
+
+    private String title;
+
+    private String topic;
+
+    private double trust;
+
+    @JsonDeserialize(using = RawJsonDeserializer.class)
+    private String message;
+
+    private Date lastUpdate;
+
+    private String status = "PENDING";
+
+    public QAEvent() {}
+
+    public QAEvent(String source, String originalId, String target, String title,
+        String topic, double trust, String message, Date lastUpdate) {
+        super();
+        this.source = source;
+        this.originalId = originalId;
+        this.target = target;
+        this.title = title;
+        this.topic = topic;
+        this.trust = trust;
+        this.message = message;
+        this.lastUpdate = lastUpdate;
+        try {
+            computedEventId();
+        } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
+            throw new IllegalStateException(e);
+        }
+    }
+
+    public String getOriginalId() {
+        return originalId;
+    }
+
+    public void setOriginalId(String originalId) {
+        this.originalId = originalId;
+    }
+
+    public String getTitle() {
+        return title;
+    }
+
+    public void setTitle(String title) {
+        this.title = title;
+    }
+
+    public String getTopic() {
+        return topic;
+    }
+
+    public void setTopic(String topic) {
+        this.topic = topic;
+    }
+
+    public double getTrust() {
+        return trust;
+    }
+
+    public void setTrust(double trust) {
+        this.trust = trust;
+    }
+
+    public String getMessage() {
+        return message;
+    }
+
+    public void setMessage(String message) {
+        this.message = message;
+    }
+
+    public String getEventId() {
+        if (eventId == null) {
+            try {
+                computedEventId();
+            } catch (NoSuchAlgorithmException | UnsupportedEncodingException e) {
+                throw new RuntimeException(e);
+            }
+        }
+        return eventId;
+    }
+
+    public void setEventId(String eventId) {
+        this.eventId = eventId;
+    }
+
+    public String getTarget() {
+        return target;
+    }
+
+    public void setTarget(String target) {
+        this.target = target;
+    }
+
+    public Date getLastUpdate() {
+        return lastUpdate;
+    }
+
+    public void setLastUpdate(Date lastUpdate) {
+        this.lastUpdate = lastUpdate;
+    }
+
+    public void setRelated(String related) {
+        this.related = related;
+    }
+
+    public String getRelated() {
+        return related;
+    }
+
+    public void setStatus(String status) {
+        this.status = status;
+    }
+
+    public String getStatus() {
+        return status;
+    }
+
+    public String getSource() {
+        return source != null ? source : OPENAIRE_SOURCE;
+    }
+
+    public void setSource(String source) {
+        this.source = source;
+    }
+
+    /*
+     * DTO constructed via Jackson use empty constructor. In this case, the eventId
+     * must be compute on the get method. This method create a signature based on
+     * the event fields and store it in the eventid attribute.
+     */
+    private void computedEventId() throws NoSuchAlgorithmException, UnsupportedEncodingException {
+        MessageDigest digester = MessageDigest.getInstance("MD5");
+        String dataToString = "source=" + source + ",originalId=" + originalId + ", title=" + title + ", topic="
+            + topic + ", trust=" + trust + ", message=" + message;
+        digester.update(dataToString.getBytes("UTF-8"));
+        byte[] signature = digester.digest();
+        char[] arr = new char[signature.length << 1];
+        for (int i = 0; i < signature.length; i++) {
+            int b = signature[i];
+            int idx = i << 1;
+            arr[idx] = HEX_DIGITS[(b >> 4) & 0xf];
+            arr[idx + 1] = HEX_DIGITS[b & 0xf];
+        }
+        eventId = new String(arr);
+
+    }
+
+    public Class<? extends QAMessageDTO> getMessageDtoClass() {
+        switch (getSource()) {
+            case OPENAIRE_SOURCE:
+                return OpenaireMessageDTO.class;
+            case COAR_NOTIFY_SOURCE:
+                return NotifyMessageDTO.class;
+            case DSPACE_USERS_SOURCE:
+                return CorrectionTypeMessageDTO.class;
+            default:
+                throw new IllegalArgumentException("Unknown event's source: " + getSource());
+        }
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/content/QAEventProcessed.java b/dspace-api/src/main/java/org/dspace/content/QAEventProcessed.java
new file mode 100644
index 0000000000..3631a2ff68
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/content/QAEventProcessed.java
@@ -0,0 +1,82 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.content;
+
+import java.io.Serializable;
+import java.util.Date;
+import javax.persistence.Column;
+import javax.persistence.Entity;
+import javax.persistence.Id;
+import javax.persistence.JoinColumn;
+import javax.persistence.ManyToOne;
+import javax.persistence.Table;
+import javax.persistence.Temporal;
+import javax.persistence.TemporalType;
+
+import org.dspace.eperson.EPerson;
+
+/**
+ * This class represent the stored information about processed notification
+ * broker events
+ *
+ */
+@Entity
+@Table(name = "qaevent_processed")
+public class QAEventProcessed implements Serializable {
+
+    private static final long serialVersionUID = 3427340199132007814L;
+
+    @Id
+    @Column(name = "qaevent_id")
+    private String eventId;
+
+    @Temporal(TemporalType.TIMESTAMP)
+    @Column(name = "qaevent_timestamp")
+    private Date eventTimestamp;
+
+    @JoinColumn(name = "eperson_uuid")
+    @ManyToOne
+    private EPerson eperson;
+
+    @JoinColumn(name = "item_uuid")
+    @ManyToOne
+    private Item item;
+
+    public String getEventId() {
+        return eventId;
+    }
+
+    public void setEventId(String eventId) {
+        this.eventId = eventId;
+    }
+
+    public Date getEventTimestamp() {
+        return eventTimestamp;
+    }
+
+    public void setEventTimestamp(Date eventTimestamp) {
+        this.eventTimestamp = eventTimestamp;
+    }
+
+    public EPerson getEperson() {
+        return eperson;
+    }
+
+    public void setEperson(EPerson eperson) {
+        this.eperson = eperson;
+    }
+
+    public Item getItem() {
+        return item;
+    }
+
+    public void setItem(Item item) {
+        this.item = item;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/content/service/CollectionService.java b/dspace-api/src/main/java/org/dspace/content/service/CollectionService.java
index 90db5c7314..8854ce5249 100644
--- a/dspace-api/src/main/java/org/dspace/content/service/CollectionService.java
+++ b/dspace-api/src/main/java/org/dspace/content/service/CollectionService.java
@@ -417,6 +417,34 @@ public interface CollectionService
     public List<Collection> findCollectionsWithSubmit(String q, Context context, Community community,
         int offset, int limit) throws SQLException, SearchServiceException;
 
+    /**
+     * Retrieve the first collection in the community or its descending that support
+     * the provided entityType
+     *
+     * @param  context    the DSpace context
+     * @param  community  the root from where the search start
+     * @param  entityType the requested entity type
+     * @return            the first collection in the community or its descending
+     *                    that support the provided entityType
+     */
+    public Collection retrieveCollectionWithSubmitByCommunityAndEntityType(Context context, Community community,
+                                                                           String entityType);
+
+    /**
+     * Retrieve the close collection to the item for which the current user has
+     * 'submit' privileges that support the provided entityType. Close mean the
+     * collection that can be reach with the minimum steps starting from the item
+     * (owningCollection, brothers collections, etc)
+     *
+     * @param  context    the DSpace context
+     * @param  item       the item from where the search start
+     * @param  entityType the requested entity type
+     * @return            the first collection in the community or its descending
+     *                    that support the provided entityType
+     */
+    public Collection retrieveCollectionWithSubmitByEntityType(Context context, Item item, String entityType)
+            throws SQLException;
+
     /**
      * Counts the number of Collection for which the current user has 'submit' privileges.
      * NOTE: for better performance, this method retrieves its results from an index (cache)
diff --git a/dspace-api/src/main/java/org/dspace/core/AbstractHibernateDAO.java b/dspace-api/src/main/java/org/dspace/core/AbstractHibernateDAO.java
index 32ad747d76..38923658f0 100644
--- a/dspace-api/src/main/java/org/dspace/core/AbstractHibernateDAO.java
+++ b/dspace-api/src/main/java/org/dspace/core/AbstractHibernateDAO.java
@@ -102,6 +102,16 @@ public abstract class AbstractHibernateDAO<T> implements GenericDAO<T> {
         return result;
     }
 
+    @Override
+    public T findByID(Context context, Class clazz, String id) throws SQLException {
+        if (id == null) {
+            return null;
+        }
+        @SuppressWarnings("unchecked")
+        T result = (T) getHibernateSession(context).get(clazz, id);
+        return result;
+    }
+
     @Override
     public List<T> findMany(Context context, String query) throws SQLException {
         @SuppressWarnings("unchecked")
diff --git a/dspace-api/src/main/java/org/dspace/core/Constants.java b/dspace-api/src/main/java/org/dspace/core/Constants.java
index f730ef6545..98bb1b7731 100644
--- a/dspace-api/src/main/java/org/dspace/core/Constants.java
+++ b/dspace-api/src/main/java/org/dspace/core/Constants.java
@@ -55,11 +55,16 @@ public class Constants {
      */
     public static final int EPERSON = 7;
 
+    /**
+     * Type of LDN MESSAGE objects
+     */
+    public static final int LDN_MESSAGE = 8;
+
     /**
      * lets you look up type names from the type IDs
      */
     public static final String[] typeText = { "BITSTREAM", "BUNDLE", "ITEM", "COLLECTION", "COMMUNITY", "SITE", "GROUP",
-        "EPERSON"};
+        "EPERSON", "LDN_MESSAGE"};
 
     /**
      * Special Bundle and Bitstream Names:
diff --git a/dspace-api/src/main/java/org/dspace/core/GenericDAO.java b/dspace-api/src/main/java/org/dspace/core/GenericDAO.java
index a04a0ccbdc..9835e18ad3 100644
--- a/dspace-api/src/main/java/org/dspace/core/GenericDAO.java
+++ b/dspace-api/src/main/java/org/dspace/core/GenericDAO.java
@@ -102,6 +102,17 @@ public interface GenericDAO<T> {
      */
     public T findByID(Context context, Class clazz, UUID id) throws SQLException;
 
+    /**
+     * Fetch the entity identified by its String primary key.
+     *
+     * @param context current DSpace context.
+     * @param clazz   class of entity to be found.
+     * @param id      primary key of the database record.
+     * @return the found entity.
+     * @throws SQLException
+     */
+    public T findByID(Context context, Class clazz, String id) throws SQLException;
+
     /**
      * Execute a JPQL query and return a collection of results.
      *
diff --git a/dspace-api/src/main/java/org/dspace/core/I18nUtil.java b/dspace-api/src/main/java/org/dspace/core/I18nUtil.java
index 0fc48b908b..b8798371c1 100644
--- a/dspace-api/src/main/java/org/dspace/core/I18nUtil.java
+++ b/dspace-api/src/main/java/org/dspace/core/I18nUtil.java
@@ -377,6 +377,22 @@ public class I18nUtil {
         return templateName;
     }
 
+    /**
+     * Get the appropriate localized version of a ldn template according to language settings
+     *
+     * @param locale Locale for this request
+     * @param name   String - base name of the ldn template
+     * @return templateName
+     * String - localized filename of a ldn template
+     */
+    public static String getLDNFilename(Locale locale, String name) {
+        String templateFile =
+            DSpaceServicesFactory.getInstance().getConfigurationService().getProperty("dspace.dir") +
+                File.separator + "config" + File.separator + "ldn" + File.separator + name;
+
+        return getFilename(locale, templateFile, "");
+    }
+
     /**
      * Creates array of Locales from text list of locale-specifications.
      * Used to parse lists in DSpace configuration properties.
diff --git a/dspace-api/src/main/java/org/dspace/core/LDN.java b/dspace-api/src/main/java/org/dspace/core/LDN.java
new file mode 100644
index 0000000000..283850eb10
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/core/LDN.java
@@ -0,0 +1,212 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.core;
+
+import static org.apache.commons.lang3.StringUtils.EMPTY;
+
+import java.io.BufferedReader;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.InputStreamReader;
+import java.io.StringWriter;
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+import java.util.Properties;
+import javax.mail.MessagingException;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.velocity.Template;
+import org.apache.velocity.VelocityContext;
+import org.apache.velocity.app.Velocity;
+import org.apache.velocity.app.VelocityEngine;
+import org.apache.velocity.exception.MethodInvocationException;
+import org.apache.velocity.exception.ParseErrorException;
+import org.apache.velocity.exception.ResourceNotFoundException;
+import org.apache.velocity.runtime.resource.loader.StringResourceLoader;
+import org.apache.velocity.runtime.resource.util.StringResourceRepository;
+import org.dspace.services.ConfigurationService;
+import org.dspace.services.factory.DSpaceServicesFactory;
+
+/**
+ * Class representing an LDN message json
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class LDN {
+    /**
+     * The content of the ldn message
+     */
+    private String content;
+    private String contentName;
+
+    /**
+     * The arguments to fill out
+     */
+    private final List<Object> arguments;
+
+    private static final Logger LOG = LogManager.getLogger();
+
+    /** Velocity template settings. */
+    private static final String RESOURCE_REPOSITORY_NAME = "LDN";
+    private static final Properties VELOCITY_PROPERTIES = new Properties();
+    static {
+        VELOCITY_PROPERTIES.put(Velocity.RESOURCE_LOADERS, "string");
+        VELOCITY_PROPERTIES.put("resource.loader.string.description",
+                "Velocity StringResource loader");
+        VELOCITY_PROPERTIES.put("resource.loader.string.class",
+                StringResourceLoader.class.getName());
+        VELOCITY_PROPERTIES.put("resource.loader.string.repository.name",
+                RESOURCE_REPOSITORY_NAME);
+        VELOCITY_PROPERTIES.put("resource.loader.string.repository.static",
+                "false");
+    }
+
+    /** Velocity template for the message*/
+    private Template template;
+
+    /**
+     * Create a new ldn message.
+     */
+    public LDN() {
+        arguments = new ArrayList<>(20);
+        template = null;
+        content = EMPTY;
+    }
+
+    /**
+     * Set the content of the message. Setting this also "resets" the message
+     * formatting - <code>addArgument</code> will start over. Comments and any
+     * "Subject:" line must be stripped.
+     *
+     * @param name a name for this message
+     * @param cnt the content of the message
+     */
+    public void setContent(String name, String cnt) {
+        content = cnt;
+        contentName = name;
+        arguments.clear();
+    }
+
+    /**
+     * Fill out the next argument in the template
+     *
+     * @param arg the value for the next argument
+     */
+    public void addArgument(Object arg) {
+        arguments.add(arg);
+    }
+
+    /**
+     * Generates the ldn message.
+     *
+     * @throws MessagingException if there was a problem sending the mail.
+     * @throws IOException        if IO error
+     */
+    public String generateLDNMessage() {
+        ConfigurationService config
+            = DSpaceServicesFactory.getInstance().getConfigurationService();
+
+        VelocityEngine templateEngine = new VelocityEngine();
+        templateEngine.init(VELOCITY_PROPERTIES);
+
+        VelocityContext vctx = new VelocityContext();
+        vctx.put("config", new LDN.UnmodifiableConfigurationService(config));
+        vctx.put("params", Collections.unmodifiableList(arguments));
+
+        if (null == template) {
+            if (StringUtils.isBlank(content)) {
+                LOG.error("template has no content");
+                throw new RuntimeException("template has no content");
+            }
+            // No template, so use a String of content.
+            StringResourceRepository repo = (StringResourceRepository)
+                templateEngine.getApplicationAttribute(RESOURCE_REPOSITORY_NAME);
+            repo.putStringResource(contentName, content);
+            // Turn content into a template.
+            template = templateEngine.getTemplate(contentName);
+        }
+
+        StringWriter writer = new StringWriter();
+        try {
+            template.merge(vctx, writer);
+        } catch (MethodInvocationException | ParseErrorException
+                | ResourceNotFoundException ex) {
+            LOG.error("Template not merged:  {}", ex.getMessage());
+            throw new RuntimeException("Template not merged", ex);
+        }
+        return writer.toString();
+    }
+
+    /**
+     * Get the VTL template for a ldn message. The message is suitable
+     * for inserting values using Apache Velocity.
+     *
+     * @param ldnMessageFile
+     *            full name for the ldn template, for example "/dspace/config/ldn/request-review".
+     *
+     * @return the ldn object, configured with body.
+     *
+     * @throws IOException if IO error,
+     *                     if the template couldn't be found, or there was some other
+     *                     error reading the template
+     */
+    public static LDN getLDNMessage(String ldnMessageFile)
+        throws IOException {
+        StringBuilder contentBuffer = new StringBuilder();
+        try (
+            InputStream is = new FileInputStream(ldnMessageFile);
+            InputStreamReader ir = new InputStreamReader(is, "UTF-8");
+            BufferedReader reader = new BufferedReader(ir);
+            ) {
+            boolean more = true;
+            while (more) {
+                String line = reader.readLine();
+                if (line == null) {
+                    more = false;
+                } else {
+                    contentBuffer.append(line);
+                    contentBuffer.append("\n");
+                }
+            }
+        }
+        LDN ldn = new LDN();
+        ldn.setContent(ldnMessageFile, contentBuffer.toString());
+        return ldn;
+    }
+
+    /**
+     * Wrap ConfigurationService to prevent templates from modifying
+     * the configuration.
+     */
+    public static class UnmodifiableConfigurationService {
+        private final ConfigurationService configurationService;
+
+        /**
+         * Swallow an instance of ConfigurationService.
+         *
+         * @param cs the real instance, to be wrapped.
+         */
+        public UnmodifiableConfigurationService(ConfigurationService cs) {
+            configurationService = cs;
+        }
+
+        /**
+         * Look up a key in the actual ConfigurationService.
+         *
+         * @param key to be looked up in the DSpace configuration.
+         * @return whatever value ConfigurationService associates with {@code key}.
+         */
+        public String get(String key) {
+            return configurationService.getProperty(key);
+        }
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/correctiontype/CorrectionType.java b/dspace-api/src/main/java/org/dspace/correctiontype/CorrectionType.java
new file mode 100644
index 0000000000..bc5abaef4e
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/correctiontype/CorrectionType.java
@@ -0,0 +1,81 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.correctiontype;
+
+import java.sql.SQLException;
+
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+
+/**
+ * Interface class that model the CorrectionType.
+ *
+ * @author Mykhaylo Boychuk (mykhaylo.boychuk at 4science.com)
+ */
+public interface CorrectionType {
+
+    /**
+     * Retrieves the unique identifier associated to the CorrectionType.
+     */
+    public String getId();
+
+    /**
+     * Retrieves the topic associated with the to the CorrectionType.
+     */
+    public String getTopic();
+
+    /**
+     * Checks whether the CorrectionType required related item.
+     */
+    public boolean isRequiredRelatedItem();
+
+    /**
+     * Checks whether target item is allowed for current CorrectionType
+     * 
+     * @param context              Current DSpace session
+     * @param targetItem           Target item
+     * @throws AuthorizeException  if authorize error
+     * @throws SQLException        if there's a database problem
+     */
+    public boolean isAllowed(Context context, Item targetItem) throws AuthorizeException, SQLException;
+
+    /**
+     * Checks whether target item and related item are allowed for current CorrectionType
+     * 
+     * @param context               Current DSpace session
+     * @param targetItem            Target item
+     * @param relatedItem           Related item
+     * @throws AuthorizeException   if authorize error
+     * @throws SQLException         if there's a database problem
+     */
+    public boolean isAllowed(Context context, Item targetItem, Item relatedItem) throws AuthorizeException,SQLException;
+
+    /**
+     * Creates a QAEvent for a specific target item.
+     * 
+     * @param context      Current DSpace session
+     * @param targetItem   Target item
+     * @param reason       Reason
+     * @return             QAEvent
+     */
+    public QAEvent createCorrection(Context context, Item targetItem, QAMessageDTO reason);
+
+    /**
+     *  Creates a QAEvent for a target item and related item.
+     * @param context      Current DSpace session
+     * @param targetItem   Target item
+     * @param relatedItem  Related item
+     * @param reason       Reason
+     * @return             QAEvent
+     */
+    public QAEvent createCorrection(Context context, Item targetItem, Item relatedItem, QAMessageDTO reason);
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/correctiontype/ReinstateCorrectionType.java b/dspace-api/src/main/java/org/dspace/correctiontype/ReinstateCorrectionType.java
new file mode 100644
index 0000000000..847236d110
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/correctiontype/ReinstateCorrectionType.java
@@ -0,0 +1,141 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.correctiontype;
+
+import static org.dspace.content.QAEvent.DSPACE_USERS_SOURCE;
+import static org.dspace.correctiontype.WithdrawnCorrectionType.WITHDRAWAL_REINSTATE_GROUP;
+
+import java.sql.SQLException;
+import java.util.Date;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.authorize.service.AuthorizeService;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.eperson.Group;
+import org.dspace.eperson.service.GroupService;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.qaevent.service.dto.CorrectionTypeMessageDTO;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.InitializingBean;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implementation class for {@link CorrectionType}
+ * that will reinstate target item if it's withdrawn.
+ *
+ * @author Mykhaylo Boychuk (mykhaylo.boychuk@4science.com)
+ */
+public class ReinstateCorrectionType implements CorrectionType, InitializingBean {
+
+    private String id;
+    private String topic;
+    private String creationForm;
+
+    @Autowired
+    private GroupService groupService;
+    @Autowired
+    private QAEventService qaEventService;
+    @Autowired
+    private AuthorizeService authorizeService;
+    @Autowired
+    private ConfigurationService configurationService;
+
+    @Override
+    public boolean isAllowed(Context context, Item targetItem) throws SQLException {
+        if (!targetItem.isWithdrawn()) {
+            return false;
+        }
+        boolean isAdmin = authorizeService.isAdmin(context);
+        if (!currentUserIsMemberOfwithdrawalReinstateGroup(context) && !isAdmin) {
+            return false;
+        }
+        long tot = qaEventService.countSourcesByTarget(context, targetItem.getID());
+        return tot == 0;
+    }
+
+    private boolean currentUserIsMemberOfwithdrawalReinstateGroup(Context context) throws SQLException {
+        String groupName = configurationService.getProperty(WITHDRAWAL_REINSTATE_GROUP);
+        if (StringUtils.isBlank(groupName)) {
+            return false;
+        }
+        Group withdrawalReinstateGroup = groupService.findByName(context, groupName);
+        return withdrawalReinstateGroup != null && groupService.isMember(context, withdrawalReinstateGroup);
+    }
+
+    @Override
+    public boolean isAllowed(Context context, Item targetItem, Item relatedItem) throws AuthorizeException,
+        SQLException {
+        return isAllowed(context, targetItem);
+    }
+
+    @Override
+    public QAEvent createCorrection(Context context, Item targetItem, QAMessageDTO reason) {
+        ObjectNode reasonJson = createReasonJson(reason);
+        QAEvent qaEvent = new QAEvent(DSPACE_USERS_SOURCE,
+                                      context.getCurrentUser().getID().toString(),
+                                      targetItem.getID().toString(),
+                                      targetItem.getName(),
+                                      this.getTopic(),
+                                      1.0,
+                                      reasonJson.toString(),
+                                      new Date()
+                                      );
+
+        qaEventService.store(context, qaEvent);
+        return qaEvent;
+    }
+
+    private ObjectNode createReasonJson(QAMessageDTO reason) {
+        CorrectionTypeMessageDTO mesasge = (CorrectionTypeMessageDTO) reason;
+        ObjectNode jsonNode = new ObjectMapper().createObjectNode();
+        jsonNode.put("reason", mesasge.getReason());
+        return jsonNode;
+    }
+
+    @Override
+    public QAEvent createCorrection(Context context, Item targetItem, Item relatedItem, QAMessageDTO reason) {
+        return this.createCorrection(context, targetItem, reason);
+    }
+
+    @Override
+    public boolean isRequiredRelatedItem() {
+        return false;
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getTopic() {
+        return topic;
+    }
+
+    public void setTopic(String topic) {
+        this.topic = topic;
+    }
+
+    @Override
+    public void afterPropertiesSet() throws Exception {}
+
+    public void setCreationForm(String creationForm) {
+        this.creationForm = creationForm;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/correctiontype/WithdrawnCorrectionType.java b/dspace-api/src/main/java/org/dspace/correctiontype/WithdrawnCorrectionType.java
new file mode 100644
index 0000000000..edf71ed815
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/correctiontype/WithdrawnCorrectionType.java
@@ -0,0 +1,149 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.correctiontype;
+
+import static org.dspace.content.QAEvent.DSPACE_USERS_SOURCE;
+import static org.dspace.core.Constants.READ;
+
+import java.sql.SQLException;
+import java.util.Date;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.authorize.service.AuthorizeService;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.eperson.Group;
+import org.dspace.eperson.service.GroupService;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.qaevent.service.dto.CorrectionTypeMessageDTO;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.InitializingBean;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implementation class for {@link CorrectionType}
+ * that will withdrawn target item if it archived and wasn't withdrawn alredy.
+ *
+ * @author Mykhaylo Boychuk (mykhaylo.boychuk at 4science.com)
+ */
+public class WithdrawnCorrectionType implements CorrectionType, InitializingBean {
+
+    public static final String WITHDRAWAL_REINSTATE_GROUP = "qaevents.withdraw-reinstate.group";
+
+    private String id;
+    private String topic;
+    private String creationForm;
+
+    @Autowired
+    private GroupService groupService;
+    @Autowired
+    private QAEventService qaEventService;
+    @Autowired
+    private AuthorizeService authorizeService;
+    @Autowired
+    private ConfigurationService configurationService;
+
+
+    @Override
+    public boolean isAllowed(Context context, Item targetItem) throws SQLException {
+        if (targetItem.isWithdrawn() || !targetItem.isArchived()) {
+            return false;
+        }
+        try {
+            authorizeService.authorizeAction(context, targetItem, READ);
+        } catch (AuthorizeException e) {
+            return false;
+        }
+        boolean isAdmin = authorizeService.isAdmin(context);
+        if (!currentUserIsMemberOfwithdrawalReinstateGroup(context) && !isAdmin) {
+            return false;
+        }
+        long tot = qaEventService.countSourcesByTarget(context, targetItem.getID());
+        return tot == 0;
+    }
+
+    private boolean currentUserIsMemberOfwithdrawalReinstateGroup(Context context) throws SQLException {
+        String groupName = configurationService.getProperty(WITHDRAWAL_REINSTATE_GROUP);
+        if (StringUtils.isBlank(groupName)) {
+            return false;
+        }
+        Group withdrawalReinstateGroup = groupService.findByName(context, groupName);
+        return withdrawalReinstateGroup != null && groupService.isMember(context, withdrawalReinstateGroup);
+    }
+
+    @Override
+    public QAEvent createCorrection(Context context, Item targetItem, QAMessageDTO reason) {
+        ObjectNode reasonJson = createReasonJson(reason);
+        QAEvent qaEvent = new QAEvent(DSPACE_USERS_SOURCE,
+                                      context.getCurrentUser().getID().toString(),
+                                      targetItem.getID().toString(),
+                                      targetItem.getName(),
+                                      this.getTopic(),
+                                      1.0,
+                                      reasonJson.toString(),
+                                      new Date()
+                                      );
+
+        qaEventService.store(context, qaEvent);
+        return qaEvent;
+    }
+
+    private ObjectNode createReasonJson(QAMessageDTO reason) {
+        CorrectionTypeMessageDTO mesasge = (CorrectionTypeMessageDTO) reason;
+        ObjectNode jsonNode = new ObjectMapper().createObjectNode();
+        jsonNode.put("reason", mesasge.getReason());
+        return jsonNode;
+    }
+
+    @Override
+    public boolean isAllowed(Context context, Item targetItem, Item relatedItem)
+            throws AuthorizeException, SQLException {
+        return isAllowed(context, targetItem);
+    }
+
+    @Override
+    public QAEvent createCorrection(Context context, Item targetItem, Item relatedItem, QAMessageDTO reason) {
+        return createCorrection(context, targetItem, reason);
+    }
+
+    @Override
+    public boolean isRequiredRelatedItem() {
+        return false;
+    }
+
+    @Override
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    @Override
+    public String getTopic() {
+        return topic;
+    }
+
+    public void setTopic(String topic) {
+        this.topic = topic;
+    }
+
+    @Override
+    public void afterPropertiesSet() throws Exception {}
+
+    public void setCreationForm(String creationForm) {
+        this.creationForm = creationForm;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/correctiontype/service/CorrectionTypeService.java b/dspace-api/src/main/java/org/dspace/correctiontype/service/CorrectionTypeService.java
new file mode 100644
index 0000000000..e76e1f7ec1
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/correctiontype/service/CorrectionTypeService.java
@@ -0,0 +1,58 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.correctiontype.service;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+import org.dspace.correctiontype.CorrectionType;
+
+/**
+ * Service interface class for the CorrectionType object.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public interface CorrectionTypeService {
+
+    /**
+     * Retrieves a CorrectionType object from the system based on a unique identifier.
+     * 
+     * @param id The unique identifier of the CorrectionType object to be retrieved.
+     * @return   The CorrectionType object corresponding to the provided identifier,
+     *           or null if no object is found.
+     */
+    public CorrectionType findOne(String id);
+
+    /**
+     * Retrieves a list of all CorrectionType objects available in the system.
+     * 
+     * @return Returns a List containing all CorrectionType objects in the system.
+     */
+    public List<CorrectionType> findAll();
+
+    /**
+     * Retrieves a list of CorrectionType objects related to the provided Item.
+     * 
+     * @param context               Current DSpace session.
+     * @param item                  Target item
+     * @throws AuthorizeException   If authorize error
+     * @throws SQLException         If a database error occurs during the operation.
+     */
+    public List<CorrectionType> findByItem(Context context, Item item) throws AuthorizeException, SQLException;
+
+    /**
+     * Retrieves a CorrectionType object associated with a specific topic.
+     * 
+     * @param topic  The topic for which the CorrectionType object is to be retrieved.
+     */
+    public CorrectionType findByTopic(String topic);
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/correctiontype/service/impl/CorrectionTypeServiceImpl.java b/dspace-api/src/main/java/org/dspace/correctiontype/service/impl/CorrectionTypeServiceImpl.java
new file mode 100644
index 0000000000..e64120c46a
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/correctiontype/service/impl/CorrectionTypeServiceImpl.java
@@ -0,0 +1,64 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.correctiontype.service.impl;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.commons.collections4.CollectionUtils;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+import org.dspace.correctiontype.CorrectionType;
+import org.dspace.correctiontype.service.CorrectionTypeService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Service implementation class for the CorrectionType object.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class CorrectionTypeServiceImpl implements CorrectionTypeService {
+
+    @Autowired
+    private List<CorrectionType> correctionTypes;
+
+    @Override
+    public CorrectionType findOne(String id) {
+        return findAll().stream()
+                        .filter(correctionType -> correctionType.getId().equals(id))
+                        .findFirst()
+                        .orElse(null);
+    }
+
+    @Override
+    public List<CorrectionType> findAll() {
+        return CollectionUtils.isNotEmpty(correctionTypes) ? correctionTypes : List.of();
+    }
+
+    @Override
+    public List<CorrectionType> findByItem(Context context, Item item) throws AuthorizeException, SQLException {
+        List<CorrectionType> correctionTypes = new ArrayList<>();
+        for (CorrectionType correctionType : findAll()) {
+            if (correctionType.isAllowed(context, item)) {
+                correctionTypes.add(correctionType);
+            }
+        }
+        return correctionTypes;
+    }
+
+    @Override
+    public CorrectionType findByTopic(String topic) {
+        return findAll().stream()
+                        .filter(correctionType -> correctionType.getTopic().equals(topic))
+                        .findFirst()
+                        .orElse(null);
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/discovery/IndexEventConsumer.java b/dspace-api/src/main/java/org/dspace/discovery/IndexEventConsumer.java
index 80602ac804..611200e62a 100644
--- a/dspace-api/src/main/java/org/dspace/discovery/IndexEventConsumer.java
+++ b/dspace-api/src/main/java/org/dspace/discovery/IndexEventConsumer.java
@@ -73,17 +73,22 @@ public class IndexEventConsumer implements Consumer {
 
         int st = event.getSubjectType();
         if (!(st == Constants.ITEM || st == Constants.BUNDLE
-            || st == Constants.COLLECTION || st == Constants.COMMUNITY || st == Constants.SITE)) {
+            || st == Constants.COLLECTION || st == Constants.COMMUNITY || st == Constants.SITE
+            || st == Constants.LDN_MESSAGE)) {
             log
                 .warn("IndexConsumer should not have been given this kind of Subject in an event, skipping: "
                           + event.toString());
             return;
         }
 
-        DSpaceObject subject = event.getSubject(ctx);
-
-        DSpaceObject object = event.getObject(ctx);
-
+        DSpaceObject subject = null;
+        DSpaceObject object = null;
+        try {
+            subject = event.getSubject(ctx);
+            object = event.getObject(ctx);
+        } catch (Exception e) {
+            log.warn("Could not find the related DSpace Object for event subject: " + st);
+        }
 
         // If event subject is a Bundle and event was Add or Remove,
         // transform the event to be a Modify on the owning Item.
@@ -110,7 +115,7 @@ public class IndexEventConsumer implements Consumer {
             case Event.MODIFY:
             case Event.MODIFY_METADATA:
                 if (subject == null) {
-                    if (st == Constants.SITE) {
+                    if (st == Constants.SITE || st == Constants.LDN_MESSAGE) {
                         // Update the indexable objects of type in event.detail of objects with ids in event.identifiers
                         for (String id : event.getIdentifiers()) {
                             IndexFactory indexableObjectService = IndexObjectFactoryFactory.getInstance().
diff --git a/dspace-api/src/main/java/org/dspace/discovery/indexobject/IndexableLDNNotification.java b/dspace-api/src/main/java/org/dspace/discovery/indexobject/IndexableLDNNotification.java
new file mode 100644
index 0000000000..86d600b6c9
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/discovery/indexobject/IndexableLDNNotification.java
@@ -0,0 +1,53 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.discovery.indexobject;
+
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.discovery.IndexableObject;
+
+/**
+ * {@link LDNMessageEntity} implementation for the {@link IndexableObject}
+ *
+ * @author Stefano Maffei at 4science.com
+ */
+public class IndexableLDNNotification extends AbstractIndexableObject<LDNMessageEntity, String> {
+
+    private LDNMessageEntity ldnMessage;
+    public static final String TYPE = LDNMessageEntity.class.getSimpleName();
+
+    public IndexableLDNNotification(LDNMessageEntity ldnMessage) {
+        super();
+        this.ldnMessage = ldnMessage;
+    }
+
+    @Override
+    public String getType() {
+        return getTypeText();
+    }
+
+    @Override
+    public String getID() {
+        return ldnMessage.getID();
+    }
+
+    @Override
+    public LDNMessageEntity getIndexedObject() {
+        return ldnMessage;
+    }
+
+    @Override
+    public void setIndexedObject(LDNMessageEntity object) {
+        this.ldnMessage = object;
+    }
+
+    @Override
+    public String getTypeText() {
+        return TYPE;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/discovery/indexobject/LDNMessageEntityIndexFactoryImpl.java b/dspace-api/src/main/java/org/dspace/discovery/indexobject/LDNMessageEntityIndexFactoryImpl.java
new file mode 100644
index 0000000000..7752ae5862
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/discovery/indexobject/LDNMessageEntityIndexFactoryImpl.java
@@ -0,0 +1,157 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.discovery.indexobject;
+
+import static org.apache.commons.lang3.time.DateFormatUtils.format;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.Iterator;
+import java.util.List;
+import java.util.Optional;
+
+import org.apache.solr.common.SolrInputDocument;
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.content.Item;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Factory implementation implementation for the
+ * {@link IndexableLDNNotification}
+ *
+ * @author Stefano Maffei at 4science.com
+ */
+public class LDNMessageEntityIndexFactoryImpl extends IndexFactoryImpl<IndexableLDNNotification, LDNMessageEntity> {
+
+    @Autowired(required = true)
+    private LDNMessageService ldnMessageService;
+    @Autowired(required = true)
+    private ItemService itemService;
+
+    @Override
+    public Iterator<IndexableLDNNotification> findAll(Context context) throws SQLException {
+        final Iterator<LDNMessageEntity> ldnNotifications = ldnMessageService.findAll(context).iterator();
+        return new Iterator<>() {
+            @Override
+            public boolean hasNext() {
+                return ldnNotifications.hasNext();
+            }
+
+            @Override
+            public IndexableLDNNotification next() {
+                return new IndexableLDNNotification(ldnNotifications.next());
+            }
+        };
+    }
+
+    @Override
+    public String getType() {
+        return IndexableLDNNotification.TYPE;
+    }
+
+    @Override
+    public Optional<IndexableLDNNotification> findIndexableObject(Context context, String id) throws SQLException {
+        final LDNMessageEntity ldnMessage = ldnMessageService.find(context, id);
+        return ldnMessage == null ? Optional.empty() : Optional.of(new IndexableLDNNotification(ldnMessage));
+    }
+
+    @Override
+    public boolean supports(Object object) {
+        return object instanceof LDNMessageEntity;
+    }
+
+    @Override
+    public List<IndexableLDNNotification> getIndexableObjects(Context context, LDNMessageEntity object)
+        throws SQLException {
+        return Arrays.asList(new IndexableLDNNotification(object));
+    }
+
+    @Override
+    public SolrInputDocument buildDocument(Context context, IndexableLDNNotification indexableObject)
+        throws SQLException, IOException {
+        // Add the ID's, types and call the SolrServiceIndexPlugins
+        final SolrInputDocument doc = super.buildDocument(context, indexableObject);
+        final LDNMessageEntity ldnMessage = indexableObject.getIndexedObject();
+        // add schema, element, qualifier and full fieldName
+        doc.addField("notification_id", ldnMessage.getID());
+        doc.addField("queue_status_i", ldnMessage.getQueueStatus());
+        doc.addField("queue_status_s", LDNMessageEntity.getQueueStatus(ldnMessage));
+        addFacetIndex(doc, "queue_status", String.valueOf(ldnMessage.getQueueStatus()),
+            LDNMessageEntity.getQueueStatus(ldnMessage));
+        if (ldnMessage.getObject() != null && ldnMessage.getObject().getID() != null) {
+            Item item = itemService.findByIdOrLegacyId(context, ldnMessage.getObject().getID().toString());
+            if (item != null) {
+                addFacetIndex(doc, "object", item.getID().toString(), itemService.getMetadata(item, "dc.title"));
+                addFacetIndex(doc, "relateditem", item.getID().toString(), itemService.getMetadata(item, "dc.title"));
+            }
+        }
+        if (ldnMessage.getContext() != null && ldnMessage.getContext().getID() != null) {
+            Item item = itemService.findByIdOrLegacyId(context, ldnMessage.getContext().getID().toString());
+            if (item != null) {
+                addFacetIndex(doc, "context", item.getID().toString(), itemService.getMetadata(item, "dc.title"));
+                addFacetIndex(doc, "relateditem", item.getID().toString(), itemService.getMetadata(item, "dc.title"));
+            }
+        }
+        NotifyServiceEntity origin = ldnMessage.getOrigin();
+        if (origin != null) {
+            addFacetIndex(doc, "origin", String.valueOf(origin.getID()),
+                LDNMessageEntity.getServiceNameForNotifyServ(origin));
+            addFacetIndex(doc, "ldn_service", String.valueOf(origin.getID()),
+                LDNMessageEntity.getServiceNameForNotifyServ(origin));
+        }
+        NotifyServiceEntity target = ldnMessage.getTarget();
+        if (target != null) {
+            addFacetIndex(doc, "target", String.valueOf(target.getID()),
+                LDNMessageEntity.getServiceNameForNotifyServ(target));
+            addFacetIndex(doc, "ldn_service", String.valueOf(target.getID()),
+                LDNMessageEntity.getServiceNameForNotifyServ(target));
+        }
+        if (ldnMessage.getInReplyTo() != null) {
+            doc.addField("in_reply_to", ldnMessage.getInReplyTo().getID());
+        }
+        doc.addField("message", ldnMessage.getMessage());
+        doc.addField("type", ldnMessage.getType());
+        addFacetIndex(doc, "activity_stream_type", ldnMessage.getActivityStreamType(),
+            ldnMessage.getActivityStreamType());
+        addFacetIndex(doc, "coar_notify_type", ldnMessage.getCoarNotifyType(), ldnMessage.getCoarNotifyType());
+        doc.addField("queue_attempts", ldnMessage.getQueueAttempts());
+        doc.addField("queue_attempts_sort", ldnMessage.getQueueAttempts());
+
+        indexDateFieldForFacet(doc, ldnMessage.getQueueLastStartTime());
+
+        doc.addField("queue_timeout", ldnMessage.getQueueTimeout());
+        String notificationType = LDNMessageEntity.getNotificationType(ldnMessage);
+        addFacetIndex(doc, "notification_type", notificationType, notificationType);
+
+        return doc;
+    }
+
+    private void indexDateFieldForFacet(SolrInputDocument doc, Date queueLastStartTime) {
+        if (queueLastStartTime != null) {
+            String value = format(queueLastStartTime, "yyyy-MM-dd");
+            addFacetIndex(doc, "queue_last_start_time", value, value);
+            doc.addField("queue_last_start_time", value);
+            doc.addField("queue_last_start_time_dt", queueLastStartTime);
+            doc.addField("queue_last_start_time_min", value);
+            doc.addField("queue_last_start_time_min_sort", value);
+            doc.addField("queue_last_start_time_max", value);
+            doc.addField("queue_last_start_time_max_sort", value);
+            doc.addField("queue_last_start_time.year",
+                Integer.parseInt(format(queueLastStartTime, "yyyy")));
+            doc.addField("queue_last_start_time.year_sort",
+                Integer.parseInt(format(queueLastStartTime, "yyyy")));
+        }
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java b/dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java
index 66fe6562ea..b9ac740685 100644
--- a/dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java
+++ b/dspace-api/src/main/java/org/dspace/eperson/EPersonServiceImpl.java
@@ -33,6 +33,7 @@ import org.dspace.content.DSpaceObjectServiceImpl;
 import org.dspace.content.Item;
 import org.dspace.content.MetadataField;
 import org.dspace.content.MetadataValue;
+import org.dspace.content.QAEventProcessed;
 import org.dspace.content.WorkspaceItem;
 import org.dspace.content.factory.ContentServiceFactory;
 import org.dspace.content.service.ItemService;
@@ -47,6 +48,7 @@ import org.dspace.eperson.service.GroupService;
 import org.dspace.eperson.service.SubscribeService;
 import org.dspace.event.Event;
 import org.dspace.orcid.service.OrcidTokenService;
+import org.dspace.qaevent.dao.QAEventsDAO;
 import org.dspace.services.ConfigurationService;
 import org.dspace.util.UUIDUtils;
 import org.dspace.versioning.Version;
@@ -106,6 +108,8 @@ public class EPersonServiceImpl extends DSpaceObjectServiceImpl<EPerson> impleme
     protected ConfigurationService configurationService;
     @Autowired
     protected OrcidTokenService orcidTokenService;
+    @Autowired
+    protected QAEventsDAO qaEventsDao;
 
     protected EPersonServiceImpl() {
         super();
@@ -142,10 +146,15 @@ public class EPersonServiceImpl extends DSpaceObjectServiceImpl<EPerson> impleme
 
     @Override
     public EPerson findByIdOrLegacyId(Context context, String id) throws SQLException {
-        if (StringUtils.isNumeric(id)) {
-            return findByLegacyId(context, Integer.parseInt(id));
-        } else {
-            return find(context, UUID.fromString(id));
+        try {
+            if (StringUtils.isNumeric(id)) {
+                return findByLegacyId(context, Integer.parseInt(id));
+            } else {
+                return find(context, UUID.fromString(id));
+            }
+        } catch (IllegalArgumentException e) {
+            // Not a valid legacy ID or valid UUID
+            return null;
         }
     }
 
@@ -487,6 +496,11 @@ public class EPersonServiceImpl extends DSpaceObjectServiceImpl<EPerson> impleme
         // Remove any subscriptions
         subscribeService.deleteByEPerson(context, ePerson);
 
+        List<QAEventProcessed> qaEvents = qaEventsDao.findByEPerson(context, ePerson);
+        for (QAEventProcessed qaEvent : qaEvents) {
+            qaEventsDao.delete(context, qaEvent);
+        }
+
         // Remove ourself
         ePersonDAO.delete(context, ePerson);
 
diff --git a/dspace-api/src/main/java/org/dspace/event/Event.java b/dspace-api/src/main/java/org/dspace/event/Event.java
index af8b2d4571..a673cd9852 100644
--- a/dspace-api/src/main/java/org/dspace/event/Event.java
+++ b/dspace-api/src/main/java/org/dspace/event/Event.java
@@ -104,8 +104,10 @@ public class Event implements Serializable {
 
     protected static final int EPERSON = 1 << Constants.EPERSON; // 7
 
+    protected static final int LDN_MESSAGE = 1 << Constants.LDN_MESSAGE; // 8
+
     protected static final int ALL_OBJECTS_MASK = BITSTREAM | BUNDLE | ITEM
-        | COLLECTION | COMMUNITY | SITE | GROUP | EPERSON;
+        | COLLECTION | COMMUNITY | SITE | GROUP | EPERSON | LDN_MESSAGE;
 
     protected static Map<Integer, Integer> objTypeToMask = new HashMap<Integer, Integer>();
 
@@ -135,6 +137,9 @@ public class Event implements Serializable {
 
         objTypeToMask.put(Constants.EPERSON, EPERSON);
         objMaskToType.put(EPERSON, Constants.EPERSON);
+
+        objTypeToMask.put(Constants.LDN_MESSAGE, LDN_MESSAGE);
+        objMaskToType.put(LDN_MESSAGE, Constants.LDN_MESSAGE);
     }
 
     /** ---------- Event Fields ------------- * */
diff --git a/dspace-api/src/main/java/org/dspace/external/OpenAIRERestConnector.java b/dspace-api/src/main/java/org/dspace/external/OpenaireRestConnector.java
similarity index 92%
rename from dspace-api/src/main/java/org/dspace/external/OpenAIRERestConnector.java
rename to dspace-api/src/main/java/org/dspace/external/OpenaireRestConnector.java
index b0aa4aba13..c96fad1de0 100644
--- a/dspace-api/src/main/java/org/dspace/external/OpenAIRERestConnector.java
+++ b/dspace-api/src/main/java/org/dspace/external/OpenaireRestConnector.java
@@ -40,20 +40,20 @@ import org.json.JSONObject;
 import org.springframework.beans.factory.annotation.Autowired;
 
 /**
- * based on OrcidRestConnector it's a rest connector for OpenAIRE API providing
+ * based on OrcidRestConnector it's a rest connector for Openaire API providing
  * ways to perform searches and token grabbing
  * 
  * @author paulo-graca
  *
  */
-public class OpenAIRERestConnector {
+public class OpenaireRestConnector {
     /**
      * log4j logger
      */
-    private static Logger log = org.apache.logging.log4j.LogManager.getLogger(OpenAIRERestConnector.class);
+    private static Logger log = org.apache.logging.log4j.LogManager.getLogger(OpenaireRestConnector.class);
 
     /**
-     * OpenAIRE API Url
+     * Openaire API Url
      *  and can be configured with: openaire.api.url
      */
     private String url = "https://api.openaire.eu";
@@ -65,30 +65,30 @@ public class OpenAIRERestConnector {
     boolean tokenEnabled = false;
 
     /**
-     * OpenAIRE Authorization and Authentication Token Service URL
+     * Openaire Authorization and Authentication Token Service URL
      *  and can be configured with: openaire.token.url
      */
     private String tokenServiceUrl;
 
     /**
-     * OpenAIRE clientId
+     * Openaire clientId
      *  and can be configured with: openaire.token.clientId
      */
     private String clientId;
 
     /**
-     * OpenAIRERest access token
+     * OpenaireRest access token
      */
-    private OpenAIRERestToken accessToken;
+    private OpenaireRestToken accessToken;
 
     /**
-     * OpenAIRE clientSecret
+     * Openaire clientSecret
      *  and can be configured with: openaire.token.clientSecret
      */
     private String clientSecret;
 
 
-    public OpenAIRERestConnector(String url) {
+    public OpenaireRestConnector(String url) {
         this.url = url;
     }
 
@@ -99,7 +99,7 @@ public class OpenAIRERestConnector {
      * 
      * @throws IOException
      */
-    public OpenAIRERestToken grabNewAccessToken() throws IOException {
+    public OpenaireRestToken grabNewAccessToken() throws IOException {
 
         if (StringUtils.isBlank(tokenServiceUrl) || StringUtils.isBlank(clientId)
                 || StringUtils.isBlank(clientSecret)) {
@@ -145,13 +145,13 @@ public class OpenAIRERestConnector {
             throw new IOException("Unable to grab the access token using provided service url, client id and secret");
         }
 
-        return new OpenAIRERestToken(responseObject.get("access_token").toString(),
+        return new OpenaireRestToken(responseObject.get("access_token").toString(),
                 Long.valueOf(responseObject.get("expires_in").toString()));
 
     }
 
     /**
-     * Perform a GET request to the OpenAIRE API
+     * Perform a GET request to the Openaire API
      * 
      * @param file
      * @param accessToken
@@ -218,12 +218,12 @@ public class OpenAIRERestConnector {
     }
 
     /**
-     * Perform an OpenAIRE Project Search By Keywords
+     * Perform an Openaire Project Search By Keywords
      * 
      * @param page
      * @param size
      * @param keywords
-     * @return OpenAIRE Response
+     * @return Openaire Response
      */
     public Response searchProjectByKeywords(int page, int size, String... keywords) {
         String path = "search/projects?keywords=" + String.join("+", keywords);
@@ -231,13 +231,13 @@ public class OpenAIRERestConnector {
     }
 
     /**
-     * Perform an OpenAIRE Project Search By ID and by Funder
+     * Perform an Openaire Project Search By ID and by Funder
      * 
      * @param projectID
      * @param projectFunder
      * @param page
      * @param size
-     * @return OpenAIRE Response
+     * @return Openaire Response
      */
     public Response searchProjectByIDAndFunder(String projectID, String projectFunder, int page, int size) {
         String path = "search/projects?grantID=" + projectID + "&funder=" + projectFunder;
@@ -245,12 +245,12 @@ public class OpenAIRERestConnector {
     }
 
     /**
-     * Perform an OpenAIRE Search request
+     * Perform an Openaire Search request
      * 
      * @param path
      * @param page
      * @param size
-     * @return OpenAIRE Response
+     * @return Openaire Response
      */
     public Response search(String path, int page, int size) {
         String[] queryStringPagination = { "page=" + page, "size=" + size };
diff --git a/dspace-api/src/main/java/org/dspace/external/OpenAIRERestToken.java b/dspace-api/src/main/java/org/dspace/external/OpenaireRestToken.java
similarity index 89%
rename from dspace-api/src/main/java/org/dspace/external/OpenAIRERestToken.java
rename to dspace-api/src/main/java/org/dspace/external/OpenaireRestToken.java
index 203f09b3c6..f5dc2b27f8 100644
--- a/dspace-api/src/main/java/org/dspace/external/OpenAIRERestToken.java
+++ b/dspace-api/src/main/java/org/dspace/external/OpenaireRestToken.java
@@ -8,13 +8,13 @@
 package org.dspace.external;
 
 /**
- * OpenAIRE rest API token to be used when grabbing an accessToken.<br/>
+ * Openaire rest API token to be used when grabbing an accessToken.<br/>
  * Based on https://develop.openaire.eu/basic.html
  * 
  * @author paulo-graca
  *
  */
-public class OpenAIRERestToken {
+public class OpenaireRestToken {
 
     /**
      * Stored access token
@@ -32,7 +32,7 @@ public class OpenAIRERestToken {
      * @param accessToken
      * @param expiresIn
      */
-    public OpenAIRERestToken(String accessToken, Long expiresIn) {
+    public OpenaireRestToken(String accessToken, Long expiresIn) {
         this.accessToken = accessToken;
         this.setExpirationDate(expiresIn);
     }
diff --git a/dspace-api/src/main/java/org/dspace/external/provider/impl/OpenAIREFundingDataProvider.java b/dspace-api/src/main/java/org/dspace/external/provider/impl/OpenaireFundingDataProvider.java
similarity index 94%
rename from dspace-api/src/main/java/org/dspace/external/provider/impl/OpenAIREFundingDataProvider.java
rename to dspace-api/src/main/java/org/dspace/external/provider/impl/OpenaireFundingDataProvider.java
index 8ca5b7c0ea..62cef508c5 100644
--- a/dspace-api/src/main/java/org/dspace/external/provider/impl/OpenAIREFundingDataProvider.java
+++ b/dspace-api/src/main/java/org/dspace/external/provider/impl/OpenaireFundingDataProvider.java
@@ -31,7 +31,7 @@ import eu.openaire.oaf.model.base.Project;
 import org.apache.commons.lang3.StringUtils;
 import org.apache.logging.log4j.Logger;
 import org.dspace.content.dto.MetadataValueDTO;
-import org.dspace.external.OpenAIRERestConnector;
+import org.dspace.external.OpenaireRestConnector;
 import org.dspace.external.model.ExternalDataObject;
 import org.dspace.external.provider.AbstractExternalDataProvider;
 import org.dspace.importer.external.metadatamapping.MetadataFieldConfig;
@@ -39,13 +39,13 @@ import org.springframework.beans.factory.annotation.Autowired;
 
 /**
  * This class is the implementation of the ExternalDataProvider interface that
- * will deal with the OpenAIRE External Data lookup
+ * will deal with the Openaire External Data lookup
  * 
  * @author paulo-graca
  */
-public class OpenAIREFundingDataProvider extends AbstractExternalDataProvider {
+public class OpenaireFundingDataProvider extends AbstractExternalDataProvider {
 
-    private static Logger log = org.apache.logging.log4j.LogManager.getLogger(OpenAIREFundingDataProvider.class);
+    private static Logger log = org.apache.logging.log4j.LogManager.getLogger(OpenaireFundingDataProvider.class);
 
     /**
      * GrantAgreement prefix
@@ -75,7 +75,7 @@ public class OpenAIREFundingDataProvider extends AbstractExternalDataProvider {
     /**
      * Connector to handle token and requests
      */
-    protected OpenAIRERestConnector connector;
+    protected OpenaireRestConnector connector;
 
     protected Map<String, MetadataFieldConfig> metadataFields;
 
@@ -93,7 +93,7 @@ public class OpenAIREFundingDataProvider extends AbstractExternalDataProvider {
         // characters that must be escaped for the <:entry-id>
         String decodedId = new String(Base64.getDecoder().decode(id));
         if (!isValidProjectURI(decodedId)) {
-            log.error("Invalid ID for OpenAIREFunding - " + id);
+            log.error("Invalid ID for OpenaireFunding - " + id);
             return Optional.empty();
         }
         Response response = searchByProjectURI(decodedId);
@@ -101,7 +101,7 @@ public class OpenAIREFundingDataProvider extends AbstractExternalDataProvider {
         try {
             if (response.getHeader() != null && Integer.parseInt(response.getHeader().getTotal()) > 0) {
                 Project project = response.getResults().getResult().get(0).getMetadata().getEntity().getProject();
-                ExternalDataObject externalDataObject = new OpenAIREFundingDataProvider
+                ExternalDataObject externalDataObject = new OpenaireFundingDataProvider
                         .ExternalDataObjectBuilder(project)
                         .setId(generateProjectURI(project))
                         .setSource(sourceIdentifier)
@@ -123,7 +123,7 @@ public class OpenAIREFundingDataProvider extends AbstractExternalDataProvider {
             limit = LIMIT_DEFAULT;
         }
 
-        // OpenAIRE uses pages and first page starts with 1
+        // Openaire uses pages and first page starts with 1
         int page = (start / limit) + 1;
 
         // escaping query
@@ -148,7 +148,7 @@ public class OpenAIREFundingDataProvider extends AbstractExternalDataProvider {
 
         if (projects.size() > 0) {
             return projects.stream()
-                    .map(project -> new OpenAIREFundingDataProvider
+                    .map(project -> new OpenaireFundingDataProvider
                             .ExternalDataObjectBuilder(project)
                             .setId(generateProjectURI(project))
                             .setSource(sourceIdentifier)
@@ -176,24 +176,24 @@ public class OpenAIREFundingDataProvider extends AbstractExternalDataProvider {
      * Generic setter for the sourceIdentifier
      * 
      * @param sourceIdentifier The sourceIdentifier to be set on this
-     *                         OpenAIREFunderDataProvider
+     *                         OpenaireFunderDataProvider
      */
     @Autowired(required = true)
     public void setSourceIdentifier(String sourceIdentifier) {
         this.sourceIdentifier = sourceIdentifier;
     }
 
-    public OpenAIRERestConnector getConnector() {
+    public OpenaireRestConnector getConnector() {
         return connector;
     }
 
     /**
-     * Generic setter for OpenAIRERestConnector
+     * Generic setter for OpenaireRestConnector
      * 
      * @param connector
      */
     @Autowired(required = true)
-    public void setConnector(OpenAIRERestConnector connector) {
+    public void setConnector(OpenaireRestConnector connector) {
         this.connector = connector;
     }
 
@@ -219,7 +219,7 @@ public class OpenAIREFundingDataProvider extends AbstractExternalDataProvider {
     }
 
     /**
-     * This method returns an URI based on OpenAIRE 3.0 guidelines
+     * This method returns an URI based on Openaire 3.0 guidelines
      * https://guidelines.openaire.eu/en/latest/literature/field_projectid.html that
      * can be used as an ID if is there any missing part, that part it will be
      * replaced by the character '+'
@@ -281,7 +281,7 @@ public class OpenAIREFundingDataProvider extends AbstractExternalDataProvider {
     }
 
     /**
-     * OpenAIRE Funding External Data Builder Class
+     * Openaire Funding External Data Builder Class
      * 
      * @author pgraca
      */
diff --git a/dspace-api/src/main/java/org/dspace/external/service/impl/ExternalDataServiceImpl.java b/dspace-api/src/main/java/org/dspace/external/service/impl/ExternalDataServiceImpl.java
index f91ea00cac..59cbe4f9d0 100644
--- a/dspace-api/src/main/java/org/dspace/external/service/impl/ExternalDataServiceImpl.java
+++ b/dspace-api/src/main/java/org/dspace/external/service/impl/ExternalDataServiceImpl.java
@@ -13,6 +13,8 @@ import java.util.Optional;
 import java.util.stream.Collectors;
 
 import org.apache.logging.log4j.Logger;
+import org.dspace.app.suggestion.SuggestionProvider;
+import org.dspace.app.suggestion.SuggestionService;
 import org.dspace.authorize.AuthorizeException;
 import org.dspace.content.Collection;
 import org.dspace.content.Item;
@@ -44,6 +46,9 @@ public class ExternalDataServiceImpl implements ExternalDataService {
     @Autowired
     private WorkspaceItemService workspaceItemService;
 
+    @Autowired
+    private SuggestionService suggestionService;
+
     @Override
     public Optional<ExternalDataObject> getExternalDataObject(String source, String id) {
         ExternalDataProvider provider = getExternalDataProvider(source);
@@ -105,6 +110,16 @@ public class ExternalDataServiceImpl implements ExternalDataService {
         log.info(LogHelper.getHeader(context, "create_item_from_externalDataObject", "Created item" +
             "with id: " + item.getID() + " from source: " + externalDataObject.getSource() + " with identifier: " +
             externalDataObject.getId()));
+        try {
+            List<SuggestionProvider> providers = suggestionService.getSuggestionProviders();
+            if (providers != null) {
+                for (SuggestionProvider p : providers) {
+                    p.flagRelatedSuggestionsAsProcessed(context, externalDataObject);
+                }
+            }
+        } catch (Exception e) {
+            log.error("Got problems with the solr suggestion storage service: " + e.getMessage(), e);
+        }
         return workspaceItem;
     }
 
diff --git a/dspace-api/src/main/java/org/dspace/importer/external/metadatamapping/contributor/SimpleXpathDateFormatMetadataContributor.java b/dspace-api/src/main/java/org/dspace/importer/external/metadatamapping/contributor/SimpleXpathDateFormatMetadataContributor.java
index fb15cd60ab..f3a186e450 100644
--- a/dspace-api/src/main/java/org/dspace/importer/external/metadatamapping/contributor/SimpleXpathDateFormatMetadataContributor.java
+++ b/dspace-api/src/main/java/org/dspace/importer/external/metadatamapping/contributor/SimpleXpathDateFormatMetadataContributor.java
@@ -87,5 +87,4 @@ public class SimpleXpathDateFormatMetadataContributor extends SimpleXpathMetadat
         dcValue.setSchema(field.getSchema());
         return dcValue;
     }
-
-}
\ No newline at end of file
+}
diff --git a/dspace-api/src/main/java/org/dspace/importer/external/openaire/metadatamapping/OpenAIREPublicationFieldMapping.java b/dspace-api/src/main/java/org/dspace/importer/external/openaire/metadatamapping/OpenAIREPublicationFieldMapping.java
new file mode 100644
index 0000000000..d58ffc8ca9
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/importer/external/openaire/metadatamapping/OpenAIREPublicationFieldMapping.java
@@ -0,0 +1,29 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.importer.external.openaire.metadatamapping;
+
+import java.util.Map;
+import javax.annotation.Resource;
+
+import org.dspace.importer.external.metadatamapping.AbstractMetadataFieldMapping;
+
+/**
+ * An implementation of {@link AbstractMetadataFieldMapping} responsible for
+ * defining the mapping of the OpenAIRE metadatum fields on the DSpace metadatum
+ * fields
+ * 
+ * @author Mykhaylo Boychuk (4science.it)
+ */
+public class OpenAIREPublicationFieldMapping extends AbstractMetadataFieldMapping {
+
+    @Override
+    @Resource(name = "openairePublicationsMetadataFieldMap")
+    public void setMetadataFieldMap(Map metadataFieldMap) {
+        super.setMetadataFieldMap(metadataFieldMap);
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/importer/external/openaire/service/OpenAireImportMetadataSourceServiceImpl.java b/dspace-api/src/main/java/org/dspace/importer/external/openaire/service/OpenAireImportMetadataSourceServiceImpl.java
new file mode 100644
index 0000000000..0e59c9eb0e
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/importer/external/openaire/service/OpenAireImportMetadataSourceServiceImpl.java
@@ -0,0 +1,353 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.importer.external.openaire.service;
+
+import java.io.IOException;
+import java.io.StringReader;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Collection;
+import java.util.List;
+import java.util.concurrent.Callable;
+import javax.el.MethodNotFoundException;
+import javax.ws.rs.client.Client;
+import javax.ws.rs.client.ClientBuilder;
+import javax.ws.rs.client.Invocation;
+import javax.ws.rs.client.WebTarget;
+import javax.ws.rs.core.Response;
+
+import org.dspace.content.Item;
+import org.dspace.importer.external.datamodel.ImportRecord;
+import org.dspace.importer.external.datamodel.Query;
+import org.dspace.importer.external.exception.MetadataSourceException;
+import org.dspace.importer.external.metadatamapping.MetadatumDTO;
+import org.dspace.importer.external.service.AbstractImportMetadataSourceService;
+import org.dspace.importer.external.service.components.QuerySource;
+import org.dspace.services.ConfigurationService;
+import org.jdom2.Document;
+import org.jdom2.Element;
+import org.jdom2.JDOMException;
+import org.jdom2.Namespace;
+import org.jdom2.filter.Filters;
+import org.jdom2.input.SAXBuilder;
+import org.jdom2.xpath.XPathExpression;
+import org.jdom2.xpath.XPathFactory;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implements a data source for querying OpenAIRE
+ *
+ * @author Pasquale Cavallo (pasquale.cavallo at 4science dot it)
+ */
+public class OpenAireImportMetadataSourceServiceImpl extends AbstractImportMetadataSourceService<Element>
+        implements QuerySource {
+
+    @Autowired(required = true)
+    protected ConfigurationService configurationService;
+
+    private String baseAddress;
+
+    private WebTarget webTarget;
+
+    private String queryParam;
+
+    @Override
+    public String getImportSource() {
+        return "openaire";
+    }
+
+    /**
+     * The string that identifies this import implementation. Preferable a URI
+     *
+     * @return the identifying uri
+     */
+    @Override
+    public ImportRecord getRecord(String id) throws MetadataSourceException {
+        return retry(new SearchByIdCallable(id));
+    }
+
+    /**
+     * The string that identifies this import implementation. Preferable a URI
+     *
+     * @return the identifying uri
+     */
+    @Override
+    public ImportRecord getRecord(Query query) throws MetadataSourceException {
+        return retry(new SearchByIdCallable(query));
+    }
+
+
+    /**
+     * Find the number of records matching a query;
+     *
+     * @param query a query string to base the search on.
+     * @return the sum of the matching records over this import source
+     * @throws MetadataSourceException if the underlying methods throw any exception.
+     */
+    @Override
+    public int getRecordsCount(String query) throws MetadataSourceException {
+        return retry(new CountByQueryCallable(query));
+    }
+
+    /**
+     * Find the number of records matching a query;
+     *
+     * @param query a query object to base the search on.
+     * @return the sum of the matching records over this import source
+     * @throws MetadataSourceException if the underlying methods throw any exception.
+     */
+    @Override
+    public int getRecordsCount(Query query) throws MetadataSourceException {
+        return retry(new CountByQueryCallable(query));
+    }
+
+    /**
+     * Find the number of records matching a string query. Supports pagination
+     *
+     * @param query a query string to base the search on.
+     * @param start offset to start at
+     * @param count number of records to retrieve.
+     * @return a set of records. Fully transformed.
+     * @throws MetadataSourceException if the underlying methods throw any exception.
+     */
+    @Override
+    public Collection<ImportRecord> getRecords(String query, int start, int count) throws MetadataSourceException {
+        return retry(new SearchByQueryCallable(query, start, count));
+    }
+
+
+    /**
+     * Find records based on a object query.
+     *
+     * @param query a query object to base the search on.
+     * @return a set of records. Fully transformed.
+     * @throws MetadataSourceException if the underlying methods throw any exception.
+     */
+    @Override
+    public Collection<ImportRecord> getRecords(Query query) throws MetadataSourceException {
+        return retry(new SearchByQueryCallable(query));
+    }
+
+    @Override
+    public Collection<ImportRecord> findMatchingRecords(Query query) throws MetadataSourceException {
+        throw new MethodNotFoundException("This method is not implemented for OpenAIRE");
+    }
+
+    @Override
+    public Collection<ImportRecord> findMatchingRecords(Item item) throws MetadataSourceException {
+        throw new MethodNotFoundException("This method is not implemented for OpenAIRE");
+    }
+
+    /**
+     * Set the baseAddress to this object
+     *
+     * @param baseAddress The String object that represents the baseAddress of this object
+     */
+    public void setBaseAddress(String baseAddress) {
+        this.baseAddress = baseAddress;
+    }
+
+    /**
+     * Return the baseAddress set to this object
+     *
+     * @return The String object that represents the baseAddress of this object
+     */
+    public String getBaseAddress() {
+        return baseAddress;
+    }
+
+    /**
+     * Set the name of the query param, this correspond to the index used (title, author)
+     * 
+     * @param queryParam on which index make the query
+     */
+    public void setQueryParam(String queryParam) {
+        this.queryParam = queryParam;
+    }
+
+    /**
+     * Get the name of the query param for the rest call
+     * 
+     * @return the name of the query param, i.e. the index (title, author) to use
+     */
+    public String getQueryParam() {
+        return queryParam;
+    }
+    /**
+     * Initialize the class
+     *
+     * @throws Exception on generic exception
+     */
+    @Override
+    public void init() throws Exception {
+        Client client = ClientBuilder.newClient();
+        if (baseAddress == null) {
+            baseAddress = configurationService.getProperty("openaire.base.url");
+        }
+        if (queryParam == null) {
+            queryParam = "title";
+        }
+        webTarget = client.target(baseAddress);
+    }
+
+    public class SearchByIdCallable  implements Callable<ImportRecord> {
+
+        String id = null;
+
+        public SearchByIdCallable(String id) {
+            this.id = id;
+        }
+
+        public SearchByIdCallable(Query query) {
+            this.id = query.getParameterAsClass("id", String.class);
+        }
+
+        @Override
+        public ImportRecord call() throws Exception {
+            List<ImportRecord> results = new ArrayList<ImportRecord>();
+            WebTarget localTarget = webTarget.queryParam("openairePublicationID", id);
+            Invocation.Builder invocationBuilder = localTarget.request();
+            Response response = invocationBuilder.get();
+            if (response.getStatus() == 200) {
+                String responseString = response.readEntity(String.class);
+                List<Element> omElements = splitToRecords(responseString);
+                if (omElements != null) {
+                    for (Element record : omElements) {
+                        results.add(filterMultipleTitles(transformSourceRecords(record)));
+                    }
+                }
+                return results != null ? results.get(0) : null;
+            } else {
+                return null;
+            }
+        }
+    }
+
+    public class CountByQueryCallable implements Callable<Integer> {
+
+        String q;
+
+        public CountByQueryCallable(String query) {
+            q = query;
+        }
+
+        public CountByQueryCallable(Query query) {
+            q = query.getParameterAsClass("query", String.class);
+        }
+
+        @Override
+        public Integer call() throws Exception {
+            WebTarget localTarget = webTarget.queryParam(queryParam, q);
+            Invocation.Builder invocationBuilder = localTarget.request();
+            Response response = invocationBuilder.get();
+            if (response.getStatus() == 200) {
+                String responseString = response.readEntity(String.class);
+
+                SAXBuilder saxBuilder = new SAXBuilder();
+                Document document = saxBuilder.build(new StringReader(responseString));
+                Element root = document.getRootElement();
+
+                XPathExpression<Element> xpath = XPathFactory.instance().compile("/header/total",
+                    Filters.element(), null);
+
+                Element totalItem = (Element) xpath.evaluateFirst(root);
+                return totalItem != null ? Integer.parseInt(totalItem.getText()) : null;
+
+            } else {
+                return 0;
+            }
+        }
+    }
+
+    public class SearchByQueryCallable implements Callable<List<ImportRecord>> {
+
+        String q;
+        int page;
+        int count;
+
+        public SearchByQueryCallable(String query, int start, int count) {
+            this.q = query;
+            this.page = start / count;
+            this.count = count;
+        }
+
+        public SearchByQueryCallable(Query query) {
+            this.q = query.getParameterAsClass("query", String.class);
+            this.page = query.getParameterAsClass("start", Integer.class) /
+                query.getParameterAsClass("count", Integer.class);
+            this.count = query.getParameterAsClass("count", Integer.class);
+        }
+
+        @Override
+        public List<ImportRecord> call() throws Exception {
+            WebTarget localTarget = webTarget.queryParam(queryParam, q);
+            localTarget = localTarget.queryParam("page", page + 1);
+            localTarget = localTarget.queryParam("size", count);
+            List<ImportRecord> results = new ArrayList<ImportRecord>();
+            Invocation.Builder invocationBuilder = localTarget.request();
+            Response response = invocationBuilder.get();
+            if (response.getStatus() == 200) {
+                String responseString = response.readEntity(String.class);
+                List<Element> omElements = splitToRecords(responseString);
+                if (omElements != null) {
+                    for (Element record : omElements) {
+                        results.add(filterMultipleTitles(transformSourceRecords(record)));
+                    }
+                }
+            }
+            return results;
+        }
+    }
+
+    /**
+     * This method remove multiple titles occurrences
+     * 
+     * @param transformSourceRecords
+     * @return ImportRecord with one or zero title
+     */
+    private ImportRecord filterMultipleTitles(ImportRecord transformSourceRecords) {
+        List<MetadatumDTO> metadata = (List<MetadatumDTO>)transformSourceRecords.getValueList();
+        ArrayList<MetadatumDTO> nextSourceRecord = new ArrayList<>();
+        boolean found = false;
+        for (MetadatumDTO dto : metadata) {
+            if ("dc".equals(dto.getSchema()) && "title".equals(dto.getElement()) && dto.getQualifier() == null) {
+                if (!found) {
+                    nextSourceRecord.add(dto);
+                    found = true;
+                }
+            } else {
+                nextSourceRecord.add(dto);
+            }
+        }
+        return new ImportRecord(nextSourceRecord);
+    }
+
+    private List<Element> splitToRecords(String recordsSrc) {
+
+        try {
+            SAXBuilder saxBuilder = new SAXBuilder();
+            Document document = saxBuilder.build(new StringReader(recordsSrc));
+            Element root = document.getRootElement();
+
+            List namespaces = Arrays.asList(
+                Namespace.getNamespace("dri", "http://www.driver-repository.eu/namespace/dri"),
+                Namespace.getNamespace("oaf", "http://namespace.openaire.eu/oaf"),
+                Namespace.getNamespace("xsi", "http://www.w3.org/2001/XMLSchema-instance"));
+            XPathExpression<Element> xpath = XPathFactory.instance().compile("//results/result",
+                Filters.element(), null, namespaces);
+
+            List<Element> recordsList = xpath.evaluate(root);
+            return recordsList;
+        } catch (JDOMException | IOException e) {
+            return null;
+        }
+    }
+
+
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/AutomaticProcessingAction.java b/dspace-api/src/main/java/org/dspace/qaevent/AutomaticProcessingAction.java
new file mode 100644
index 0000000000..771650746d
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/AutomaticProcessingAction.java
@@ -0,0 +1,17 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent;
+
+/**
+ * Enumeration of possible actions to perform over a {@link org.dspace.content.QAEvent}
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public enum AutomaticProcessingAction {
+    REJECT, ACCEPT, IGNORE
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/QAEventAutomaticProcessingEvaluation.java b/dspace-api/src/main/java/org/dspace/qaevent/QAEventAutomaticProcessingEvaluation.java
new file mode 100644
index 0000000000..d7c8f3681e
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/QAEventAutomaticProcessingEvaluation.java
@@ -0,0 +1,31 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent;
+
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+
+/**
+ * This interface allows the implemnetation of Automation Processing rules
+ * defining which {@link AutomaticProcessingAction} should be eventually
+ * performed on a specific {@link QAEvent}
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public interface QAEventAutomaticProcessingEvaluation {
+
+    /**
+     * Evaluate a {@link QAEvent} to decide which, if any, {@link AutomaticProcessingAction} should be performed
+     *
+     * @param context the DSpace context
+     * @param qaEvent the quality assurance event
+     * @return        an action of {@link AutomaticProcessingAction} or null if no automatic action should be performed
+     */
+    AutomaticProcessingAction evaluateAutomaticProcessing(Context context, QAEvent qaEvent);
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/QAEventsDeleteCascadeConsumer.java b/dspace-api/src/main/java/org/dspace/qaevent/QAEventsDeleteCascadeConsumer.java
new file mode 100644
index 0000000000..6460c360ec
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/QAEventsDeleteCascadeConsumer.java
@@ -0,0 +1,50 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+
+package org.dspace.qaevent;
+
+import org.dspace.core.Constants;
+import org.dspace.core.Context;
+import org.dspace.event.Consumer;
+import org.dspace.event.Event;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.utils.DSpace;
+
+/**
+ * Consumer to delete qaevents from solr due to the target item deletion
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class QAEventsDeleteCascadeConsumer implements Consumer {
+
+    private QAEventService qaEventService;
+
+    @Override
+    public void initialize() throws Exception {
+        qaEventService = new DSpace().getSingletonService(QAEventService.class);
+    }
+
+    @Override
+    public void finish(Context context) throws Exception {
+
+    }
+
+    @Override
+    public void consume(Context context, Event event) throws Exception {
+        if (event.getEventType() == Event.DELETE) {
+            if (event.getSubjectType() == Constants.ITEM && event.getSubjectID() != null) {
+                qaEventService.deleteEventsByTargetId(event.getSubjectID());
+            }
+        }
+    }
+
+    public void end(Context context) throws Exception {
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/QANotifyPatterns.java b/dspace-api/src/main/java/org/dspace/qaevent/QANotifyPatterns.java
new file mode 100644
index 0000000000..ede1990569
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/QANotifyPatterns.java
@@ -0,0 +1,30 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent;
+
+/**
+ * Constants for Quality Assurance configurations to be used into cfg and xml spring.
+ * 
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ */
+public class QANotifyPatterns {
+
+    public static final String TOPIC_ENRICH_MORE_PROJECT = "ENRICH/MORE/PROJECT";
+    public static final String TOPIC_ENRICH_MISSING_PROJECT = "ENRICH/MISSING/PROJECT";
+    public static final String TOPIC_ENRICH_MISSING_ABSTRACT = "ENRICH/MISSING/ABSTRACT";
+    public static final String TOPIC_ENRICH_MORE_REVIEW = "ENRICH/MORE/REVIEW";
+    public static final String TOPIC_ENRICH_MORE_ENDORSEMENT = "ENRICH/MORE/ENDORSEMENT";
+    public static final String TOPIC_ENRICH_MORE_PID = "ENRICH/MORE/PID";
+    public static final String TOPIC_ENRICH_MISSING_PID = "ENRICH/MISSING/PID";
+    public static final String TOPIC_ENRICH_MORE_LINK = "ENRICH/MORE/LINK";
+
+    /**
+     * Default constructor
+     */
+    private QANotifyPatterns() { }
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/QAScoreAutomaticProcessingEvaluation.java b/dspace-api/src/main/java/org/dspace/qaevent/QAScoreAutomaticProcessingEvaluation.java
new file mode 100644
index 0000000000..f685222d3d
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/QAScoreAutomaticProcessingEvaluation.java
@@ -0,0 +1,151 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent;
+
+import java.sql.SQLException;
+import java.util.UUID;
+
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.content.logic.LogicalStatement;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * A configurable implementation of {@link QAEventAutomaticProcessingEvaluation} allowing to define thresholds for
+ * automatic acceptance, rejection or ignore of {@link QAEvent} matching a specific, optional, item filter
+ * {@link LogicalStatement}. If the item filter is not defined only the score threshold will be used.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class QAScoreAutomaticProcessingEvaluation implements QAEventAutomaticProcessingEvaluation {
+    /**
+     * The minimum score of QAEvent to be considered for automatic approval (trust must be greater or equals to that)
+     */
+    private double scoreToApprove;
+
+    /**
+     * The threshold under which QAEvent are considered for automatic ignore (trust must be less or equals to that)
+     */
+    private double scoreToIgnore;
+
+    /**
+     * The threshold under which QAEvent are considered for automatic rejection (trust must be less or equals to that)
+     */
+    private double scoreToReject;
+
+    /**
+     * The optional logical statement that must pass for item target of a QAEvent to be considered for automatic
+     * approval
+     */
+    private LogicalStatement itemFilterToApprove;
+
+    /**
+     * The optional logical statement that must pass for item target of a QAEvent to be considered for automatic
+     * ignore
+     */
+    private LogicalStatement itemFilterToIgnore;
+
+    /**
+     * The optional logical statement that must pass for item target of a QAEvent to be considered for automatic
+     * rejection
+     */
+    private LogicalStatement itemFilterToReject;
+
+    @Autowired
+    private ItemService itemService;
+
+    @Override
+    public AutomaticProcessingAction evaluateAutomaticProcessing(Context context, QAEvent qaEvent) {
+        Item item = findItem(context, qaEvent.getTarget());
+
+        if (shouldReject(context, qaEvent.getTrust(), item)) {
+            return AutomaticProcessingAction.REJECT;
+        } else if (shouldIgnore(context, qaEvent.getTrust(), item)) {
+            return AutomaticProcessingAction.IGNORE;
+        } else if (shouldApprove(context, qaEvent.getTrust(), item)) {
+            return AutomaticProcessingAction.ACCEPT;
+        } else {
+            return null;
+        }
+
+    }
+
+    private Item findItem(Context context, String uuid) {
+        try {
+            return itemService.find(context, UUID.fromString(uuid));
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private boolean shouldReject(Context context, double trust, Item item) {
+        return trust <= scoreToReject &&
+            (itemFilterToReject == null || itemFilterToReject.getResult(context, item));
+    }
+
+    private boolean shouldIgnore(Context context, double trust, Item item) {
+        return trust <= scoreToIgnore &&
+            (itemFilterToIgnore == null || itemFilterToIgnore.getResult(context, item));
+    }
+
+    private boolean shouldApprove(Context context, double trust, Item item) {
+        return trust >= scoreToApprove &&
+            (itemFilterToApprove == null || itemFilterToApprove.getResult(context, item));
+    }
+
+    public double getScoreToApprove() {
+        return scoreToApprove;
+    }
+
+    public void setScoreToApprove(double scoreToApprove) {
+        this.scoreToApprove = scoreToApprove;
+    }
+
+    public double getScoreToIgnore() {
+        return scoreToIgnore;
+    }
+
+    public void setScoreToIgnore(double scoreToIgnore) {
+        this.scoreToIgnore = scoreToIgnore;
+    }
+
+    public double getScoreToReject() {
+        return scoreToReject;
+    }
+
+    public void setScoreToReject(double scoreToReject) {
+        this.scoreToReject = scoreToReject;
+    }
+
+    public LogicalStatement getItemFilterToApprove() {
+        return itemFilterToApprove;
+    }
+
+    public void setItemFilterToApprove(LogicalStatement itemFilterToApprove) {
+        this.itemFilterToApprove = itemFilterToApprove;
+    }
+
+    public LogicalStatement getItemFilterToIgnore() {
+        return itemFilterToIgnore;
+    }
+
+    public void setItemFilterToIgnore(LogicalStatement itemFilterToIgnore) {
+        this.itemFilterToIgnore = itemFilterToIgnore;
+    }
+
+    public LogicalStatement getItemFilterToReject() {
+        return itemFilterToReject;
+    }
+
+    public void setItemFilterToReject(LogicalStatement itemFilterToReject) {
+        this.itemFilterToReject = itemFilterToReject;
+    }
+}
+
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/QASource.java b/dspace-api/src/main/java/org/dspace/qaevent/QASource.java
new file mode 100644
index 0000000000..10849b47fc
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/QASource.java
@@ -0,0 +1,67 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent;
+
+import java.util.Date;
+import java.util.UUID;
+
+/**
+ * This model class represent the source/provider of the QA events (as Openaire).
+ * 
+ * @author Luca Giamminonni (luca.giamminonni at 4Science)
+ *
+ */
+public class QASource {
+
+    /**
+     * The focus attributes specify if the QASource object is describing the status of a specific
+     * quality assurance source for the whole repository (focus = null) or for a specific
+     * DSpaceObject (focus = uuid of the DSpaceObject). This would mostly affect the totalEvents attribute below.
+     */
+    private UUID focus;
+    private String name;
+    private Date lastEvent;
+    private long totalEvents;
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public long getTotalEvents() {
+        return totalEvents;
+    }
+
+    public void setTotalEvents(long totalEvents) {
+        this.totalEvents = totalEvents;
+    }
+
+    public Date getLastEvent() {
+        return lastEvent;
+    }
+
+    public void setLastEvent(Date lastEvent) {
+        this.lastEvent = lastEvent;
+    }
+
+    public UUID getFocus() {
+        return focus;
+    }
+
+    public void setFocus(UUID focus) {
+        this.focus = focus;
+    }
+
+    @Override
+    public String toString() {
+        return name + focus + totalEvents;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/QATopic.java b/dspace-api/src/main/java/org/dspace/qaevent/QATopic.java
new file mode 100644
index 0000000000..92fe3737f4
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/QATopic.java
@@ -0,0 +1,73 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent;
+
+import java.util.Date;
+import java.util.UUID;
+
+/**
+ * This model class represent the quality assurance broker topic concept. A
+ * topic represents a type of event and is therefore used to group events.
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+public class QATopic {
+
+    /**
+     * The focus attributes specify if the QATopic object is describing the status of a specific
+     * quality assurance topic for the whole repository (focus = null) or for a specific
+     * DSpaceObject (focus = uuid of the DSpaceObject). This would mostly affect the totalEvents attribute below.
+     */
+    private UUID focus;
+    private String key;
+    /**
+     * The source attributes contains the name of the QA source like: OpenAIRE, DSpaceUsers
+     */
+    private String source;
+    private Date lastEvent;
+    private long totalEvents;
+
+    public String getSource() {
+        return source;
+    }
+
+    public void setSource(String source) {
+        this.source = source;
+    }
+    public String getKey() {
+        return key;
+    }
+
+    public void setKey(String key) {
+        this.key = key;
+    }
+
+    public void setFocus(UUID focus) {
+        this.focus = focus;
+    }
+
+    public UUID getFocus() {
+        return focus;
+    }
+
+    public long getTotalEvents() {
+        return totalEvents;
+    }
+
+    public void setTotalEvents(long totalEvents) {
+        this.totalEvents = totalEvents;
+    }
+
+    public Date getLastEvent() {
+        return lastEvent;
+    }
+
+    public void setLastEvent(Date lastEvent) {
+        this.lastEvent = lastEvent;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/QualityAssuranceAction.java b/dspace-api/src/main/java/org/dspace/qaevent/QualityAssuranceAction.java
new file mode 100644
index 0000000000..f2aebba799
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/QualityAssuranceAction.java
@@ -0,0 +1,31 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent;
+
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+
+/**
+ * Interface for classes that perform a correction on the given item.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public interface QualityAssuranceAction {
+
+    /**
+     * Perform a correction on the given item.
+     *
+     * @param context     the DSpace context
+     * @param item        the item to correct
+     * @param relatedItem the related item, if any
+     * @param message     the message with the correction details
+     */
+    public void applyCorrection(Context context, Item item, Item relatedItem, QAMessageDTO message);
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/action/AMetadataMapAction.java b/dspace-api/src/main/java/org/dspace/qaevent/action/AMetadataMapAction.java
new file mode 100644
index 0000000000..ee81988f63
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/action/AMetadataMapAction.java
@@ -0,0 +1,82 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.action;
+
+import java.sql.SQLException;
+import java.util.Map;
+
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.content.Item;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.qaevent.QualityAssuranceAction;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implementation of {@link QualityAssuranceAction} that add a specific metadata on the given
+ * item based on the child class implementation.
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ *
+ */
+public abstract class AMetadataMapAction implements QualityAssuranceAction {
+    public static final String DEFAULT = "default";
+
+    private Map<String, String> types;
+    @Autowired
+    private ItemService itemService;
+
+    public void setItemService(ItemService itemService) {
+        this.itemService = itemService;
+    }
+
+    public Map<String, String> getTypes() {
+        return types;
+    }
+
+    public void setTypes(Map<String, String> types) {
+        this.types = types;
+    }
+
+    public abstract String extractMetadataType(QAMessageDTO message);
+    public abstract String extractMetadataValue(QAMessageDTO message);
+
+    /**
+     * Apply the correction on one metadata field of the given item based on the
+     * openaire message type.
+     */
+    @Override
+    public void applyCorrection(Context context, Item item, Item relatedItem, QAMessageDTO message) {
+
+        try {
+            String targetMetadata = types.get(extractMetadataType(message));
+            if (targetMetadata == null) {
+                targetMetadata = types.get(DEFAULT);
+            }
+            String[] metadata = splitMetadata(targetMetadata);
+            itemService.addMetadata(context, item, metadata[0], metadata[1], metadata[2], null,
+                extractMetadataValue(message));
+            itemService.update(context, item);
+        } catch (SQLException | AuthorizeException e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+
+    public String[] splitMetadata(String metadata) {
+        String[] result = new String[3];
+        String[] split = metadata.split("\\.");
+        result[0] = split[0];
+        result[1] = split[1];
+        if (split.length == 3) {
+            result[2] = split[2];
+        }
+        return result;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/action/ASimpleMetadataAction.java b/dspace-api/src/main/java/org/dspace/qaevent/action/ASimpleMetadataAction.java
new file mode 100644
index 0000000000..3acaa726e0
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/action/ASimpleMetadataAction.java
@@ -0,0 +1,65 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.action;
+
+import java.sql.SQLException;
+
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.content.Item;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.qaevent.QualityAssuranceAction;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Abstract class for Simple metadata action.
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ *
+ */
+public abstract class ASimpleMetadataAction implements QualityAssuranceAction {
+    private String metadata;
+    private String metadataSchema;
+    private String metadataElement;
+    private String metadataQualifier;
+    @Autowired
+    private ItemService itemService;
+
+    public void setItemService(ItemService itemService) {
+        this.itemService = itemService;
+    }
+
+    public String getMetadata() {
+        return metadata;
+    }
+
+    public void setMetadata(String metadata) {
+        this.metadata = metadata;
+        String[] split = metadata.split("\\.");
+        this.metadataSchema = split[0];
+        this.metadataElement = split[1];
+        if (split.length == 3) {
+            this.metadataQualifier = split[2];
+        }
+    }
+
+    public abstract String extractMetadataValue(QAMessageDTO message);
+
+    @Override
+    public void applyCorrection(Context context, Item item, Item relatedItem, QAMessageDTO message) {
+        try {
+            String metadataValue = extractMetadataValue(message);
+            itemService.addMetadata(context, item, metadataSchema, metadataElement, metadataQualifier, null,
+                metadataValue);
+            itemService.update(context, item);
+        } catch (SQLException | AuthorizeException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/action/QAEntityOpenaireMetadataAction.java b/dspace-api/src/main/java/org/dspace/qaevent/action/QAEntityOpenaireMetadataAction.java
new file mode 100644
index 0000000000..f244418dd0
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/action/QAEntityOpenaireMetadataAction.java
@@ -0,0 +1,180 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.action;
+
+import java.sql.SQLException;
+import java.util.Map;
+
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.content.Collection;
+import org.dspace.content.EntityType;
+import org.dspace.content.Item;
+import org.dspace.content.RelationshipType;
+import org.dspace.content.WorkspaceItem;
+import org.dspace.content.service.CollectionService;
+import org.dspace.content.service.EntityTypeService;
+import org.dspace.content.service.InstallItemService;
+import org.dspace.content.service.ItemService;
+import org.dspace.content.service.RelationshipService;
+import org.dspace.content.service.RelationshipTypeService;
+import org.dspace.content.service.WorkspaceItemService;
+import org.dspace.core.Context;
+import org.dspace.qaevent.QualityAssuranceAction;
+import org.dspace.qaevent.service.dto.OpenaireMessageDTO;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implementation of {@link QualityAssuranceAction} that handle the relationship between the
+ * item to correct and a related item.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class QAEntityOpenaireMetadataAction implements QualityAssuranceAction {
+    private String relation;
+    private String entityType;
+    private Map<String, String> entityMetadata;
+
+    @Autowired
+    private InstallItemService installItemService;
+
+    @Autowired
+    private ItemService itemService;
+
+    @Autowired
+    private EntityTypeService entityTypeService;
+
+    @Autowired
+    private RelationshipService relationshipService;
+
+    @Autowired
+    private RelationshipTypeService relationshipTypeService;
+
+    @Autowired
+    private WorkspaceItemService workspaceItemService;
+
+    @Autowired
+    private CollectionService collectionService;
+
+    public void setItemService(ItemService itemService) {
+        this.itemService = itemService;
+    }
+
+    public String getRelation() {
+        return relation;
+    }
+
+    public void setRelation(String relation) {
+        this.relation = relation;
+    }
+
+    public String[] splitMetadata(String metadata) {
+        String[] result = new String[3];
+        String[] split = metadata.split("\\.");
+        result[0] = split[0];
+        result[1] = split[1];
+        if (split.length == 3) {
+            result[2] = split[2];
+        }
+        return result;
+    }
+
+    public String getEntityType() {
+        return entityType;
+    }
+
+    public void setEntityType(String entityType) {
+        this.entityType = entityType;
+    }
+
+    public Map<String, String> getEntityMetadata() {
+        return entityMetadata;
+    }
+
+    public void setEntityMetadata(Map<String, String> entityMetadata) {
+        this.entityMetadata = entityMetadata;
+    }
+
+    @Override
+    public void applyCorrection(Context context, Item item, Item relatedItem, QAMessageDTO message) {
+        try {
+            if (relatedItem != null) {
+                link(context, item, relatedItem);
+            } else {
+
+                Collection collection = collectionService.retrieveCollectionWithSubmitByEntityType(context,
+                    item, entityType);
+                if (collection == null) {
+                    throw new IllegalStateException("No collection found by entity type: " + collection);
+                }
+
+                WorkspaceItem workspaceItem = workspaceItemService.create(context, collection, true);
+                relatedItem = workspaceItem.getItem();
+
+                for (String key : entityMetadata.keySet()) {
+                    String value = getValue(message, key);
+                    if (StringUtils.isNotBlank(value)) {
+                        String[] targetMetadata = splitMetadata(entityMetadata.get(key));
+                        itemService.addMetadata(context, relatedItem, targetMetadata[0], targetMetadata[1],
+                                targetMetadata[2], null, value);
+                    }
+                }
+                installItemService.installItem(context, workspaceItem);
+                itemService.update(context, relatedItem);
+                link(context, item, relatedItem);
+            }
+        } catch (SQLException | AuthorizeException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Create a new relationship between the two given item, based on the configured
+     * relation.
+     */
+    private void link(Context context, Item item, Item relatedItem) throws SQLException, AuthorizeException {
+        EntityType project = entityTypeService.findByEntityType(context, entityType);
+        RelationshipType relType = relationshipTypeService.findByEntityType(context, project).stream()
+                .filter(r -> StringUtils.equals(r.getRightwardType(), relation)).findFirst()
+                .orElseThrow(() -> new IllegalStateException("No relationshipType named " + relation
+                        + " was found for the entity type " + entityType
+                        + ". A proper configuration is required to use the QAEntitiyMetadataAction."
+                        + " If you don't manage funding in your repository please skip this topic in"
+                        + " the qaevents.cfg"));
+        // Create the relationship
+        relationshipService.create(context, item, relatedItem, relType, -1, -1);
+    }
+
+    private String getValue(QAMessageDTO message, String key) {
+        if (!(message instanceof OpenaireMessageDTO)) {
+            return null;
+        }
+
+        OpenaireMessageDTO openaireMessage = (OpenaireMessageDTO) message;
+
+        if (StringUtils.equals(key, "acronym")) {
+            return openaireMessage.getAcronym();
+        } else if (StringUtils.equals(key, "code")) {
+            return openaireMessage.getCode();
+        } else if (StringUtils.equals(key, "funder")) {
+            return openaireMessage.getFunder();
+        } else if (StringUtils.equals(key, "fundingProgram")) {
+            return openaireMessage.getFundingProgram();
+        } else if (StringUtils.equals(key, "jurisdiction")) {
+            return openaireMessage.getJurisdiction();
+        } else if (StringUtils.equals(key, "openaireId")) {
+            return openaireMessage.getOpenaireId();
+        } else if (StringUtils.equals(key, "title")) {
+            return openaireMessage.getTitle();
+        }
+
+        return null;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/action/QANotifyMetadataMapAction.java b/dspace-api/src/main/java/org/dspace/qaevent/action/QANotifyMetadataMapAction.java
new file mode 100644
index 0000000000..a85a386550
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/action/QANotifyMetadataMapAction.java
@@ -0,0 +1,31 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.action;
+
+import org.dspace.qaevent.service.dto.NotifyMessageDTO;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+
+/**
+ * Notify Implementation {@link AMetadataMapAction}
+ * 
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ *
+ */
+public class QANotifyMetadataMapAction extends AMetadataMapAction {
+
+    @Override
+    public String extractMetadataType(QAMessageDTO message) {
+        return ((NotifyMessageDTO)message).getRelationship();
+    }
+
+    @Override
+    public String extractMetadataValue(QAMessageDTO message) {
+        return ((NotifyMessageDTO)message).getHref();
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/action/QANotifySimpleMetadataAction.java b/dspace-api/src/main/java/org/dspace/qaevent/action/QANotifySimpleMetadataAction.java
new file mode 100644
index 0000000000..ffb70fce66
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/action/QANotifySimpleMetadataAction.java
@@ -0,0 +1,26 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.action;
+
+import org.dspace.qaevent.QualityAssuranceAction;
+import org.dspace.qaevent.service.dto.NotifyMessageDTO;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+
+/**
+ * Implementation of {@link QualityAssuranceAction} that add a simple metadata to the given
+ * item.
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ *
+ */
+public class QANotifySimpleMetadataAction extends ASimpleMetadataAction {
+
+    public String extractMetadataValue(QAMessageDTO message) {
+        return ((NotifyMessageDTO) message).getHref();
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/action/QAOpenaireMetadataMapAction.java b/dspace-api/src/main/java/org/dspace/qaevent/action/QAOpenaireMetadataMapAction.java
new file mode 100644
index 0000000000..427ad2bfde
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/action/QAOpenaireMetadataMapAction.java
@@ -0,0 +1,31 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.action;
+
+import org.dspace.qaevent.service.dto.OpenaireMessageDTO;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+
+/**
+ * Openaire Implementation {@link AMetadataMapAction}
+ * 
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ *
+ */
+public class QAOpenaireMetadataMapAction extends AMetadataMapAction {
+
+    @Override
+    public String extractMetadataType(QAMessageDTO message) {
+        return ((OpenaireMessageDTO)message).getType();
+    }
+
+    @Override
+    public String extractMetadataValue(QAMessageDTO message) {
+        return ((OpenaireMessageDTO)message).getValue();
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/action/QAOpenaireSimpleMetadataAction.java b/dspace-api/src/main/java/org/dspace/qaevent/action/QAOpenaireSimpleMetadataAction.java
new file mode 100644
index 0000000000..3baa95eced
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/action/QAOpenaireSimpleMetadataAction.java
@@ -0,0 +1,26 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.action;
+
+import org.dspace.qaevent.QualityAssuranceAction;
+import org.dspace.qaevent.service.dto.OpenaireMessageDTO;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+
+/**
+ * Implementation of {@link QualityAssuranceAction} that add a simple metadata to the given
+ * item.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class QAOpenaireSimpleMetadataAction extends ASimpleMetadataAction {
+
+    public String extractMetadataValue(QAMessageDTO message) {
+        return ((OpenaireMessageDTO) message).getAbstracts();
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/action/QAReinstateRequestAction.java b/dspace-api/src/main/java/org/dspace/qaevent/action/QAReinstateRequestAction.java
new file mode 100644
index 0000000000..7fa08dc6ec
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/action/QAReinstateRequestAction.java
@@ -0,0 +1,44 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.action;
+
+import java.sql.SQLException;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.content.Item;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.qaevent.QualityAssuranceAction;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * QAReinstateRequestAction is an implementation of the QualityAssuranceAction interface.
+ * It is responsible for applying a correction to reinstate a specified item.
+ *
+ * @author Mykhaylo Boychuk (mykhaylo.boychuk@4science.com)
+ */
+public class QAReinstateRequestAction implements QualityAssuranceAction {
+
+    private static final Logger log = LogManager.getLogger();
+
+    @Autowired
+    private ItemService itemService;
+
+    @Override
+    public void applyCorrection(Context context, Item item, Item relatedItem, QAMessageDTO message) {
+        try {
+            itemService.reinstate(context, item);
+        } catch (SQLException | AuthorizeException e) {
+            log.error(e.getMessage(), e);
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/action/QAWithdrawnRequestAction.java b/dspace-api/src/main/java/org/dspace/qaevent/action/QAWithdrawnRequestAction.java
new file mode 100644
index 0000000000..a0463fdb18
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/action/QAWithdrawnRequestAction.java
@@ -0,0 +1,44 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.action;
+
+import java.sql.SQLException;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.content.Item;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.qaevent.QualityAssuranceAction;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * QAWithdrawnRequestAction is an implementation of the QualityAssuranceAction interface.
+ * It is responsible for applying a correction to withdraw a specified item.
+ *
+ * @author Mykhaylo Boychuk (mykhaylo.boychuk@4science.com)
+ */
+public class QAWithdrawnRequestAction implements QualityAssuranceAction {
+
+    private static final Logger log = LogManager.getLogger();
+
+    @Autowired
+    private ItemService itemService;
+
+    @Override
+    public void applyCorrection(Context context, Item item, Item relatedItem, QAMessageDTO message) {
+        try {
+            itemService.withdraw(context, item);
+        } catch (SQLException | AuthorizeException e) {
+            log.error(e.getMessage(), e);
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/dao/QAEventsDAO.java b/dspace-api/src/main/java/org/dspace/qaevent/dao/QAEventsDAO.java
new file mode 100644
index 0000000000..98c38ca3f5
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/dao/QAEventsDAO.java
@@ -0,0 +1,92 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.dao;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.content.Item;
+import org.dspace.content.QAEventProcessed;
+import org.dspace.core.Context;
+import org.dspace.core.GenericDAO;
+import org.dspace.eperson.EPerson;
+
+/**
+ * DAO that handle processed QA Events.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public interface QAEventsDAO extends GenericDAO<QAEventProcessed> {
+
+    /**
+     * Returns all the stored QAEventProcessed entities.
+     *
+     * @param  context      the DSpace context
+     * @return              the found entities
+     * @throws SQLException if an SQL error occurs
+     */
+    public List<QAEventProcessed> findAll(Context context) throws SQLException;
+
+    /**
+     * Returns the stored QAEventProcessed entities by item.
+     *
+     * @param  context      the DSpace context
+     * @param  item         the item to search for
+     * @return              the found entities
+     * @throws SQLException if an SQL error occurs
+     */
+    public List<QAEventProcessed> findByItem(Context context, Item item) throws SQLException;
+
+    /**
+     * Returns the stored QAEventProcessed entities by eperson.
+     *
+     * @param  context      the DSpace context
+     * @param  ePerson      the ePerson to search for
+     * @return              the found entities
+     * @throws SQLException if an SQL error occurs
+     */
+    public List<QAEventProcessed> findByEPerson(Context context, EPerson ePerson) throws SQLException;
+
+    /**
+     * Search a page of quality assurance broker events by notification ID.
+     * 
+     * @param  context      the DSpace context
+     * @param  eventId      the event id
+     * @param  start        the start index
+     * @param  size         the size to be applied
+     * @return              the processed events
+     * @throws SQLException if an SQL error occurs
+     */
+    public List<QAEventProcessed> searchByEventId(Context context, String eventId, Integer start, Integer size)
+        throws SQLException;
+
+    /**
+     * Check if an event with the given checksum is already stored.
+     * 
+     * @param  context      the DSpace context
+     * @param  checksum     the checksum to search for
+     * @return              true if the given checksum is related to an already
+     *                      stored event, false otherwise
+     * @throws SQLException if an SQL error occurs
+     */
+    public boolean isEventStored(Context context, String checksum) throws SQLException;
+
+    /**
+     * Store an event related to the given checksum.
+     *
+     * @param  context  the DSpace context
+     * @param  checksum the checksum of the event to be store
+     * @param  eperson  the eperson who handle the event
+     * @param  item     the item related to the event
+     * @return          true if the creation is completed with success, false
+     *                  otherwise
+     */
+    boolean storeEvent(Context context, String checksum, EPerson eperson, Item item);
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/dao/impl/QAEventsDAOImpl.java b/dspace-api/src/main/java/org/dspace/qaevent/dao/impl/QAEventsDAOImpl.java
new file mode 100644
index 0000000000..ac9b96045e
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/dao/impl/QAEventsDAOImpl.java
@@ -0,0 +1,90 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.dao.impl;
+
+import java.sql.SQLException;
+import java.util.Date;
+import java.util.List;
+import javax.persistence.Query;
+
+import org.dspace.content.Item;
+import org.dspace.content.QAEventProcessed;
+import org.dspace.core.AbstractHibernateDAO;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+import org.dspace.qaevent.dao.QAEventsDAO;
+
+/**
+ * Implementation of {@link QAEventsDAO} that store processed events using an
+ * SQL DBMS.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class QAEventsDAOImpl extends AbstractHibernateDAO<QAEventProcessed> implements QAEventsDAO {
+
+    @Override
+    public List<QAEventProcessed> findAll(Context context) throws SQLException {
+        return findAll(context, QAEventProcessed.class);
+    }
+
+    @Override
+    public boolean storeEvent(Context context, String checksum, EPerson eperson, Item item) {
+        QAEventProcessed qaEvent = new QAEventProcessed();
+        qaEvent.setEperson(eperson);
+        qaEvent.setEventId(checksum);
+        qaEvent.setItem(item);
+        qaEvent.setEventTimestamp(new Date());
+        try {
+            create(context, qaEvent);
+            return true;
+        } catch (SQLException e) {
+            return false;
+        }
+    }
+
+    @Override
+    public boolean isEventStored(Context context, String checksum) throws SQLException {
+        Query query = createQuery(context,
+                "SELECT count(eventId) FROM QAEventProcessed qaevent WHERE qaevent.eventId = :event_id ");
+        query.setParameter("event_id", checksum);
+        return count(query) != 0;
+    }
+
+    @Override
+    public List<QAEventProcessed> searchByEventId(Context context, String eventId, Integer start, Integer size)
+            throws SQLException {
+        Query query = createQuery(context,
+                "SELECT * FROM QAEventProcessed qaevent WHERE qaevent.qaevent_id = :event_id ");
+        query.setFirstResult(start);
+        query.setMaxResults(size);
+        query.setParameter("event_id", eventId);
+        return findMany(context, query);
+    }
+
+    @Override
+    public List<QAEventProcessed> findByItem(Context context, Item item) throws SQLException {
+        Query query = createQuery(context, ""
+            + " SELECT qaevent "
+            + " FROM QAEventProcessed qaevent "
+            + " WHERE qaevent.item = :item ");
+        query.setParameter("item", item);
+        return findMany(context, query);
+    }
+
+    @Override
+    public List<QAEventProcessed> findByEPerson(Context context, EPerson ePerson) throws SQLException {
+        Query query = createQuery(context, ""
+            + " SELECT qaevent "
+            + " FROM QAEventProcessed qaevent "
+            + " WHERE qaevent.eperson = :eperson ");
+        query.setParameter("eperson", ePerson);
+        return findMany(context, query);
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImport.java b/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImport.java
new file mode 100644
index 0000000000..cbaf808422
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImport.java
@@ -0,0 +1,355 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.script;
+
+import static org.apache.commons.lang3.StringUtils.isNotBlank;
+import static org.apache.commons.lang3.StringUtils.substringAfter;
+import static org.dspace.core.Constants.ITEM;
+
+import java.io.ByteArrayInputStream;
+import java.io.ByteArrayOutputStream;
+import java.io.InputStream;
+import java.net.MalformedURLException;
+import java.net.URL;
+import java.sql.SQLException;
+import java.util.List;
+import java.util.UUID;
+
+import com.fasterxml.jackson.core.type.TypeReference;
+import com.fasterxml.jackson.databind.DeserializationFeature;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.json.JsonMapper;
+import eu.dnetlib.broker.BrokerClient;
+import org.apache.commons.cli.ParseException;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.commons.lang3.exception.ExceptionUtils;
+import org.dspace.content.DSpaceObject;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+import org.dspace.eperson.factory.EPersonServiceFactory;
+import org.dspace.handle.HandleServiceImpl;
+import org.dspace.handle.service.HandleService;
+import org.dspace.qaevent.service.OpenaireClientFactory;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.scripts.DSpaceRunnable;
+import org.dspace.services.ConfigurationService;
+import org.dspace.services.factory.DSpaceServicesFactory;
+import org.dspace.utils.DSpace;
+
+/**
+ * Implementation of {@link DSpaceRunnable} to perfom a QAEvents import from a
+ * json file. The JSON file contains an array of JSON Events, where each event
+ * has the following structure. The message attribute follows the structure
+ * documented at
+ * @see <a href="https://graph.openaire.eu/docs/category/entities" target="_blank"> see </a>
+ * 
+ * <code> <br/>
+ * { <br/>
+ * "originalId": "oai:www.openstarts.units.it:10077/21838",<br/>
+ * "title": "Egypt, crossroad of translations and literary interweavings", <br/>
+ * "topic": "ENRICH/MORE/PROJECT", <br/>
+ * "trust": 1.0, <br/>
+ * "message": { <br/>
+ * "projects[0].acronym": "PAThs", <br/>
+ * "projects[0].code": "687567", <br/>
+ * "projects[0].funder": "EC",<br/>
+ * "projects[0].fundingProgram": "H2020", <br/>
+ * "projects[0].jurisdiction": "EU",<br/>
+ * "projects[0].openaireId": "40|corda__h2020::6e32f5eb912688f2424c68b851483ea4", <br/>
+ * "projects[0].title": "Tracking Papyrus and Parchment Paths" <br/>
+ * } <br/>
+ * }
+ * </code>
+ * 
+ * @author Alessandro Martelli (alessandro.martelli at 4science.it)
+ * @author Luca Giamminonni (luca.giamminonni at 4Science.it)
+ *
+ */
+public class OpenaireEventsImport
+    extends DSpaceRunnable<OpenaireEventsImportScriptConfiguration<OpenaireEventsImport>> {
+
+    private HandleService handleService;
+
+    private QAEventService qaEventService;
+
+    private String[] topicsToImport;
+
+    private ConfigurationService configurationService;
+
+    private BrokerClient brokerClient;
+
+    private ObjectMapper jsonMapper;
+
+    private URL openaireBrokerURL;
+
+    private String fileLocation;
+
+    private String email;
+
+    private Context context;
+
+    @Override
+    @SuppressWarnings({ "rawtypes" })
+    public OpenaireEventsImportScriptConfiguration getScriptConfiguration() {
+        OpenaireEventsImportScriptConfiguration configuration = new DSpace().getServiceManager()
+                .getServiceByName("import-openaire-events", OpenaireEventsImportScriptConfiguration.class);
+        return configuration;
+    }
+
+    @Override
+    public void setup() throws ParseException {
+
+        jsonMapper = new JsonMapper();
+        jsonMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
+
+        DSpace dspace = new DSpace();
+        handleService = dspace.getSingletonService(HandleServiceImpl.class);
+        qaEventService = dspace.getSingletonService(QAEventService.class);
+        configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();
+        brokerClient = OpenaireClientFactory.getInstance().getBrokerClient();
+
+        topicsToImport = configurationService.getArrayProperty("qaevents.openaire.import.topic");
+        openaireBrokerURL = getOpenaireBrokerUri();
+
+        fileLocation = commandLine.getOptionValue("f");
+        email = commandLine.getOptionValue("e");
+
+    }
+
+    @Override
+    public void internalRun() throws Exception {
+
+        if (StringUtils.isAllBlank(fileLocation, email)) {
+            throw new IllegalArgumentException("One parameter between the location of the file and the email "
+                + "must be entered to proceed with the import.");
+        }
+
+        if (StringUtils.isNoneBlank(fileLocation, email)) {
+            throw new IllegalArgumentException("Only one parameter between the location of the file and the email "
+                + "must be entered to proceed with the import.");
+        }
+
+        context = new Context();
+        assignCurrentUserInContext();
+
+        try {
+            importOpenaireEvents();
+        } catch (Exception ex) {
+            handler.logError("A not recoverable error occurs during OPENAIRE events import: " + getMessage(ex), ex);
+            throw ex;
+        }
+
+    }
+
+    /**
+     * Read the OPENAIRE events from the given JSON file or directly from the
+     * OPENAIRE broker and try to store them.
+     */
+    private void importOpenaireEvents() throws Exception {
+
+        if (StringUtils.isNotBlank(fileLocation)) {
+            handler.logInfo("Trying to read the QA events from the provided file");
+            importOpenaireEventsFromFile();
+        } else {
+            handler.logInfo("Trying to read the QA events from the OPENAIRE broker");
+            importOpenaireEventsFromBroker();
+        }
+
+    }
+
+    /**
+     * Read the OPENAIRE events from the given file location and try to store them.
+     */
+    private void importOpenaireEventsFromFile() throws Exception {
+
+        InputStream eventsFileInputStream = getQAEventsFileInputStream();
+        List<QAEvent> qaEvents = readOpenaireQAEventsFromJson(eventsFileInputStream);
+
+        handler.logInfo("Found " + qaEvents.size() + " events in the given file");
+
+        storeOpenaireQAEvents(qaEvents);
+
+    }
+
+    /**
+     * Import the OPENAIRE events from the Broker using the subscription related to
+     * the given email and try to store them.
+     */
+    private void importOpenaireEventsFromBroker() {
+
+        List<String> subscriptionIds = listEmailSubscriptions();
+
+        handler.logInfo("Found " + subscriptionIds.size() + " subscriptions related to the given email");
+
+        for (String subscriptionId : subscriptionIds) {
+
+            List<QAEvent> events = readOpenaireQAEventsFromBroker(subscriptionId);
+
+            handler.logInfo("Found " + events.size() + " events from the subscription " + subscriptionId);
+
+            storeOpenaireQAEvents(events);
+
+        }
+    }
+
+    /**
+     * Obtain an InputStream from the runnable instance.
+     */
+    private InputStream getQAEventsFileInputStream() throws Exception {
+        return handler.getFileStream(context, fileLocation)
+            .orElseThrow(() -> new IllegalArgumentException("Error reading file, the file couldn't be "
+                + "found for filename: " + fileLocation));
+    }
+
+    /**
+     * Read all the QAEvent from the OPENAIRE Broker related to the subscription
+     * with the given id.
+     */
+    private List<QAEvent> readOpenaireQAEventsFromBroker(String subscriptionId) {
+
+        try {
+            InputStream eventsInputStream = getEventsBySubscriptions(subscriptionId);
+            return readOpenaireQAEventsFromJson(eventsInputStream);
+        } catch (Exception ex) {
+            handler.logError("An error occurs downloading the events related to the subscription "
+                + subscriptionId + ": " + getMessage(ex), ex);
+        }
+
+        return List.of();
+
+    }
+
+    /**
+     * Read all the QAEvent present in the given input stream.
+     *
+     * @return the QA events to be imported
+     */
+    private List<QAEvent> readOpenaireQAEventsFromJson(InputStream inputStream) throws Exception {
+        return jsonMapper.readValue(inputStream, new TypeReference<List<QAEvent>>() {
+        });
+    }
+
+    /**
+     * Store the given QAEvents.
+     *
+     * @param events the event to be stored
+     */
+    private void storeOpenaireQAEvents(List<QAEvent> events) {
+        for (QAEvent event : events) {
+            try {
+                final String resourceUUID = getResourceUUID(context, event.getOriginalId());
+                if (resourceUUID == null) {
+                    throw new IllegalArgumentException("Skipped event " + event.getEventId() +
+                        " related to the oai record " + event.getOriginalId() + " as the record was not found");
+                }
+                event.setTarget(resourceUUID);
+                storeOpenaireQAEvent(event);
+            } catch (RuntimeException | SQLException e) {
+                handler.logWarning("An error occurs storing the event with id "
+                    + event.getEventId() + ": " + getMessage(e));
+            }
+        }
+    }
+
+    private String getResourceUUID(Context context, String originalId) throws IllegalStateException, SQLException {
+        String id = getHandleFromOriginalId(originalId);
+        if (StringUtils.isNotBlank(id)) {
+            DSpaceObject dso = handleService.resolveToObject(context, id);
+            if (dso != null && dso.getType() == ITEM) {
+                Item item = (Item) dso;
+                final String itemUuid = item.getID().toString();
+                context.uncacheEntity(item);
+                return itemUuid;
+            } else {
+                return null;
+            }
+        } else {
+            throw new IllegalArgumentException("Malformed originalId " + originalId);
+        }
+    }
+
+    // oai:www.openstarts.units.it:10077/21486
+    private String getHandleFromOriginalId(String originalId) {
+        int startPosition = originalId.lastIndexOf(':');
+        if (startPosition != -1) {
+            return originalId.substring(startPosition + 1, originalId.length());
+        } else {
+            return originalId;
+        }
+    }
+
+    /**
+     * Store the given QAEvent, skipping it if it is not supported.
+     *
+     * @param event the event to be stored
+     */
+    private void storeOpenaireQAEvent(QAEvent event) {
+
+        if (!StringUtils.equalsAny(event.getTopic(), topicsToImport)) {
+            handler.logWarning("Event for topic " + event.getTopic() + " is not allowed in the qaevents.cfg");
+            return;
+        }
+
+        event.setSource(QAEvent.OPENAIRE_SOURCE);
+
+        qaEventService.store(context, event);
+
+    }
+
+    /**
+     * Download the events related to the given subscription from the OPENAIRE broker.
+     *
+     * @param subscriptionId the subscription id
+     * @return an input stream from which to read the events in json format
+     */
+    private InputStream getEventsBySubscriptions(String subscriptionId) throws Exception {
+        ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+        brokerClient.downloadEvents(openaireBrokerURL, subscriptionId, outputStream);
+        return new ByteArrayInputStream(outputStream.toByteArray());
+    }
+
+    /**
+     * Takes all the subscription related to the given email from the OPENAIRE
+     * broker.
+     */
+    private List<String> listEmailSubscriptions() {
+        try {
+            return brokerClient.listSubscriptions(openaireBrokerURL, email);
+        } catch (Exception ex) {
+            throw new IllegalArgumentException("An error occurs retriving the subscriptions "
+                + "from the OPENAIRE broker: " + getMessage(ex), ex);
+        }
+    }
+
+    private URL getOpenaireBrokerUri() {
+        try {
+            return new URL(configurationService.getProperty("qaevents.openaire.broker-url", "http://api.openaire.eu/broker"));
+        } catch (MalformedURLException e) {
+            throw new IllegalStateException("The configured OPENAIRE broker URL is not valid.", e);
+        }
+    }
+
+    /**
+     * Get the root exception message from the given exception.
+     */
+    private String getMessage(Exception ex) {
+        String message = ExceptionUtils.getRootCauseMessage(ex);
+        // Remove the Exception name from the message
+        return isNotBlank(message) ? substringAfter(message, ":").trim() : "";
+    }
+
+    private void assignCurrentUserInContext() throws SQLException {
+        UUID uuid = getEpersonIdentifier();
+        if (uuid != null) {
+            EPerson ePerson = EPersonServiceFactory.getInstance().getEPersonService().find(context, uuid);
+            context.setCurrentUser(ePerson);
+        }
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImportCli.java b/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImportCli.java
new file mode 100644
index 0000000000..d98b578cdd
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImportCli.java
@@ -0,0 +1,42 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.script;
+
+import org.apache.commons.cli.HelpFormatter;
+import org.apache.commons.cli.ParseException;
+import org.dspace.utils.DSpace;
+
+/**
+ * Extensions of {@link OpenaireEventsImport} to run the script on console.
+ *
+ * @author Alessandro Martelli (alessandro.martelli at 4science.it)
+ *
+ */
+public class OpenaireEventsImportCli extends OpenaireEventsImport {
+
+    @Override
+    @SuppressWarnings({ "rawtypes" })
+    public OpenaireEventsImportCliScriptConfiguration getScriptConfiguration() {
+        return new DSpace().getServiceManager()
+            .getServiceByName("import-openaire-events", OpenaireEventsImportCliScriptConfiguration.class);
+    }
+
+    @Override
+    public void setup() throws ParseException {
+        super.setup();
+
+        // in case of CLI we show the help prompt
+        if (commandLine.hasOption('h')) {
+            HelpFormatter formatter = new HelpFormatter();
+            formatter.printHelp("Import Notification event json file", getScriptConfiguration().getOptions());
+            System.exit(0);
+        }
+
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImportCliScriptConfiguration.java b/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImportCliScriptConfiguration.java
new file mode 100644
index 0000000000..5be0453a17
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImportCliScriptConfiguration.java
@@ -0,0 +1,31 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.script;
+
+import org.apache.commons.cli.Options;
+
+/**
+ * Extension of {@link OpenaireEventsImportScriptConfiguration} to run the script on
+ * console.
+ *
+ * @author Alessandro Martelli (alessandro.martelli at 4science.it)
+ *
+ */
+public class OpenaireEventsImportCliScriptConfiguration<T extends OpenaireEventsImport>
+    extends OpenaireEventsImportScriptConfiguration<T> {
+
+    @Override
+    public Options getOptions() {
+        Options options = super.getOptions();
+        options.addOption("h", "help", false, "help");
+        options.getOption("h").setType(boolean.class);
+        super.options = options;
+        return options;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImportScriptConfiguration.java b/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImportScriptConfiguration.java
new file mode 100644
index 0000000000..60001e7350
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/script/OpenaireEventsImportScriptConfiguration.java
@@ -0,0 +1,72 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.script;
+
+import java.io.InputStream;
+
+import org.apache.commons.cli.Options;
+import org.dspace.scripts.configuration.ScriptConfiguration;
+
+/**
+ * Extension of {@link ScriptConfiguration} to perfom a QAEvents import from
+ * file.
+ *
+ * @author Alessandro Martelli (alessandro.martelli at 4science.it)
+ *
+ */
+public class OpenaireEventsImportScriptConfiguration<T extends OpenaireEventsImport> extends ScriptConfiguration<T> {
+
+    /*
+    private AuthorizeService authorizeService;
+     */
+    private Class<T> dspaceRunnableClass;
+
+    @Override
+    public Class<T> getDspaceRunnableClass() {
+        return dspaceRunnableClass;
+    }
+
+    /**
+     * Generic setter for the dspaceRunnableClass
+     * @param dspaceRunnableClass   The dspaceRunnableClass to be set on this OpenaireEventsImportScriptConfiguration
+     */
+    @Override
+    public void setDspaceRunnableClass(Class<T> dspaceRunnableClass) {
+        this.dspaceRunnableClass = dspaceRunnableClass;
+    }
+/*
+    @Override
+    public boolean isAllowedToExecute(Context context) {
+        try {
+            return authorizeService.isAdmin(context);
+        } catch (SQLException e) {
+            throw new RuntimeException("SQLException occurred when checking if the current user is an admin", e);
+        }
+    }
+*/
+    @Override
+    public Options getOptions() {
+        if (options == null) {
+            Options options = new Options();
+
+            options.addOption("f", "file", true, "Import data from Openaire quality assurance broker JSON file."
+                + " This parameter is mutually exclusive to the email parameter.");
+            options.getOption("f").setType(InputStream.class);
+            options.getOption("f").setRequired(false);
+
+            options.addOption("e", "email", true, "Email related to the subscriptions to import data from Openaire "
+                + "broker. This parameter is mutually exclusive to the file parameter.");
+            options.getOption("e").setType(String.class);
+            options.getOption("e").setRequired(false);
+
+            super.options = options;
+        }
+        return options;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/security/AdministratorsOnlyQASecurity.java b/dspace-api/src/main/java/org/dspace/qaevent/security/AdministratorsOnlyQASecurity.java
new file mode 100644
index 0000000000..38cf40ce39
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/security/AdministratorsOnlyQASecurity.java
@@ -0,0 +1,51 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.security;
+
+import java.sql.SQLException;
+import java.util.Optional;
+
+import org.dspace.authorize.service.AuthorizeService;
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * QASecurity that restrict access to the QA Source and related events only to repository administrators
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science.com)
+ */
+public class AdministratorsOnlyQASecurity implements QASecurity {
+
+    @Autowired
+    private AuthorizeService authorizeService;
+
+    public Optional<String> generateFilterQuery(Context context, EPerson currentUser) {
+        return Optional.empty();
+    }
+
+    @Override
+    public boolean canSeeQASource(Context context, EPerson user) {
+        try {
+            return authorizeService.isAdmin(context, user);
+        } catch (SQLException e) {
+            return false;
+        }
+    }
+
+    @Override
+    public boolean canSeeQAEvent(Context context, EPerson user, QAEvent qaEvent) {
+        try {
+            return authorizeService.isAdmin(context, user);
+        } catch (SQLException e) {
+            return false;
+        }
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/security/QASecurity.java b/dspace-api/src/main/java/org/dspace/qaevent/security/QASecurity.java
new file mode 100644
index 0000000000..44b00e7d94
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/security/QASecurity.java
@@ -0,0 +1,55 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.security;
+
+import java.util.Optional;
+
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+
+/**
+ * The QASecurity interface defines methods for implementing security strategies
+ * related to Quality Assurance (QA) events. Classes implementing this interface should
+ * provide logic to filter and determine visibility of QA events based on the user's permissions.
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science.com)
+ *
+ */
+public interface QASecurity {
+
+    /**
+     * Return a SOLR queries that can be applied querying the qaevent SOLR core to retrieve only the qaevents visible to
+     * the provided user
+     * 
+     * @param context the DSpace context
+     * @param user    the user to consider to restrict the visible qaevents
+     * @return        the SOLR filter query to apply
+     */
+    public Optional<String> generateFilterQuery(Context context, EPerson user);
+
+    /**
+     * Return <code>true</code> it the user is potentially allowed to see events in the qasource that adopt this
+     * security strategy
+     *
+     * @param context the DSpace context
+     * @param user the user to consider to restrict the visible qaevents
+     * @return <code>true</code> if the user can eventually see some qaevents
+     */
+    public boolean canSeeQASource(Context context, EPerson user);
+
+    /**
+     * Return <code>true</code> it the user is potentially allowed to see events in the qasource that adopt this
+     * security strategy
+     *
+     * @param context the DSpace context
+     * @param user    the user to consider to restrict the visible qaevents
+     * @return        <code>true</code> if the user can see the provided qaEvent
+     */
+    public boolean canSeeQAEvent(Context context, EPerson user, QAEvent qaEvent);
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/security/UserBasedFilterQASecurity.java b/dspace-api/src/main/java/org/dspace/qaevent/security/UserBasedFilterQASecurity.java
new file mode 100644
index 0000000000..3d66d221e6
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/security/UserBasedFilterQASecurity.java
@@ -0,0 +1,70 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.security;
+
+import java.sql.SQLException;
+import java.text.MessageFormat;
+import java.util.Optional;
+
+import org.dspace.authorize.service.AuthorizeService;
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+import org.dspace.qaevent.service.QAEventService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * QASecurity implementations that allow access to only qa events that match a SORL query generated using the eperson
+ * uuid
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science.com)
+ */
+public class UserBasedFilterQASecurity implements QASecurity {
+
+    private String filterTemplate;
+    private boolean allowAdmins = true;
+
+    @Autowired
+    private QAEventService qaEventService;
+    @Autowired
+    private AuthorizeService authorizeService;
+
+    public Optional<String> generateFilterQuery(Context context, EPerson user) {
+        try {
+            if (allowAdmins && authorizeService.isAdmin(context, user)) {
+                return Optional.empty();
+            } else {
+                return Optional.of(MessageFormat.format(filterTemplate, user.getID().toString()));
+            }
+        } catch (SQLException e) {
+            throw new RuntimeException("Error checking permissions", e);
+        }
+    }
+
+    public boolean canSeeQASource(Context context, EPerson user) {
+        return user != null;
+    }
+
+    public boolean canSeeQAEvent(Context context, EPerson user, QAEvent qaEvent) {
+        try {
+            return (allowAdmins && authorizeService.isAdmin(context, user))
+                    || qaEventService.qaEventsInSource(context, user, qaEvent.getEventId(), qaEvent.getSource());
+        } catch (SQLException e) {
+            throw new RuntimeException("Error checking permissions", e);
+        }
+    }
+
+    public void setFilterTemplate(String filterTemplate) {
+        this.filterTemplate = filterTemplate;
+    }
+
+    public void setAllowAdmins(boolean allowAdmins) {
+        this.allowAdmins = allowAdmins;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/OpenaireClientFactory.java b/dspace-api/src/main/java/org/dspace/qaevent/service/OpenaireClientFactory.java
new file mode 100644
index 0000000000..e7a7be33c1
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/OpenaireClientFactory.java
@@ -0,0 +1,31 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service;
+
+import eu.dnetlib.broker.BrokerClient;
+import org.dspace.utils.DSpace;
+
+/**
+ * Factory for the {@link BrokerClient}.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+public interface OpenaireClientFactory {
+
+    /**
+     * Returns an instance of the {@link BrokerClient}.
+     *
+     * @return the client instance
+     */
+    public BrokerClient getBrokerClient();
+
+    public static OpenaireClientFactory getInstance() {
+        return new DSpace().getServiceManager().getServiceByName("openaireClientFactory", OpenaireClientFactory.class);
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/QAEventActionService.java b/dspace-api/src/main/java/org/dspace/qaevent/service/QAEventActionService.java
new file mode 100644
index 0000000000..2e5690f622
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/QAEventActionService.java
@@ -0,0 +1,45 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service;
+
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+
+/**
+ * Service that handle the actions that can be done related to an
+ * {@link QAEvent}.
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public interface QAEventActionService {
+
+    /**
+     * Accept the given event.
+     *
+     * @param context the DSpace context
+     * @param qaevent the event to be accepted
+     */
+    public void accept(Context context, QAEvent qaevent);
+
+    /**
+     * Discard the given event.
+     *
+     * @param context the DSpace context
+     * @param qaevent the event to be discarded
+     */
+    public void discard(Context context, QAEvent qaevent);
+
+    /**
+     * Reject the given event.
+     *
+     * @param context the DSpace context
+     * @param qaevent the event to be rejected
+     */
+    public void reject(Context context, QAEvent qaevent);
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/QAEventSecurityService.java b/dspace-api/src/main/java/org/dspace/qaevent/service/QAEventSecurityService.java
new file mode 100644
index 0000000000..7f6ef7a12c
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/QAEventSecurityService.java
@@ -0,0 +1,55 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service;
+
+import java.util.Optional;
+
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+
+/**
+ * Interface to limit the visibility of {@link QAEvent} to specific users.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.com)
+ *
+ */
+public interface QAEventSecurityService {
+
+    /**
+     * Check if the specified user can see a specific QASource
+     * @param context     the context
+     * @param user        the eperson to consider
+     * @param sourceName  the source name
+     * @return          <code>true</code> if the specified user can eventually see events in the QASource
+     */
+    boolean canSeeSource(Context context, EPerson user, String sourceName);
+
+    /**
+     * Check if the specified user can see a specific QAEvent. It is expected that a QAEvent in a not visible QASource
+     * cannot be accessed. So implementation of this method should enforce this rule.
+     * 
+     * @param context   the context
+     * @param user      the eperson to consider
+     * @param qaEvent   the qaevent to check
+     * @return <code>true</code> if the specified user can see the specified event
+     */
+    boolean canSeeEvent(Context context, EPerson user, QAEvent qaEvent);
+
+    /**
+     * Generate a query to restrict the qa events returned by other search/find method to the only ones visible to the
+     * specified user
+     * 
+     * @param context     the context
+     * @param user        the eperson to consider
+     * @param sourceName  the source name
+     * @return the solr filter query
+     */
+    public Optional<String> generateQAEventFilterQuery(Context context, EPerson user, String sourceName);
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/QAEventService.java b/dspace-api/src/main/java/org/dspace/qaevent/service/QAEventService.java
new file mode 100644
index 0000000000..3254aecf77
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/QAEventService.java
@@ -0,0 +1,267 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service;
+
+import java.util.List;
+import java.util.UUID;
+
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+import org.dspace.qaevent.QASource;
+import org.dspace.qaevent.QATopic;
+
+/**
+ * Service that handles {@link QAEvent}.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public interface QAEventService {
+
+    /**
+     * Find all the event's topics.
+     *
+     * @param  context     the DSpace context
+     * @param  offset      the offset to apply
+     * @param  orderField  the field to order for
+     * @param  ascending   true if the order should be ascending, false otherwise
+     * @return             the topics list
+     */
+    public List<QATopic> findAllTopics(Context context, long offset, long count, String orderField, boolean ascending);
+
+    /**
+     * Find all the event's topics related to the given source.
+     *
+     * @param  context     the DSpace context
+     * @param  source      the source to search for
+     * @param  offset      the offset to apply
+     * @param  count       the page size
+     * @param  orderField  the field to order for
+     * @param  ascending   true if the order should be ascending, false otherwise
+     * @return             the topics list
+     */
+    public List<QATopic> findAllTopicsBySource(Context context, String source, long offset, long count,
+        String orderField, boolean ascending);
+
+    /**
+     * Find a specific topic by its name, source and optionally a target.
+     *
+     * @param  context the DSpace context
+     * @param  sourceName the name of the source
+     * @param  topicName  the topic name to search for
+     * @param  target     (nullable) the uuid of the target to focus on
+     * @return            the topic
+     */
+    public QATopic findTopicBySourceAndNameAndTarget(Context context, String sourceName, String topicName, UUID target);
+
+    /**
+     * Count all the event's topics.
+     *
+     * @return the count result
+     */
+    public long countTopics();
+
+    /**
+     * Count all the event's topics related to the given source.
+     *
+     * @param  context the DSpace context
+     * @param  source  the source to search for
+     * @return         the count result
+     */
+    public long countTopicsBySource(Context context, String source);
+
+    /**
+     * Find all the events by topic.
+     *
+     * @param  context    the DSpace context
+     * @param  sourceName the source name
+     * @param  topic      the topic to search for
+     * @param  offset     the offset to apply
+     * @param  size       the page size
+     * @param  orderField  the field to order for
+     * @param  ascending   true if the order should be ascending, false otherwise
+     * @return            the events
+     */
+    public List<QAEvent> findEventsByTopic(Context context, String sourceName, String topic, long offset, int size,
+                                           String orderField, boolean ascending);
+
+    /**
+     * Find all the events by topic.
+     *
+     * @param  context     the DSpace context
+     * @param  sourceName  the source name
+     * @param  topic       the topic to search for
+     * @return             the events count
+     */
+    public long countEventsByTopic(Context context, String sourceName, String topic);
+
+    /**
+     * Find an event by the given id. Please note that no security filter are applied by this method.
+     *
+     * @param  id      the id of the event to search for
+     * @return         the event
+     */
+    public QAEvent findEventByEventId(String id);
+
+    /**
+     * Store the given event.
+     *
+     * @param context the DSpace context
+     * @param event   the event to store
+     */
+    public void store(Context context, QAEvent event);
+
+    /**
+     * Delete an event by the given id.
+     *
+     * @param id      the id of the event to delete
+     */
+    public void deleteEventByEventId(String id);
+
+    /**
+     * Delete events by the given target id.
+     *
+     * @param targetId the id of the target id
+     */
+    public void deleteEventsByTargetId(UUID targetId);
+
+    /**
+     * Find a specific topid by the given id.
+     *
+     * @param  topicId the topic id to search for
+     * @return         the topic
+     */
+    public QATopic findTopicByTopicId(String topicId);
+
+    /**
+     * Find a specific source by the given name.
+     *
+     * @param  context the DSpace context
+     * @param  source  the source name
+     * @return         the source
+     */
+    public QASource findSource(Context context, String source);
+
+    /**
+     * Find a specific source by the given name including the stats focused on the target item.
+     *
+     * @param  context the DSpace context
+     * @param  source  the source name
+     * @param  target  the uuid of the item target
+     * @return         the source
+     */
+    public QASource findSource(Context context, String source, UUID target);
+
+    /**
+     * Find all the event's sources.
+     *
+     * @param  context  the DSpace context
+     * @param  offset   the offset to apply
+     * @param  pageSize the page size
+     * @return          the sources list
+     */
+    public List<QASource> findAllSources(Context context, long offset, int pageSize);
+
+    /**
+     * Count all the event's sources.
+     *
+     * @param  context the DSpace context
+     * @return         the count result
+     */
+    public long countSources(Context context);
+
+    /**
+     * Count all the event's sources related to a specific item
+     *
+     * @param  context the DSpace context
+     * @param  target  the item uuid
+     * @return         the count result
+     */
+    public long countSourcesByTarget(Context context, UUID target);
+
+    /**
+     * Count all the event's topics related to the given source referring to a specific item
+     *
+     * @param  context the DSpace context
+     * @param  target  the item uuid
+     * @param  source  the source to search for
+     * @return         the count result
+     */
+    public long countTopicsBySourceAndTarget(Context context, String source, UUID target);
+
+    /**
+     * Check if the given QA event supports a related item.
+     * 
+     * @param  qaevent the event to be verified
+     * @return         true if the event supports a related item, false otherwise.
+     */
+    public boolean isRelatedItemSupported(QAEvent qaevent);
+
+    /**
+     * Find a list of QA events according to the pagination parameters for the specified topic and target sorted by
+     * trust descending
+     *
+     * @param  context  the DSpace context
+     * @param  source   the source name
+     * @param  topic    the topic to search for
+     * @param  offset   the offset to apply
+     * @param  pageSize the page size
+     * @param  target   the uuid of the QA event's target
+     * @return          the events
+     */
+    public List<QAEvent> findEventsByTopicAndTarget(Context context, String source, String topic, UUID target,
+                                                    long offset, int pageSize);
+
+    /**
+     * Check if a qaevent with the provided id is visible to the current user according to the source security
+     *
+     * @param  context the DSpace context
+     * @param  user    the user to consider for the security check
+     * @param  eventId the id of the event to check for existence
+     * @param  source  the qa source name
+     * @return <code>true</code> if the event exists
+     */
+    public boolean qaEventsInSource(Context context, EPerson user, String eventId, String source);
+
+    /**
+     * Count the QA events related to the specified topic and target
+     *
+     * @param  context  the DSpace context
+     * @param  source   the source name
+     * @param  topic    the topic to search for
+     * @param  target   the uuid of the QA event's target
+     * @return          the count result
+     */
+    public long countEventsByTopicAndTarget(Context context, String source, String topic, UUID target);
+
+    /**
+     * Find all the event's sources related to a specific item
+     *
+     * @param  context   the DSpace context
+     * @param  target    the item referring to
+     * @param  offset    the offset to apply
+     * @param  pageSize  the page size
+     * @return           the source list
+     */
+    public List<QASource> findAllSourcesByTarget(Context context, UUID target, long offset, int pageSize);
+
+    /**
+     * Find all the event's topics related to the given source for a specific item
+     *
+     * @param  context   the DSpace context
+     * @param  source    (not null) the source to search for
+     * @param  target    the item referring to
+     * @param  offset    the offset to apply
+     * @param  pageSize  the page size
+     * @return           the topics list
+     */
+    public List<QATopic> findAllTopicsBySourceAndTarget(Context context, String source, UUID target, long offset,
+            long pageSize, String orderField, boolean ascending);
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/dto/CorrectionTypeMessageDTO.java b/dspace-api/src/main/java/org/dspace/qaevent/service/dto/CorrectionTypeMessageDTO.java
new file mode 100644
index 0000000000..e5e38c2396
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/dto/CorrectionTypeMessageDTO.java
@@ -0,0 +1,39 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service.dto;
+
+import java.io.Serializable;
+
+/**
+ * The CorrectionTypeMessageDTO class implements the QAMessageDTO interface
+ * and represents a Data Transfer Object (DTO) for holding information
+ * related to a correction type message in the context of Quality Assurance (QA).
+ *
+ * @author Mykhaylo Boychuk (mykhaylo.boychuk at 4science.it)
+ */
+public class CorrectionTypeMessageDTO implements QAMessageDTO, Serializable {
+
+    private static final long serialVersionUID = 2718151302291303796L;
+
+    private String reason;
+
+    public CorrectionTypeMessageDTO() {}
+
+    public CorrectionTypeMessageDTO(String reason) {
+        this.reason = reason;
+    }
+
+    public String getReason() {
+        return reason;
+    }
+
+    public void setReason(String reason) {
+        this.reason = reason;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/dto/NotifyMessageDTO.java b/dspace-api/src/main/java/org/dspace/qaevent/service/dto/NotifyMessageDTO.java
new file mode 100644
index 0000000000..2a5842589f
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/dto/NotifyMessageDTO.java
@@ -0,0 +1,58 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service.dto;
+
+/**
+ * Implementation of {@link QAMessageDTO} that model message coming from COAR NOTIFY.
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ *
+ */
+public class NotifyMessageDTO implements QAMessageDTO {
+
+    private String serviceName;
+
+    private String serviceId;
+
+    private String href;
+
+    private String relationship;
+
+    public String getServiceName() {
+        return serviceName;
+    }
+
+    public void setServiceName(String serviceName) {
+        this.serviceName = serviceName;
+    }
+
+    public String getServiceId() {
+        return serviceId;
+    }
+
+    public void setServiceId(String serviceId) {
+        this.serviceId = serviceId;
+    }
+
+    public String getHref() {
+        return href;
+    }
+
+    public void setHref(String href) {
+        this.href = href;
+    }
+
+    public String getRelationship() {
+        return relationship;
+    }
+
+    public void setRelationship(String relationship) {
+        this.relationship = relationship;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/dto/OpenaireMessageDTO.java b/dspace-api/src/main/java/org/dspace/qaevent/service/dto/OpenaireMessageDTO.java
new file mode 100644
index 0000000000..821f11f869
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/dto/OpenaireMessageDTO.java
@@ -0,0 +1,175 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service.dto;
+
+import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+/**
+ * Implementation of {@link QAMessageDTO} that model message coming from OPENAIRE.
+ * @see <a href="https://graph.openaire.eu/docs/category/entities" target="_blank"> see </a>
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+@JsonIgnoreProperties(ignoreUnknown = true)
+public class OpenaireMessageDTO implements QAMessageDTO {
+
+    @JsonProperty("pids[0].value")
+    private String value;
+
+    @JsonProperty("pids[0].type")
+    private String type;
+
+    @JsonProperty("instances[0].hostedby")
+    private String instanceHostedBy;
+
+    @JsonProperty("instances[0].instancetype")
+    private String instanceInstanceType;
+
+    @JsonProperty("instances[0].license")
+    private String instanceLicense;
+
+    @JsonProperty("instances[0].url")
+    private String instanceUrl;
+
+    @JsonProperty("abstracts[0]")
+    private String abstracts;
+
+    @JsonProperty("projects[0].acronym")
+    private String acronym;
+
+    @JsonProperty("projects[0].code")
+    private String code;
+
+    @JsonProperty("projects[0].funder")
+    private String funder;
+
+    @JsonProperty("projects[0].fundingProgram")
+    private String fundingProgram;
+
+    @JsonProperty("projects[0].jurisdiction")
+    private String jurisdiction;
+
+    @JsonProperty("projects[0].openaireId")
+    private String openaireId;
+
+    @JsonProperty("projects[0].title")
+    private String title;
+
+    public String getValue() {
+        return value;
+    }
+
+    public void setValue(String value) {
+        this.value = value;
+    }
+
+    public String getType() {
+        return type;
+    }
+
+    public void setType(String type) {
+        this.type = type;
+    }
+
+    public String getInstanceHostedBy() {
+        return instanceHostedBy;
+    }
+
+    public void setInstanceHostedBy(String instanceHostedBy) {
+        this.instanceHostedBy = instanceHostedBy;
+    }
+
+    public String getInstanceInstanceType() {
+        return instanceInstanceType;
+    }
+
+    public void setInstanceInstanceType(String instanceInstanceType) {
+        this.instanceInstanceType = instanceInstanceType;
+    }
+
+    public String getInstanceLicense() {
+        return instanceLicense;
+    }
+
+    public void setInstanceLicense(String instanceLicense) {
+        this.instanceLicense = instanceLicense;
+    }
+
+    public String getInstanceUrl() {
+        return instanceUrl;
+    }
+
+    public void setInstanceUrl(String instanceUrl) {
+        this.instanceUrl = instanceUrl;
+    }
+
+    public String getAbstracts() {
+        return abstracts;
+    }
+
+    public void setAbstracts(String abstracts) {
+        this.abstracts = abstracts;
+    }
+
+    public String getAcronym() {
+        return acronym;
+    }
+
+    public void setAcronym(String acronym) {
+        this.acronym = acronym;
+    }
+
+    public String getCode() {
+        return code;
+    }
+
+    public void setCode(String code) {
+        this.code = code;
+    }
+
+    public String getFunder() {
+        return funder;
+    }
+
+    public void setFunder(String funder) {
+        this.funder = funder;
+    }
+
+    public String getFundingProgram() {
+        return fundingProgram;
+    }
+
+    public void setFundingProgram(String fundingProgram) {
+        this.fundingProgram = fundingProgram;
+    }
+
+    public String getJurisdiction() {
+        return jurisdiction;
+    }
+
+    public void setJurisdiction(String jurisdiction) {
+        this.jurisdiction = jurisdiction;
+    }
+
+    public String getOpenaireId() {
+        return openaireId;
+    }
+
+    public void setOpenaireId(String openaireId) {
+        this.openaireId = openaireId;
+    }
+
+    public String getTitle() {
+        return title;
+    }
+
+    public void setTitle(String title) {
+        this.title = title;
+    }
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/dto/QAMessageDTO.java b/dspace-api/src/main/java/org/dspace/qaevent/service/dto/QAMessageDTO.java
new file mode 100644
index 0000000000..ede32ef497
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/dto/QAMessageDTO.java
@@ -0,0 +1,20 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service.dto;
+
+import org.dspace.content.QAEvent;
+
+/**
+ * Interface for classes that contains the details related to a {@link QAEvent}.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+public interface QAMessageDTO {
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/impl/OpenaireClientFactoryImpl.java b/dspace-api/src/main/java/org/dspace/qaevent/service/impl/OpenaireClientFactoryImpl.java
new file mode 100644
index 0000000000..5839f5e877
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/impl/OpenaireClientFactoryImpl.java
@@ -0,0 +1,35 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service.impl;
+
+import eu.dnetlib.broker.BrokerClient;
+import org.dspace.qaevent.service.OpenaireClientFactory;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implementation of {@link OpenaireClientFactory} that returns the instance of
+ * {@link BrokerClient} managed by the Spring context.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+public class OpenaireClientFactoryImpl implements OpenaireClientFactory {
+
+    @Autowired
+    private BrokerClient brokerClient;
+
+    @Override
+    public BrokerClient getBrokerClient() {
+        return brokerClient;
+    }
+
+    public void setBrokerClient(BrokerClient brokerClient) {
+        this.brokerClient = brokerClient;
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/impl/QAEventActionServiceImpl.java b/dspace-api/src/main/java/org/dspace/qaevent/service/impl/QAEventActionServiceImpl.java
new file mode 100644
index 0000000000..30875a5105
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/impl/QAEventActionServiceImpl.java
@@ -0,0 +1,138 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service.impl;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.Map;
+import java.util.UUID;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.DeserializationFeature;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.json.JsonMapper;
+import com.fasterxml.jackson.databind.node.ObjectNode;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.entity.ContentType;
+import org.apache.http.entity.StringEntity;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.impl.client.HttpClients;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.qaevent.QualityAssuranceAction;
+import org.dspace.qaevent.service.QAEventActionService;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Implementation of {@link QAEventActionService}.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class QAEventActionServiceImpl implements QAEventActionService {
+
+    private static final Logger log = LogManager.getLogger(QAEventActionServiceImpl.class);
+
+    private ObjectMapper jsonMapper;
+
+    @Autowired
+    private QAEventService qaEventService;
+
+    @Autowired
+    private ItemService itemService;
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    private Map<String, QualityAssuranceAction> topicsToActions;
+
+    public void setTopicsToActions(Map<String, QualityAssuranceAction> topicsToActions) {
+        this.topicsToActions = topicsToActions;
+    }
+
+    public Map<String, QualityAssuranceAction> getTopicsToActions() {
+        return topicsToActions;
+    }
+
+    public QAEventActionServiceImpl() {
+        jsonMapper = new JsonMapper();
+        jsonMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
+    }
+
+    @Override
+    public void accept(Context context, QAEvent qaevent) {
+        Item item = null;
+        Item related = null;
+        try {
+            item = itemService.find(context, UUID.fromString(qaevent.getTarget()));
+            if (qaevent.getRelated() != null) {
+                related = itemService.find(context, UUID.fromString(qaevent.getRelated()));
+            }
+            if (topicsToActions.get(qaevent.getTopic()) == null) {
+                String msg = "Unable to manage QA Event typed " + qaevent.getTopic()
+                    + ". Managed types are: " + topicsToActions;
+                log.error(msg);
+                throw new RuntimeException(msg);
+            }
+            context.turnOffAuthorisationSystem();
+            topicsToActions.get(qaevent.getTopic()).applyCorrection(context, item, related,
+                jsonMapper.readValue(qaevent.getMessage(), qaevent.getMessageDtoClass()));
+            qaEventService.deleteEventByEventId(qaevent.getEventId());
+            makeAcknowledgement(qaevent.getEventId(), qaevent.getSource(), QAEvent.ACCEPTED);
+        } catch (SQLException | JsonProcessingException e) {
+            throw new RuntimeException(e);
+        } finally {
+            context.restoreAuthSystemState();
+        }
+    }
+
+    @Override
+    public void discard(Context context, QAEvent qaevent) {
+        qaEventService.deleteEventByEventId(qaevent.getEventId());
+        makeAcknowledgement(qaevent.getEventId(), qaevent.getSource(), QAEvent.DISCARDED);
+    }
+
+    @Override
+    public void reject(Context context, QAEvent qaevent) {
+        qaEventService.deleteEventByEventId(qaevent.getEventId());
+        makeAcknowledgement(qaevent.getEventId(), qaevent.getSource(), QAEvent.REJECTED);
+    }
+
+    /**
+     * Make acknowledgement to the configured urls for the event status.
+     */
+    private void makeAcknowledgement(String eventId, String source, String status) {
+        String[] ackwnoledgeCallbacks = configurationService
+            .getArrayProperty("qaevents." + source + ".acknowledge-url");
+        if (ackwnoledgeCallbacks != null) {
+            for (String ackwnoledgeCallback : ackwnoledgeCallbacks) {
+                if (StringUtils.isNotBlank(ackwnoledgeCallback)) {
+                    ObjectNode node = jsonMapper.createObjectNode();
+                    node.put("eventId", eventId);
+                    node.put("status", status);
+                    StringEntity requestEntity = new StringEntity(node.toString(), ContentType.APPLICATION_JSON);
+                    CloseableHttpClient httpclient = HttpClients.createDefault();
+                    HttpPost postMethod = new HttpPost(ackwnoledgeCallback);
+                    postMethod.setEntity(requestEntity);
+                    try {
+                        httpclient.execute(postMethod);
+                    } catch (IOException e) {
+                        log.error(e.getMessage(), e);
+                    }
+                }
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/impl/QAEventSecurityServiceImpl.java b/dspace-api/src/main/java/org/dspace/qaevent/service/impl/QAEventSecurityServiceImpl.java
new file mode 100644
index 0000000000..854626b3ba
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/impl/QAEventSecurityServiceImpl.java
@@ -0,0 +1,72 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service.impl;
+
+import java.util.Map;
+import java.util.Optional;
+
+import org.apache.logging.log4j.Logger;
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+import org.dspace.qaevent.security.QASecurity;
+import org.dspace.qaevent.service.QAEventSecurityService;
+
+/**
+ * Implementation of the security service for QAEvents.
+ * This implementation manages a configuration of {@link QASecurity} instances,
+ * each responsible for security checks for a specific QA source.
+ *
+ * @author Mykhaylo Boychuk (mykhaylo.boychuk@4science.com)
+ */
+public class QAEventSecurityServiceImpl implements QAEventSecurityService {
+
+    /**
+     * The default security settings to be used when specific configurations are not available for a QA source.
+     */
+    private QASecurity defaultSecurity;
+
+    /**
+     * A mapping of QA source names to their corresponding QASecurity configurations.
+     */
+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(QAEventSecurityServiceImpl.class);
+
+    private Map<String, QASecurity> qaSecurityConfiguration;
+
+    public void setQaSecurityConfiguration(Map<String, QASecurity> qaSecurityConfiguration) {
+        this.qaSecurityConfiguration = qaSecurityConfiguration;
+    }
+
+    public void setDefaultSecurity(QASecurity defaultSecurity) {
+        this.defaultSecurity = defaultSecurity;
+    }
+
+    @Override
+    public Optional<String> generateQAEventFilterQuery(Context context, EPerson user, String qaSource) {
+        QASecurity qaSecurity = getQASecurity(qaSource);
+        return qaSecurity.generateFilterQuery(context, user);
+    }
+
+    private QASecurity getQASecurity(String qaSource) {
+        return qaSecurityConfiguration.getOrDefault(qaSource, defaultSecurity);
+    }
+
+    @Override
+    public boolean canSeeEvent(Context context, EPerson user, QAEvent qaEvent) {
+        String source = qaEvent.getSource();
+        QASecurity qaSecurity = getQASecurity(source);
+        return qaSecurity.canSeeQASource(context, user) && qaSecurity.canSeeQAEvent(context, user, qaEvent);
+    }
+
+    @Override
+    public boolean canSeeSource(Context context, EPerson user, String qaSource) {
+        QASecurity qaSecurity = getQASecurity(qaSource);
+        return qaSecurity.canSeeQASource(context, user);
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/java/org/dspace/qaevent/service/impl/QAEventServiceImpl.java b/dspace-api/src/main/java/org/dspace/qaevent/service/impl/QAEventServiceImpl.java
new file mode 100644
index 0000000000..98077a1c0c
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/qaevent/service/impl/QAEventServiceImpl.java
@@ -0,0 +1,773 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.service.impl;
+
+import static java.util.Comparator.comparing;
+import static org.apache.commons.lang3.StringUtils.endsWith;
+import static org.dspace.content.QAEvent.OPENAIRE_SOURCE;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+import java.util.Objects;
+import java.util.Optional;
+import java.util.UUID;
+import java.util.stream.Collectors;
+
+import com.fasterxml.jackson.databind.DeserializationFeature;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.json.JsonMapper;
+import org.apache.commons.lang3.ArrayUtils;
+import org.apache.commons.lang3.StringUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.apache.solr.client.solrj.SolrClient;
+import org.apache.solr.client.solrj.SolrQuery;
+import org.apache.solr.client.solrj.SolrQuery.ORDER;
+import org.apache.solr.client.solrj.SolrServerException;
+import org.apache.solr.client.solrj.impl.HttpSolrClient;
+import org.apache.solr.client.solrj.request.UpdateRequest;
+import org.apache.solr.client.solrj.response.FacetField;
+import org.apache.solr.client.solrj.response.FacetField.Count;
+import org.apache.solr.client.solrj.response.QueryResponse;
+import org.apache.solr.common.SolrDocument;
+import org.apache.solr.common.SolrDocumentList;
+import org.apache.solr.common.SolrInputDocument;
+import org.apache.solr.common.params.FacetParams;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.core.Email;
+import org.dspace.core.I18nUtil;
+import org.dspace.eperson.EPerson;
+import org.dspace.handle.service.HandleService;
+import org.dspace.qaevent.AutomaticProcessingAction;
+import org.dspace.qaevent.QAEventAutomaticProcessingEvaluation;
+import org.dspace.qaevent.QASource;
+import org.dspace.qaevent.QATopic;
+import org.dspace.qaevent.dao.QAEventsDAO;
+import org.dspace.qaevent.dao.impl.QAEventsDAOImpl;
+import org.dspace.qaevent.service.QAEventActionService;
+import org.dspace.qaevent.service.QAEventSecurityService;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.services.ConfigurationService;
+import org.dspace.services.factory.DSpaceServicesFactory;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.beans.factory.annotation.Qualifier;
+
+
+/**
+ * Implementation of {@link QAEventService} that use Solr to store events. When
+ * the user performs an action on the event (such as accepting the suggestion or
+ * rejecting it) then the event is removed from solr and saved in the database
+ * (see {@link QAEventsDAO}) so that it is no longer proposed.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class QAEventServiceImpl implements QAEventService {
+
+    private static final Logger log = LogManager.getLogger();
+
+    public static final String QAEVENTS_SOURCES = "qaevents.sources";
+
+    @Autowired(required = true)
+    protected ConfigurationService configurationService;
+
+    @Autowired(required = true)
+    protected QAEventSecurityService qaSecurityService;
+
+    @Autowired(required = true)
+    protected ItemService itemService;
+
+    @Autowired
+    private HandleService handleService;
+
+    @Autowired
+    private QAEventsDAOImpl qaEventsDao;
+
+    @Autowired(required = false)
+    @Qualifier("qaAutomaticProcessingMap")
+    private Map<String, QAEventAutomaticProcessingEvaluation> qaAutomaticProcessingMap;
+
+    @Autowired
+    private QAEventActionService qaEventActionService;
+
+    private ObjectMapper jsonMapper;
+
+    public QAEventServiceImpl() {
+        jsonMapper = new JsonMapper();
+        jsonMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
+    }
+
+    /**
+     * Non-Static CommonsHttpSolrServer for processing indexing events.
+     */
+    protected SolrClient solr = null;
+
+    public static final String SOURCE = "source";
+    public static final String ORIGINAL_ID = "original_id";
+    public static final String TITLE = "title";
+    public static final String TOPIC = "topic";
+    public static final String TRUST = "trust";
+    public static final String MESSAGE = "message";
+    public static final String EVENT_ID = "event_id";
+    public static final String RESOURCE_UUID = "resource_uuid";
+    public static final String LAST_UPDATE = "last_update";
+    public static final String RELATED_UUID = "related_uuid";
+
+    protected SolrClient getSolr() {
+        if (solr == null) {
+            String solrService = DSpaceServicesFactory.getInstance().getConfigurationService()
+                    .getProperty("qaevents.solr.server", "http://localhost:8983/solr/qaevent");
+            return new HttpSolrClient.Builder(solrService).build();
+        }
+        return solr;
+    }
+
+    @Override
+    public long countTopics() {
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        solrQuery.setQuery("*:*");
+        solrQuery.setFacet(true);
+        solrQuery.setFacetMinCount(1);
+        solrQuery.addFacetField(TOPIC);
+        QueryResponse response;
+        try {
+            response = getSolr().query(solrQuery);
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+        return response.getFacetField(TOPIC).getValueCount();
+    }
+
+    @Override
+    public long countTopicsBySource(Context context, String sourceName) {
+        var currentUser = context.getCurrentUser();
+        if (isNotSupportedSource(sourceName) || !qaSecurityService.canSeeSource(context, currentUser, sourceName)) {
+            return 0;
+        }
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        Optional<String> securityQuery = qaSecurityService.generateQAEventFilterQuery(context, currentUser, sourceName);
+        solrQuery.setQuery(securityQuery.orElse("*:*"));
+        solrQuery.setFacet(true);
+        solrQuery.setFacetMinCount(1);
+        solrQuery.addFacetField(TOPIC);
+        solrQuery.addFilterQuery(SOURCE + ":\"" + sourceName + "\"");
+        QueryResponse response;
+        try {
+            response = getSolr().query(solrQuery);
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+        return response.getFacetField(TOPIC).getValueCount();
+    }
+
+    @Override
+    public QATopic findTopicBySourceAndNameAndTarget(Context context, String sourceName, String topicName,
+                                                     UUID target) {
+        if (isNotSupportedSource(sourceName)
+                || !qaSecurityService.canSeeSource(context, context.getCurrentUser(), sourceName)) {
+            return null;
+        }
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        Optional<String> securityQuery = qaSecurityService.generateQAEventFilterQuery(context,
+                context.getCurrentUser(), sourceName);
+        solrQuery.setQuery(securityQuery.orElse("*:*"));
+
+        solrQuery.addFilterQuery(SOURCE + ":\"" + sourceName + "\"");
+        solrQuery.addFilterQuery(TOPIC + ":\"" + topicName + "\"");
+        if (target != null) {
+            solrQuery.addFilterQuery(RESOURCE_UUID + ":\"" + target.toString() + "\"");
+        }
+        solrQuery.setFacet(true);
+        solrQuery.setFacetMinCount(1);
+        solrQuery.addFacetField(TOPIC);
+        QueryResponse response;
+        try {
+            response = getSolr().query(solrQuery);
+            FacetField facetField = response.getFacetField(TOPIC);
+            for (Count c : facetField.getValues()) {
+                if (c.getName().equals(topicName)) {
+                    QATopic topic = new QATopic();
+                    topic.setSource(sourceName);
+                    topic.setKey(c.getName());
+                    topic.setTotalEvents(c.getCount());
+                    topic.setLastEvent(new Date());
+                    return topic;
+                }
+            }
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+        return null;
+    }
+
+    @Override
+    public void deleteEventByEventId(String id) {
+        try {
+            getSolr().deleteById(id);
+            getSolr().commit();
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void deleteEventsByTargetId(UUID targetId) {
+        try {
+            getSolr().deleteByQuery(RESOURCE_UUID + ":" + targetId.toString());
+            getSolr().commit();
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public QATopic findTopicByTopicId(String topicId) {
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        solrQuery.setQuery(TOPIC + ":" + topicId.replaceAll("!", "/"));
+        solrQuery.setFacet(true);
+        solrQuery.setFacetMinCount(1);
+        solrQuery.addFacetField(TOPIC);
+        QueryResponse response;
+        try {
+            response = getSolr().query(solrQuery);
+            FacetField facetField = response.getFacetField(TOPIC);
+            for (Count c : facetField.getValues()) {
+                if (c.getName().equals(topicId.replace("!", "/"))) {
+                    QATopic topic = new QATopic();
+                    topic.setKey(c.getName());
+                    topic.setTotalEvents(c.getCount());
+                    topic.setLastEvent(new Date());
+                    return topic;
+                }
+            }
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+        return null;
+    }
+
+    @Override
+    public List<QATopic> findAllTopics(Context context, long offset, long count, String orderField, boolean ascending) {
+        return findAllTopicsBySource(context, null, offset, count, orderField, ascending);
+    }
+
+    @Override
+    public List<QATopic> findAllTopicsBySource(Context context, String source, long offset,
+        long count, String orderField, boolean ascending) {
+        return findAllTopicsBySourceAndTarget(context, source, null, offset, count, orderField, ascending);
+    }
+
+    @Override
+    public List<QATopic> findAllTopicsBySourceAndTarget(Context context, String source, UUID target, long offset,
+        long pageSize, String orderField, boolean ascending) {
+        if (isNotSupportedSource(source)
+                || !qaSecurityService.canSeeSource(context, context.getCurrentUser(), source)) {
+            return List.of();
+        }
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        if (orderField != null) {
+            solrQuery.setSort(orderField, ascending ? ORDER.asc : ORDER.desc);
+            solrQuery.setFacetSort(FacetParams.FACET_SORT_INDEX);
+        }
+        Optional<String> securityQuery = qaSecurityService.generateQAEventFilterQuery(context,
+                context.getCurrentUser(), source);
+        solrQuery.setQuery(securityQuery.orElse("*:*"));
+        solrQuery.setFacet(true);
+        solrQuery.setFacetMinCount(1);
+        solrQuery.setFacetLimit((int) (offset + pageSize));
+        solrQuery.addFacetField(TOPIC);
+        solrQuery.addFilterQuery(SOURCE + ":\"" + source + "\"");
+        if (target != null) {
+            solrQuery.addFilterQuery(RESOURCE_UUID + ":" + target.toString());
+        }
+        QueryResponse response;
+        List<QATopic> topics = new ArrayList<>();
+        try {
+            response = getSolr().query(solrQuery);
+            FacetField facetField = response.getFacetField(TOPIC);
+            int idx = 0;
+            for (Count c : facetField.getValues()) {
+                if (idx < offset) {
+                    idx++;
+                    continue;
+                }
+                QATopic topic = new QATopic();
+                topic.setSource(source);
+                topic.setKey(c.getName());
+                topic.setFocus(target);
+                topic.setTotalEvents(c.getCount());
+                topic.setLastEvent(new Date());
+                topics.add(topic);
+                idx++;
+            }
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+        return topics;
+    }
+
+    @Override
+    public void store(Context context, QAEvent dto) {
+
+        if (isNotSupportedSource(dto.getSource())) {
+            throw new IllegalArgumentException("The source of the given event is not supported: " + dto.getSource());
+        }
+
+        if (StringUtils.isBlank(dto.getTopic())) {
+            throw new IllegalArgumentException("A topic is mandatory for an event");
+        }
+
+        String checksum = dto.getEventId();
+        try {
+            if (!qaEventsDao.isEventStored(context, checksum)) {
+
+                SolrInputDocument doc = createSolrDocument(context, dto, checksum);
+
+                UpdateRequest updateRequest = new UpdateRequest();
+
+                updateRequest.add(doc);
+                updateRequest.process(getSolr());
+
+                getSolr().commit();
+
+                performAutomaticProcessingIfNeeded(context, dto);
+            }
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private void performAutomaticProcessingIfNeeded(Context context, QAEvent qaEvent) {
+        if (qaAutomaticProcessingMap == null) {
+            return;
+        }
+        QAEventAutomaticProcessingEvaluation evaluation = qaAutomaticProcessingMap.get(qaEvent.getSource());
+
+        if (evaluation == null) {
+            return;
+        }
+
+        AutomaticProcessingAction action = evaluation.evaluateAutomaticProcessing(context, qaEvent);
+
+        if (action == null) {
+            return;
+        }
+
+        switch (action) {
+            case REJECT:
+                qaEventActionService.reject(context, qaEvent);
+                break;
+            case IGNORE:
+                qaEventActionService.discard(context, qaEvent);
+                break;
+            case ACCEPT:
+                qaEventActionService.accept(context, qaEvent);
+                break;
+            default:
+                throw new IllegalStateException("Unknown automatic action requested " + action);
+        }
+
+    }
+
+    /**
+     * Sends an email notification to the system administrator about a new
+     * Quality Assurance (QA) request event. The email includes details such as the
+     * topic, target, and message associated with the QA event.
+     *
+     * @param qaEvent The Quality Assurance event for which the notification is generated.
+     */
+    public void sentEmailToAdminAboutNewRequest(QAEvent qaEvent) {
+        try {
+            String uiUrl = configurationService.getProperty("dspace.ui.url");
+            Email email = Email.getEmail(I18nUtil.getEmailFilename(Locale.getDefault(), "qaevent_admin_notification"));
+            email.addRecipient(configurationService.getProperty("qaevents.mail.notification"));
+            email.addArgument(qaEvent.getTopic());
+            email.addArgument(uiUrl + "/items/" + qaEvent.getTarget());
+            email.addArgument(parsJson(qaEvent.getMessage()));
+            email.send();
+        } catch (Exception e) {
+            log.warn("Error during sending email of Withdrawn/Reinstate request for item with uuid:  {}",
+                     qaEvent.getTarget(), e);
+        }
+    }
+
+    private String parsJson(String jsonString) {
+        try {
+            ObjectMapper objectMapper = new ObjectMapper();
+            JsonNode jsonNode = objectMapper.readTree(jsonString);
+            return jsonNode.get("reason").asText();
+        } catch (Exception e) {
+            log.warn("Unable to parse the JSON:  {}", jsonString);
+            return jsonString;
+        }
+    }
+
+    @Override
+    public QAEvent findEventByEventId(String eventId) {
+        SolrQuery solrQuery = new SolrQuery("*:*");
+        solrQuery.addFilterQuery(EVENT_ID + ":\"" + eventId + "\"");
+        try {
+            QueryResponse response = getSolr().query(solrQuery);
+            if (response != null) {
+                SolrDocumentList list = response.getResults();
+                if (list != null && list.size() == 1) {
+                    SolrDocument doc = list.get(0);
+                    return getQAEventFromSOLR(doc);
+                }
+            }
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException("Exception querying Solr", e);
+        }
+        return null;
+    }
+
+    @Override
+    public List<QAEvent> findEventsByTopic(Context context, String sourceName, String topic, long offset, int pageSize,
+                                           String orderField, boolean ascending) {
+        EPerson currentUser = context.getCurrentUser();
+        if (isNotSupportedSource(sourceName) || !qaSecurityService.canSeeSource(context, currentUser, sourceName)) {
+            return List.of();
+        }
+
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setStart(((Long) offset).intValue());
+        if (pageSize != -1) {
+            solrQuery.setRows(pageSize);
+        }
+        solrQuery.setSort(orderField, ascending ? ORDER.asc : ORDER.desc);
+        Optional<String> securityQuery = qaSecurityService.generateQAEventFilterQuery(context, currentUser, sourceName);
+        solrQuery.setQuery(securityQuery.orElse("*:*"));
+
+        solrQuery.setQuery(TOPIC + ":" + topic.replaceAll("!", "/"));
+        solrQuery.addFilterQuery(SOURCE + ":\"" + sourceName + "\"");
+
+        try {
+            QueryResponse response = getSolr().query(solrQuery);
+            if (response != null) {
+                SolrDocumentList solrDocuments = response.getResults();
+                List<QAEvent> responseItem = new ArrayList<>();
+                for (SolrDocument doc : solrDocuments) {
+                    QAEvent item = getQAEventFromSOLR(doc);
+                    responseItem.add(item);
+                }
+                return responseItem;
+            }
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+        return List.of();
+    }
+
+    @Override
+    public long countEventsByTopic(Context context, String sourceName, String topic) {
+        EPerson currentUser = context.getCurrentUser();
+        if (isNotSupportedSource(sourceName) || !qaSecurityService.canSeeSource(context, currentUser, sourceName)) {
+            return 0;
+        }
+
+        Optional<String> securityQuery = qaSecurityService.generateQAEventFilterQuery(context, currentUser, sourceName);
+
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        solrQuery.setQuery(securityQuery.orElse("*:*"));
+        solrQuery.addFilterQuery(SOURCE + ":\"" + sourceName + "\"");
+        solrQuery.setQuery(TOPIC + ":" + topic.replaceAll("!", "/"));
+        try {
+            return getSolr().query(solrQuery).getResults().getNumFound();
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+    }
+
+    @Override
+    public QASource findSource(Context context, String sourceName) {
+        String[] split = sourceName.split(":");
+        return findSource(context, split[0], split.length == 2 ? UUID.fromString(split[1]) : null);
+    }
+
+    @Override
+    public QASource findSource(Context context, String sourceName, UUID target) {
+        EPerson currentUser = context.getCurrentUser();
+        if (isNotSupportedSource(sourceName) || !qaSecurityService.canSeeSource(context, currentUser, sourceName)) {
+            return null;
+        }
+
+        Optional<String> securityQuery = qaSecurityService.generateQAEventFilterQuery(context, currentUser, sourceName);
+
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setQuery(securityQuery.orElse("*:*"));
+        solrQuery.setRows(0);
+        solrQuery.addFilterQuery(SOURCE + ":\"" + sourceName + "\"");
+        if (target != null) {
+            solrQuery.addFilterQuery("resource_uuid:" + target.toString());
+        }
+        solrQuery.setFacet(true);
+        solrQuery.setFacetMinCount(1);
+        solrQuery.addFacetField(SOURCE);
+
+        try {
+            QueryResponse response = getSolr().query(solrQuery);
+            FacetField facetField = response.getFacetField(SOURCE);
+            for (Count c : facetField.getValues()) {
+                if (c.getName().equalsIgnoreCase(sourceName)) {
+                    QASource source = new QASource();
+                    source.setName(c.getName());
+                    source.setFocus(target);
+                    source.setTotalEvents(c.getCount());
+                    source.setLastEvent(new Date());
+                    return source;
+                }
+            }
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+
+        QASource source = new QASource();
+        source.setName(sourceName);
+        source.setTotalEvents(0L);
+
+        return source;
+    }
+
+    @Override
+    public List<QASource> findAllSources(Context context, long offset, int pageSize) {
+        return Arrays.stream(getSupportedSources())
+                     .map((sourceName) -> findSource(context, sourceName))
+            .filter(Objects::nonNull)
+                     .sorted(comparing(QASource::getTotalEvents)
+                     .reversed())
+                     .skip(offset)
+                     .limit(pageSize)
+                     .collect(Collectors.toList());
+    }
+
+    @Override
+    public long countSources(Context context) {
+        return Arrays.stream(getSupportedSources())
+                .map((sourceName) -> findSource(context, sourceName))
+                .filter(Objects::nonNull)
+                .filter(source -> source.getTotalEvents() > 0)
+                .count();
+    }
+
+    @Override
+    public long countSourcesByTarget(Context context, UUID target) {
+        return Arrays.stream(getSupportedSources())
+                .map((sourceName) -> findSource(context, sourceName, target))
+                .filter(Objects::nonNull)
+                .filter(source -> source.getTotalEvents() > 0)
+                .count();
+    }
+
+    @Override
+    public boolean isRelatedItemSupported(QAEvent qaevent) {
+        // Currently only PROJECT topics related to OPENAIRE supports related items
+        return qaevent.getSource().equals(OPENAIRE_SOURCE) && endsWith(qaevent.getTopic(), "/PROJECT");
+    }
+
+    private SolrInputDocument createSolrDocument(Context context, QAEvent dto, String checksum) throws Exception {
+        SolrInputDocument doc = new SolrInputDocument();
+        doc.addField(SOURCE, dto.getSource());
+        doc.addField(EVENT_ID, checksum);
+        doc.addField(ORIGINAL_ID, dto.getOriginalId());
+        doc.addField(TITLE, dto.getTitle());
+        doc.addField(TOPIC, dto.getTopic());
+        doc.addField(TRUST, dto.getTrust());
+        doc.addField(MESSAGE, dto.getMessage());
+        doc.addField(LAST_UPDATE, new Date());
+        String resourceUUID = getResourceUUID(context, dto.getOriginalId());
+        if (resourceUUID == null) {
+            resourceUUID = dto.getTarget();
+            /*throw new IllegalArgumentException("Skipped event " + checksum +
+                " related to the oai record " + dto.getOriginalId() + " as the record was not found");*/
+        }
+        doc.addField(RESOURCE_UUID, resourceUUID);
+        doc.addField(RELATED_UUID, dto.getRelated());
+        return doc;
+    }
+
+    private String getResourceUUID(Context context, String originalId) throws Exception {
+        String id = getHandleFromOriginalId(originalId);
+        if (id != null) {
+            Item item = (Item) handleService.resolveToObject(context, id);
+            if (item != null) {
+                final String itemUuid = item.getID().toString();
+                context.uncacheEntity(item);
+                return itemUuid;
+            } else {
+                return null;
+            }
+        } else {
+            throw new IllegalArgumentException("Malformed originalId " + originalId);
+        }
+    }
+
+    // oai:www.openstarts.units.it:10077/21486
+    private String getHandleFromOriginalId(String originalId) {
+        int startPosition = originalId.lastIndexOf(':');
+        if (startPosition != -1) {
+            return originalId.substring(startPosition + 1, originalId.length());
+        } else {
+            return originalId;
+        }
+    }
+
+    private QAEvent getQAEventFromSOLR(SolrDocument doc) {
+        QAEvent item = new QAEvent();
+        item.setSource((String) doc.get(SOURCE));
+        item.setEventId((String) doc.get(EVENT_ID));
+        item.setLastUpdate((Date) doc.get(LAST_UPDATE));
+        item.setMessage((String) doc.get(MESSAGE));
+        item.setOriginalId((String) doc.get(ORIGINAL_ID));
+        item.setTarget((String) doc.get(RESOURCE_UUID));
+        item.setTitle((String) doc.get(TITLE));
+        item.setTopic((String) doc.get(TOPIC));
+        item.setTrust((double) doc.get(TRUST));
+        item.setRelated((String) doc.get(RELATED_UUID));
+        return item;
+    }
+
+    @Override
+    public boolean qaEventsInSource(Context context, EPerson user, String eventId, String source) {
+        SolrQuery solrQuery = new SolrQuery();
+        Optional<String> securityQuery = qaSecurityService.generateQAEventFilterQuery(context, user, source);
+        solrQuery.setQuery(securityQuery.orElse("*:*"));
+        solrQuery.addFilterQuery(EVENT_ID + ":\"" + eventId + "\"");
+        QueryResponse response;
+        try {
+            response = getSolr().query(solrQuery);
+            if (response != null) {
+                return response.getResults().getNumFound() == 1;
+            }
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException("Exception querying Solr", e);
+        }
+        return false;
+    }
+
+    @Override
+    public long countEventsByTopicAndTarget(Context context, String sourceName, String topic, UUID target) {
+        var currentUser = context.getCurrentUser();
+        if (isNotSupportedSource(sourceName) || !qaSecurityService.canSeeSource(context, currentUser, sourceName)) {
+            return 0;
+        }
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        Optional<String> securityQuery = qaSecurityService.generateQAEventFilterQuery(context, currentUser, sourceName);
+        solrQuery.setQuery(securityQuery.orElse("*:*"));
+        if (target != null) {
+            solrQuery.addFilterQuery(RESOURCE_UUID + ":\"" + target.toString() + "\"");
+        }
+        solrQuery.addFilterQuery(SOURCE + ":\"" + sourceName + "\"");
+        solrQuery.addFilterQuery(TOPIC + ":\"" + topic + "\"");
+        QueryResponse response = null;
+        try {
+            response = getSolr().query(solrQuery);
+            return response.getResults().getNumFound();
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public List<QAEvent> findEventsByTopicAndTarget(Context context, String source, String topic, UUID target,
+            long offset, int pageSize) {
+        var currentUser = context.getCurrentUser();
+        if (isNotSupportedSource(source) || !qaSecurityService.canSeeSource(context, currentUser, source)) {
+            return List.of();
+        }
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setStart(((Long) offset).intValue());
+        solrQuery.setRows(pageSize);
+        solrQuery.setSort(TRUST, ORDER.desc);
+        Optional<String> securityQuery = qaSecurityService.generateQAEventFilterQuery(context, currentUser, source);
+        solrQuery.setQuery(securityQuery.orElse("*:*"));
+        if (target != null) {
+            solrQuery.addFilterQuery(RESOURCE_UUID + ":\"" + target.toString() + "\"");
+        }
+        solrQuery.addFilterQuery(SOURCE + ":\"" + source + "\"");
+        solrQuery.addFilterQuery(TOPIC + ":\"" + topic + "\"");
+
+        try {
+            QueryResponse response = getSolr().query(solrQuery);
+            if (response != null) {
+                SolrDocumentList list = response.getResults();
+                List<QAEvent> responseItem = new ArrayList<>();
+                for (SolrDocument doc : list) {
+                    QAEvent item = getQAEventFromSOLR(doc);
+                    responseItem.add(item);
+                }
+                return responseItem;
+            }
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+        return List.of();
+    }
+
+    private boolean isNotSupportedSource(String source) {
+        return !ArrayUtils.contains(getSupportedSources(), source);
+    }
+
+    private String[] getSupportedSources() {
+        return configurationService.getArrayProperty(QAEVENTS_SOURCES,
+            new String[] { QAEvent.OPENAIRE_SOURCE, QAEvent.COAR_NOTIFY_SOURCE });
+    }
+
+    @Override
+    public long countTopicsBySourceAndTarget(Context context, String source, UUID target) {
+        var currentUser = context.getCurrentUser();
+        if (isNotSupportedSource(source) || !qaSecurityService.canSeeSource(context, currentUser, source)) {
+            return 0;
+        }
+        SolrQuery solrQuery = new SolrQuery();
+        solrQuery.setRows(0);
+        Optional<String> securityQuery = qaSecurityService.generateQAEventFilterQuery(context, currentUser, source);
+        solrQuery.setQuery(securityQuery.orElse("*:*"));
+        solrQuery.setFacet(true);
+        solrQuery.setFacetMinCount(1);
+        solrQuery.addFacetField(TOPIC);
+        solrQuery.addFilterQuery(SOURCE + ":\"" + source + "\"");
+        if (target != null) {
+            solrQuery.addFilterQuery(RESOURCE_UUID + ":\"" + target.toString() + "\"");
+        }
+        try {
+            QueryResponse response = getSolr().query(solrQuery);
+            return response.getFacetField(TOPIC).getValueCount();
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public List<QASource> findAllSourcesByTarget(Context context, UUID target, long offset, int pageSize) {
+        return Arrays.stream(getSupportedSources())
+                     .map((sourceName) -> findSource(context, sourceName, target))
+                     .filter(Objects::nonNull)
+                     .sorted(comparing(QASource::getTotalEvents).reversed())
+                     .filter(source -> source.getTotalEvents() > 0)
+                     .skip(offset)
+                     .limit(pageSize)
+                     .collect(Collectors.toList());
+    }
+
+}
diff --git a/dspace-api/src/main/java/org/dspace/util/RawJsonDeserializer.java b/dspace-api/src/main/java/org/dspace/util/RawJsonDeserializer.java
new file mode 100644
index 0000000000..baadf0d283
--- /dev/null
+++ b/dspace-api/src/main/java/org/dspace/util/RawJsonDeserializer.java
@@ -0,0 +1,35 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.util;
+
+import java.io.IOException;
+
+import com.fasterxml.jackson.core.JsonParser;
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.DeserializationContext;
+import com.fasterxml.jackson.databind.JsonDeserializer;
+import com.fasterxml.jackson.databind.JsonNode;
+import com.fasterxml.jackson.databind.ObjectMapper;
+
+/**
+ * Extension of {@link JsonDeserializer} that convert a json to a String.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class RawJsonDeserializer extends JsonDeserializer<String> {
+
+    @Override
+    public String deserialize(JsonParser jp, DeserializationContext ctxt)
+           throws IOException, JsonProcessingException {
+
+        ObjectMapper mapper = (ObjectMapper) jp.getCodec();
+        JsonNode node = mapper.readTree(jp);
+        return mapper.writeValueAsString(node);
+    }
+}
\ No newline at end of file
diff --git a/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/h2/V7.6_2024.03.07__qaevent_processed.sql b/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/h2/V7.6_2024.03.07__qaevent_processed.sql
new file mode 100644
index 0000000000..467de85f85
--- /dev/null
+++ b/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/h2/V7.6_2024.03.07__qaevent_processed.sql
@@ -0,0 +1,16 @@
+--
+-- The contents of this file are subject to the license and copyright
+-- detailed in the LICENSE and NOTICE files at the root of the source
+-- tree and available online at
+--
+-- http://www.dspace.org/license/
+--
+
+CREATE TABLE qaevent_processed (
+  qaevent_id VARCHAR(255) NOT NULL,
+  qaevent_timestamp TIMESTAMP NULL,
+  eperson_uuid UUID NULL REFERENCES eperson(uuid),
+  item_uuid uuid NOT NULL REFERENCES item(uuid)
+);
+
+CREATE INDEX item_uuid_idx ON qaevent_processed(item_uuid);
diff --git a/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/h2/V7.6_2024.03.12__ldn_tables.sql b/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/h2/V7.6_2024.03.12__ldn_tables.sql
new file mode 100644
index 0000000000..f5ea59254f
--- /dev/null
+++ b/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/h2/V7.6_2024.03.12__ldn_tables.sql
@@ -0,0 +1,90 @@
+--
+-- The contents of this file are subject to the license and copyright
+-- detailed in the LICENSE and NOTICE files at the root of the source
+-- tree and available online at
+--
+-- http://www.dspace.org/license/
+--
+
+-----------------------------------------------------------------------------------
+-- CREATE notifyservice table
+-----------------------------------------------------------------------------------
+
+
+CREATE SEQUENCE if NOT EXISTS notifyservice_id_seq;
+
+CREATE TABLE notifyservice (
+    id INTEGER PRIMARY KEY,
+    name VARCHAR(255),
+    description TEXT,
+    url VARCHAR(255),
+    ldn_url VARCHAR(255),
+    enabled BOOLEAN NOT NULL,
+    score NUMERIC(6, 5),
+    lower_ip VARCHAR(45),
+    upper_ip VARCHAR(45),
+    CONSTRAINT ldn_url_unique UNIQUE (ldn_url)
+);
+
+-----------------------------------------------------------------------------------
+-- CREATE notifyservice_inbound_pattern_id_seq table
+-----------------------------------------------------------------------------------
+
+CREATE SEQUENCE if NOT EXISTS notifyservice_inbound_pattern_id_seq;
+
+CREATE TABLE notifyservice_inbound_pattern (
+    id INTEGER PRIMARY KEY,
+    service_id INTEGER REFERENCES notifyservice(id) ON DELETE CASCADE,
+    pattern VARCHAR(255),
+    constraint_name VARCHAR(255),
+    automatic BOOLEAN
+);
+
+CREATE INDEX notifyservice_inbound_idx ON notifyservice_inbound_pattern (service_id);
+
+
+-------------------------------------------------------------------------------
+-- Table to store LDN messages
+-------------------------------------------------------------------------------
+
+CREATE TABLE ldn_message
+(
+  id VARCHAR(255) PRIMARY KEY,
+  object uuid,
+  message TEXT,
+  type VARCHAR(255),
+  origin INTEGER,
+  target INTEGER,
+  inReplyTo VARCHAR(255),
+  context uuid,
+  activity_stream_type VARCHAR(255),
+  coar_notify_type VARCHAR(255),
+  queue_status INTEGER DEFAULT NULL,
+  queue_attempts INTEGER DEFAULT 0,
+  queue_last_start_time TIMESTAMP,
+  queue_timeout TIMESTAMP,
+  source_ip VARCHAR(45),
+  FOREIGN KEY (object) REFERENCES dspaceobject (uuid) ON DELETE SET NULL,
+  FOREIGN KEY (context) REFERENCES dspaceobject (uuid) ON DELETE SET NULL,
+  FOREIGN KEY (origin) REFERENCES notifyservice (id) ON DELETE SET NULL,
+  FOREIGN KEY (target) REFERENCES notifyservice (id) ON DELETE SET NULL,
+  FOREIGN KEY (inReplyTo) REFERENCES ldn_message (id) ON DELETE SET NULL
+);
+
+
+-------------------------------------------------------------------------------
+-- Table to store notify patterns that will be triggered
+-------------------------------------------------------------------------------
+
+CREATE SEQUENCE if NOT EXISTS notifypatterns_to_trigger_id_seq;
+
+CREATE TABLE notifypatterns_to_trigger
+(
+  id INTEGER PRIMARY KEY,
+  item_id UUID REFERENCES Item(uuid) ON DELETE CASCADE,
+  service_id INTEGER REFERENCES notifyservice(id) ON DELETE CASCADE,
+  pattern VARCHAR(255)
+);
+
+CREATE INDEX notifypatterns_to_trigger_item_idx ON notifypatterns_to_trigger (item_id);
+CREATE INDEX notifypatterns_to_trigger_service_idx ON notifypatterns_to_trigger (service_id);
diff --git a/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/postgres/V7.6_2024.03.07__qaevent_processed.sql b/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/postgres/V7.6_2024.03.07__qaevent_processed.sql
new file mode 100644
index 0000000000..5c3f0fac73
--- /dev/null
+++ b/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/postgres/V7.6_2024.03.07__qaevent_processed.sql
@@ -0,0 +1,19 @@
+--
+-- The contents of this file are subject to the license and copyright
+-- detailed in the LICENSE and NOTICE files at the root of the source
+-- tree and available online at
+--
+-- http://www.dspace.org/license/
+--
+
+CREATE TABLE qaevent_processed (
+  qaevent_id VARCHAR(255) NOT NULL,
+  qaevent_timestamp TIMESTAMP NULL,
+  eperson_uuid UUID NULL,
+  item_uuid UUID NULL,
+  CONSTRAINT qaevent_pk PRIMARY KEY (qaevent_id),
+  CONSTRAINT eperson_uuid_fkey FOREIGN KEY (eperson_uuid) REFERENCES eperson (uuid),
+  CONSTRAINT item_uuid_fkey FOREIGN KEY (item_uuid) REFERENCES item (uuid)
+);
+
+CREATE INDEX item_uuid_idx ON qaevent_processed(item_uuid);
diff --git a/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/postgres/V7.6_2024.03.12__ldn_tables.sql b/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/postgres/V7.6_2024.03.12__ldn_tables.sql
new file mode 100644
index 0000000000..f5ea59254f
--- /dev/null
+++ b/dspace-api/src/main/resources/org/dspace/storage/rdbms/sqlmigration/postgres/V7.6_2024.03.12__ldn_tables.sql
@@ -0,0 +1,90 @@
+--
+-- The contents of this file are subject to the license and copyright
+-- detailed in the LICENSE and NOTICE files at the root of the source
+-- tree and available online at
+--
+-- http://www.dspace.org/license/
+--
+
+-----------------------------------------------------------------------------------
+-- CREATE notifyservice table
+-----------------------------------------------------------------------------------
+
+
+CREATE SEQUENCE if NOT EXISTS notifyservice_id_seq;
+
+CREATE TABLE notifyservice (
+    id INTEGER PRIMARY KEY,
+    name VARCHAR(255),
+    description TEXT,
+    url VARCHAR(255),
+    ldn_url VARCHAR(255),
+    enabled BOOLEAN NOT NULL,
+    score NUMERIC(6, 5),
+    lower_ip VARCHAR(45),
+    upper_ip VARCHAR(45),
+    CONSTRAINT ldn_url_unique UNIQUE (ldn_url)
+);
+
+-----------------------------------------------------------------------------------
+-- CREATE notifyservice_inbound_pattern_id_seq table
+-----------------------------------------------------------------------------------
+
+CREATE SEQUENCE if NOT EXISTS notifyservice_inbound_pattern_id_seq;
+
+CREATE TABLE notifyservice_inbound_pattern (
+    id INTEGER PRIMARY KEY,
+    service_id INTEGER REFERENCES notifyservice(id) ON DELETE CASCADE,
+    pattern VARCHAR(255),
+    constraint_name VARCHAR(255),
+    automatic BOOLEAN
+);
+
+CREATE INDEX notifyservice_inbound_idx ON notifyservice_inbound_pattern (service_id);
+
+
+-------------------------------------------------------------------------------
+-- Table to store LDN messages
+-------------------------------------------------------------------------------
+
+CREATE TABLE ldn_message
+(
+  id VARCHAR(255) PRIMARY KEY,
+  object uuid,
+  message TEXT,
+  type VARCHAR(255),
+  origin INTEGER,
+  target INTEGER,
+  inReplyTo VARCHAR(255),
+  context uuid,
+  activity_stream_type VARCHAR(255),
+  coar_notify_type VARCHAR(255),
+  queue_status INTEGER DEFAULT NULL,
+  queue_attempts INTEGER DEFAULT 0,
+  queue_last_start_time TIMESTAMP,
+  queue_timeout TIMESTAMP,
+  source_ip VARCHAR(45),
+  FOREIGN KEY (object) REFERENCES dspaceobject (uuid) ON DELETE SET NULL,
+  FOREIGN KEY (context) REFERENCES dspaceobject (uuid) ON DELETE SET NULL,
+  FOREIGN KEY (origin) REFERENCES notifyservice (id) ON DELETE SET NULL,
+  FOREIGN KEY (target) REFERENCES notifyservice (id) ON DELETE SET NULL,
+  FOREIGN KEY (inReplyTo) REFERENCES ldn_message (id) ON DELETE SET NULL
+);
+
+
+-------------------------------------------------------------------------------
+-- Table to store notify patterns that will be triggered
+-------------------------------------------------------------------------------
+
+CREATE SEQUENCE if NOT EXISTS notifypatterns_to_trigger_id_seq;
+
+CREATE TABLE notifypatterns_to_trigger
+(
+  id INTEGER PRIMARY KEY,
+  item_id UUID REFERENCES Item(uuid) ON DELETE CASCADE,
+  service_id INTEGER REFERENCES notifyservice(id) ON DELETE CASCADE,
+  pattern VARCHAR(255)
+);
+
+CREATE INDEX notifypatterns_to_trigger_item_idx ON notifypatterns_to_trigger (item_id);
+CREATE INDEX notifypatterns_to_trigger_service_idx ON notifypatterns_to_trigger (service_id);
diff --git a/dspace-api/src/main/resources/spring/spring-dspace-addon-import-services.xml b/dspace-api/src/main/resources/spring/spring-dspace-addon-import-services.xml
index 6b0ef3e9b9..fdf5d6c534 100644
--- a/dspace-api/src/main/resources/spring/spring-dspace-addon-import-services.xml
+++ b/dspace-api/src/main/resources/spring/spring-dspace-addon-import-services.xml
@@ -123,6 +123,20 @@
           </property>
     </bean>
 
+    <bean id="openaireImportServiceByAuthor"
+          class="org.dspace.importer.external.openaire.service.OpenAireImportMetadataSourceServiceImpl" scope="singleton">
+        <property name="metadataFieldMapping" ref="openairePublicationMetadataFieldMapping"/>
+        <property name="queryParam" value="author"/>
+    </bean>
+    <bean id="openaireImportServiceByTitle"
+          class="org.dspace.importer.external.openaire.service.OpenAireImportMetadataSourceServiceImpl" scope="singleton">
+        <property name="metadataFieldMapping" ref="openairePublicationMetadataFieldMapping"/>
+        <property name="queryParam" value="title"/>
+    </bean>
+    <bean id="openairePublicationMetadataFieldMapping"
+          class="org.dspace.importer.external.openaire.metadatamapping.OpenAIREPublicationFieldMapping">
+    </bean>
+
     <bean id="CrossRefImportService" class="org.dspace.importer.external.crossref.CrossRefImportMetadataSourceServiceImpl" scope="singleton">
         <property name="metadataFieldMapping" ref="CrossRefMetadataFieldMapping"/>
         <property name="url" value="${crossref.url}"/>
diff --git a/dspace-api/src/main/resources/spring/spring-dspace-addon-suggestion-services.xml b/dspace-api/src/main/resources/spring/spring-dspace-addon-suggestion-services.xml
new file mode 100644
index 0000000000..fb720137c4
--- /dev/null
+++ b/dspace-api/src/main/resources/spring/spring-dspace-addon-suggestion-services.xml
@@ -0,0 +1,23 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!--
+
+    The contents of this file are subject to the license and copyright
+    detailed in the LICENSE and NOTICE files at the root of the source
+    tree and available online at
+
+    http://www.dspace.org/license/
+
+-->
+<beans xmlns="http://www.springframework.org/schema/beans"
+       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+       xmlns:context="http://www.springframework.org/schema/context"
+       xsi:schemaLocation="http://www.springframework.org/schema/beans
+           http://www.springframework.org/schema/beans/spring-beans.xsd
+           http://www.springframework.org/schema/context
+           http://www.springframework.org/schema/context/spring-context.xsd"
+       default-autowire-candidates="*Service,*DAO,javax.sql.DataSource">
+
+    <context:annotation-config/> <!-- allows us to use spring annotations in beans -->
+
+    <bean class="org.dspace.app.suggestion.SuggestionServiceImpl" id="org.dspace.app.suggestion.SuggestionService" />
+</beans>
diff --git a/dspace-api/src/test/data/dspaceFolder/config/item-submission.xml b/dspace-api/src/test/data/dspaceFolder/config/item-submission.xml
index 452460501a..9b464bbe50 100644
--- a/dspace-api/src/test/data/dspaceFolder/config/item-submission.xml
+++ b/dspace-api/src/test/data/dspaceFolder/config/item-submission.xml
@@ -24,6 +24,7 @@
         <name-map collection-handle="123456789/typebind-test" submission-name="typebindtest"/>
         <name-map collection-handle="123456789/accessCondition-not-discoverable" submission-name="accessConditionNotDiscoverable"/>
         <name-map collection-handle="123456789/test-hidden" submission-name="test-hidden"/>
+        <name-map collection-handle="123456789/collection-test" submission-name="collectiontest"/>
     </submission-map>
 
 
@@ -177,6 +178,12 @@
             <scope visibility="hidden" visibilityOutside="hidden">submission</scope>
         </step-definition>
 
+        <step-definition id="coarnotify">
+            <heading>submit.progressbar.coarnotify</heading>
+            <processing-class>org.dspace.app.rest.submit.step.NotifyStep</processing-class>
+            <type>coarnotify</type>
+        </step-definition>
+
     </step-definitions>
 
     <!-- The submission-definitions map lays out the detailed definition of -->
@@ -209,6 +216,9 @@
             <step id="traditionalpageone"/>
             <step id="traditionalpagetwo"/>
 
+            <!--Step will be COAR Notify services to the item -->
+            <step id="coarnotify"/>
+
             <!--Step will be to Upload the item -->
             <step id="upload"/>
             <!-- <step id="upload-with-embargo"/> -->
diff --git a/dspace-api/src/test/data/dspaceFolder/config/local.cfg b/dspace-api/src/test/data/dspaceFolder/config/local.cfg
index 35ed8a235b..3dc4e398c1 100644
--- a/dspace-api/src/test/data/dspaceFolder/config/local.cfg
+++ b/dspace-api/src/test/data/dspaceFolder/config/local.cfg
@@ -95,14 +95,14 @@ loglevel.dspace = INFO
 #  IIIF TEST SETTINGS  #
 ########################
 iiif.enabled = true
-event.dispatcher.default.consumers = versioning, discovery, eperson, orcidqueue, iiif
+event.dispatcher.default.consumers = versioning, discovery, eperson, orcidqueue, iiif, qaeventsdelete, ldnmessage
 
 ###########################################
 # CUSTOM UNIT / INTEGRATION TEST SETTINGS #
 ###########################################
 # custom dispatcher to be used by dspace-api IT that doesn't need SOLR
 event.dispatcher.exclude-discovery.class = org.dspace.event.BasicDispatcher
-event.dispatcher.exclude-discovery.consumers = versioning, eperson
+event.dispatcher.exclude-discovery.consumers = versioning, eperson, qaeventsdelete, ldnmessage
 
 # Configure authority control for Unit Testing (in DSpaceControlledVocabularyTest)
 # (This overrides default, commented out settings in dspace.cfg)
@@ -174,3 +174,13 @@ authority.controlled.dspace.object.owner = true
 # Configuration required for thorough testing of browse links
 webui.browse.link.1 = author:dc.contributor.*
 webui.browse.link.2 = subject:dc.subject.*
+
+
+###########################################
+#  LDN CONFIGURATIONS                     #
+###########################################
+ldn.enabled = true
+qaevents.enabled = true
+ldn.ip-range.enabled = true
+ldn.notify.inbox.block-untrusted = true
+ldn.notify.inbox.block-untrusted-ip = true
diff --git a/dspace-api/src/test/data/dspaceFolder/config/spring/api/external-openaire.xml b/dspace-api/src/test/data/dspaceFolder/config/spring/api/external-openaire.xml
index f1e6c30d13..8a5277ab2d 100644
--- a/dspace-api/src/test/data/dspaceFolder/config/spring/api/external-openaire.xml
+++ b/dspace-api/src/test/data/dspaceFolder/config/spring/api/external-openaire.xml
@@ -7,7 +7,7 @@
                            http://www.springframework.org/schema/util/spring-util.xsd"
        default-lazy-init="true">
 
-    <bean id="mockOpenAIRERestConnector" class="org.dspace.external.MockOpenAIRERestConnector">
+    <bean id="mockOpenaireRestConnector" class="org.dspace.external.MockOpenaireRestConnector">
         <constructor-arg value="${openaire.api.url:https://api.openaire.eu}"/>
 		<property name="tokenEnabled" value="${openaire.token.enabled:false}"/>
 		<property name="tokenServiceUrl" value="${openaire.token.url:https://aai.openaire.eu/oidc/token}"/>
@@ -15,10 +15,10 @@
 		<property name="clientSecret" value="${openaire.token.clientSecret}"/>
     </bean>
 	<bean
-		class="org.dspace.external.provider.impl.OpenAIREFundingDataProvider"
+		class="org.dspace.external.provider.impl.OpenaireFundingDataProvider"
 		init-method="init">
-		<property name="sourceIdentifier" value="openAIREFunding" />
-		<property name="connector" ref="mockOpenAIRERestConnector" />
+		<property name="sourceIdentifier" value="openaireFunding" />
+		<property name="connector" ref="mockOpenaireRestConnector" />
 	    <property name="metadataFields" ref="mapOfmetadata"/>
 		<property name="supportedEntityTypes">
 			<list>
diff --git a/dspace-api/src/test/data/dspaceFolder/config/spring/api/external-services.xml b/dspace-api/src/test/data/dspaceFolder/config/spring/api/external-services.xml
index 37e1fb5089..8081e6f2f7 100644
--- a/dspace-api/src/test/data/dspaceFolder/config/spring/api/external-services.xml
+++ b/dspace-api/src/test/data/dspaceFolder/config/spring/api/external-services.xml
@@ -91,6 +91,8 @@
         </property>
     </bean>
 
+    <bean class="org.dspace.app.suggestion.MockSuggestionExternalDataSource" />
+
     <bean id="dataciteLiveImportDataProvider" class="org.dspace.external.provider.impl.LiveImportDataProvider">
         <property name="metadataSource" ref="DataCiteImportService"/>
         <property name="sourceIdentifier" value="datacite"/>
diff --git a/dspace-api/src/test/data/dspaceFolder/config/spring/api/item-filters.xml b/dspace-api/src/test/data/dspaceFolder/config/spring/api/item-filters.xml
index 836d4f0896..b1edb2d622 100644
--- a/dspace-api/src/test/data/dspaceFolder/config/spring/api/item-filters.xml
+++ b/dspace-api/src/test/data/dspaceFolder/config/spring/api/item-filters.xml
@@ -286,7 +286,7 @@
         </property>
     </bean>
 
-    <!-- An example of an OpenAIRE compliance filter based on the same rules in xoai.xml
+    <!-- An example of an Openaire compliance filter based on the same rules in xoai.xml
          some sub-statements are defined within this bean, and some are referenced from earlier definitions
     -->
     <bean id="openaire_filter" class="org.dspace.content.logic.DefaultFilter">
@@ -329,7 +329,7 @@
                                 </list>
                             </property>
                         </bean>
-                        <!-- AND the dc.relation is a valid OpenAIRE identifier
+                        <!-- AND the dc.relation is a valid Openaire identifier
                              (starts with "info:eu-repo/grantAgreement/") -->
                         <bean id="has-openaire-relation_condition"
                               class="org.dspace.content.logic.condition.MetadataValueMatchCondition">
@@ -367,4 +367,12 @@
         </property>
     </bean>
 
+    <util:map id="ldnItemFilters" key-type="java.lang.String"
+              value-type="org.dspace.content.logic.LogicalStatement">
+       <entry key="always_true_filter" value-ref="always_true_filter"/>
+       <entry key="in-outfit-collection_condition" value-ref="in-outfit-collection_condition"/>
+       <entry key="demo_filter" value-ref="demo_filter"/>
+       <entry key="doi-filter" value-ref="doi-filter"/>
+       <entry key="type_filter" value-ref="type_filter"/>
+	</util:map>
 </beans>
diff --git a/dspace-api/src/test/data/dspaceFolder/config/spring/api/qaevents-test.xml b/dspace-api/src/test/data/dspaceFolder/config/spring/api/qaevents-test.xml
new file mode 100644
index 0000000000..8738d6cbef
--- /dev/null
+++ b/dspace-api/src/test/data/dspaceFolder/config/spring/api/qaevents-test.xml
@@ -0,0 +1,28 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<beans xmlns="http://www.springframework.org/schema/beans"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xmlns:context="http://www.springframework.org/schema/context"
+    xmlns:util="http://www.springframework.org/schema/util"
+    xsi:schemaLocation="http://www.springframework.org/schema/beans
+           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
+           http://www.springframework.org/schema/context
+           http://www.springframework.org/schema/context/spring-context-2.5.xsd
+           http://www.springframework.org/schema/util
+           http://www.springframework.org/schema/util/spring-util.xsd">
+
+    <context:annotation-config /> <!-- allows us to use spring annotations in beans -->
+
+    <!-- this file contains extra beans related to the qaevent feature configured only for test purpose -->
+    <util:map id="qaAutomaticProcessingMap">
+        <entry key="coar-notify" value-ref="qaScoreEvaluation"/>
+    </util:map>
+
+    <bean id="qaScoreEvaluation" class="org.dspace.qaevent.QAScoreAutomaticProcessingEvaluation">
+        <property name="scoreToReject" value="0.3" />
+        <property name="scoreToIgnore" value="0.5" />
+        <property name="scoreToApprove" value="0.8" />
+        <property name="itemFilterToReject" ref="simple-demo_filter" />
+        <property name="itemFilterToIgnore" ref="simple-demo_filter" />
+        <property name="itemFilterToApprove" ref="simple-demo_filter" />
+    </bean>
+</beans>
\ No newline at end of file
diff --git a/dspace-api/src/test/data/dspaceFolder/config/spring/api/scripts.xml b/dspace-api/src/test/data/dspaceFolder/config/spring/api/scripts.xml
index 808d22a5bf..78a43f2774 100644
--- a/dspace-api/src/test/data/dspaceFolder/config/spring/api/scripts.xml
+++ b/dspace-api/src/test/data/dspaceFolder/config/spring/api/scripts.xml
@@ -65,6 +65,11 @@
         <property name="dspaceRunnableClass" value="org.dspace.orcid.script.OrcidBulkPush"/>
     </bean>
 
+    <bean id="import-openaire-events" class="org.dspace.qaevent.script.OpenaireEventsImportCliScriptConfiguration" primary="true">
+        <property name="description" value="Import new openaire quality assurance broker events"/>
+        <property name="dspaceRunnableClass" value="org.dspace.qaevent.script.OpenaireEventsImportCli"/>
+    </bean>
+
     <bean id="process-cleaner" class="org.dspace.administer.ProcessCleanerCliConfiguration">
         <property name="description" value="Cleanup all the old processes in the specified state"/>
         <property name="dspaceRunnableClass" value="org.dspace.administer.ProcessCleanerCli"/>
diff --git a/dspace-api/src/test/data/dspaceFolder/config/spring/api/solr-services.xml b/dspace-api/src/test/data/dspaceFolder/config/spring/api/solr-services.xml
index 32ab90b2cc..aaa896a937 100644
--- a/dspace-api/src/test/data/dspaceFolder/config/spring/api/solr-services.xml
+++ b/dspace-api/src/test/data/dspaceFolder/config/spring/api/solr-services.xml
@@ -47,7 +47,14 @@
     <bean id="org.dspace.statistics.SolrStatisticsCore"
           class="org.dspace.statistics.MockSolrStatisticsCore"
           autowire-candidate="true"/>
-          
+
+    <!-- qa events -->
+    <bean class="org.dspace.qaevent.MockQAEventService"
+          id="org.dspace.qaevent.service.QAEventService" />
+
     <bean class="org.dspace.statistics.GeoIpService" autowire-candidate="true"/>
 
+    <!-- suggestion service for solr providers -->
+    <bean id="org.dspace.app.suggestion.SolrSuggestionStorageService" class="org.dspace.app.suggestion.MockSolrSuggestionStorageService" />
+
 </beans>
diff --git a/dspace-api/src/test/data/dspaceFolder/config/spring/api/suggestions.xml b/dspace-api/src/test/data/dspaceFolder/config/spring/api/suggestions.xml
new file mode 100644
index 0000000000..a3ae1cb875
--- /dev/null
+++ b/dspace-api/src/test/data/dspaceFolder/config/spring/api/suggestions.xml
@@ -0,0 +1,33 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<beans xmlns="http://www.springframework.org/schema/beans"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xmlns:context="http://www.springframework.org/schema/context"
+    xmlns:util="http://www.springframework.org/schema/util"
+    xsi:schemaLocation="http://www.springframework.org/schema/beans
+           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
+           http://www.springframework.org/schema/context
+           http://www.springframework.org/schema/context/spring-context-2.5.xsd
+           http://www.springframework.org/schema/util 
+           http://www.springframework.org/schema/util/spring-util-3.0.xsd">
+
+    <context:annotation-config /> <!-- allows us to use spring annotations in beans -->
+
+    <!-- This is defined in the solr-services.xml
+	<bean id="org.dspace.app.nbevent.service.NBEventService" 
+	   class="org.dspace.app.nbevent.service.impl.NBEventServiceImpl" /> -->
+ 
+	 <util:map id="suggestionProviders" map-class="java.util.HashMap" 
+	          key-type="java.lang.String" value-type="org.dspace.app.suggestion.SuggestionProvider">
+	    <entry key="scopus">
+			<bean class="org.dspace.app.suggestion.MockSolrSuggestionProvider">
+				<property name="sourceName" value="scopus"></property>
+			</bean>
+		</entry>
+	    <entry key="reciter">
+            <bean class="org.dspace.app.suggestion.MockSolrSuggestionProvider">
+                <property name="sourceName" value="reciter"></property>
+            </bean>
+        </entry>
+	</util:map>
+
+ </beans>
diff --git a/dspace-api/src/test/java/org/dspace/AbstractIntegrationTestWithDatabase.java b/dspace-api/src/test/java/org/dspace/AbstractIntegrationTestWithDatabase.java
index e27fb19a68..dad6dbb4a6 100644
--- a/dspace-api/src/test/java/org/dspace/AbstractIntegrationTestWithDatabase.java
+++ b/dspace-api/src/test/java/org/dspace/AbstractIntegrationTestWithDatabase.java
@@ -29,6 +29,8 @@ import org.dspace.eperson.factory.EPersonServiceFactory;
 import org.dspace.eperson.service.EPersonService;
 import org.dspace.eperson.service.GroupService;
 import org.dspace.kernel.ServiceManager;
+import org.dspace.qaevent.MockQAEventService;
+import org.dspace.qaevent.service.QAEventService;
 import org.dspace.services.factory.DSpaceServicesFactory;
 import org.dspace.statistics.MockSolrLoggerServiceImpl;
 import org.dspace.statistics.MockSolrStatisticsCore;
@@ -47,7 +49,7 @@ public class AbstractIntegrationTestWithDatabase extends AbstractDSpaceIntegrati
      * log4j category
      */
     private static final Logger log = LogManager
-        .getLogger(AbstractIntegrationTestWithDatabase.class);
+            .getLogger(AbstractIntegrationTestWithDatabase.class);
 
     /**
      * Context mock object to use in the tests.
@@ -92,7 +94,7 @@ public class AbstractIntegrationTestWithDatabase extends AbstractDSpaceIntegrati
         } catch (SQLException se) {
             log.error("Error initializing database", se);
             fail("Error initializing database: " + se.getMessage()
-                     + (se.getCause() == null ? "" : ": " + se.getCause().getMessage()));
+                    + (se.getCause() == null ? "" : ": " + se.getCause().getMessage()));
         }
     }
 
@@ -196,6 +198,10 @@ public class AbstractIntegrationTestWithDatabase extends AbstractDSpaceIntegrati
                     .getServiceByName(AuthoritySearchService.class.getName(), MockAuthoritySolrServiceImpl.class);
             authorityService.reset();
 
+            MockQAEventService qaEventService = serviceManager
+                    .getServiceByName(QAEventService.class.getName(), MockQAEventService.class);
+            qaEventService.reset();
+
             // Reload our ConfigurationService (to reset configs to defaults again)
             DSpaceServicesFactory.getInstance().getConfigurationService().reloadConfig();
 
diff --git a/dspace-api/src/test/java/org/dspace/app/ldn/LDNMessageConsumerIT.java b/dspace-api/src/test/java/org/dspace/app/ldn/LDNMessageConsumerIT.java
new file mode 100644
index 0000000000..305261c7c3
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/app/ldn/LDNMessageConsumerIT.java
@@ -0,0 +1,456 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn;
+
+import static org.dspace.app.ldn.LDNMessageEntity.QUEUE_STATUS_QUEUED;
+import static org.dspace.matcher.NotifyServiceEntityMatcher.matchesNotifyServiceEntity;
+import static org.hamcrest.CoreMatchers.containsString;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.junit.Assert.assertThat;
+
+import java.io.InputStream;
+import java.sql.SQLException;
+import java.util.List;
+import java.util.Set;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.commons.collections4.CollectionUtils;
+import org.dspace.AbstractIntegrationTestWithDatabase;
+import org.dspace.app.ldn.factory.NotifyServiceFactory;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.EPersonBuilder;
+import org.dspace.builder.NotifyServiceBuilder;
+import org.dspace.builder.NotifyServiceInboundPatternBuilder;
+import org.dspace.builder.WorkspaceItemBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Item;
+import org.dspace.content.WorkspaceItem;
+import org.dspace.content.factory.ContentServiceFactory;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Constants;
+import org.dspace.eperson.EPerson;
+import org.dspace.services.ConfigurationService;
+import org.dspace.services.factory.DSpaceServicesFactory;
+import org.dspace.workflow.WorkflowItem;
+import org.dspace.workflow.WorkflowService;
+import org.dspace.workflow.factory.WorkflowServiceFactory;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Integration Tests against {@link LDNMessageConsumer}
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class LDNMessageConsumerIT extends AbstractIntegrationTestWithDatabase {
+
+    private Collection collection;
+    private EPerson submitter;
+
+    private LDNMessageService ldnMessageService = NotifyServiceFactory.getInstance().getLDNMessageService();
+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();
+    private WorkflowService workflowService = WorkflowServiceFactory.getInstance().getWorkflowService();
+    private ItemService itemService = ContentServiceFactory.getInstance().getItemService();
+
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        context.turnOffAuthorisationSystem();
+        //** GIVEN **
+        //1. create a normal user to use as submitter
+        submitter = EPersonBuilder.createEPerson(context)
+                                          .withEmail("submitter@example.com")
+                                          .withPassword(password)
+                                          .build();
+
+        //2. A community with one collection.
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+
+        collection = CollectionBuilder.createCollection(context, parentCommunity)
+                                                 .withName("Collection 1")
+                                                 .withSubmitterGroup(submitter)
+                                                 .build();
+        context.setCurrentUser(submitter);
+
+        context.restoreAuthSystemState();
+    }
+
+    @Test
+    public void testLDNMessageConsumerRequestReview() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        //3. a workspace item ready to go
+        WorkspaceItem workspaceItem =
+            WorkspaceItemBuilder.createWorkspaceItem(context, collection)
+                                .withTitle("Submission Item")
+                                .withIssueDate("2023-11-20")
+                                .withCOARNotifyService(notifyService, "request-review")
+                                .withFulltext("test.txt", "test", InputStream.nullInputStream())
+                                .grantLicense()
+                                .build();
+
+        WorkflowItem workflowItem = workflowService.start(context, workspaceItem);
+        Item item = workflowItem.getItem();
+        context.dispatchEvents();
+        context.restoreAuthSystemState();
+
+        LDNMessageEntity ldnMessage =
+            ldnMessageService.findAll(context).stream().findFirst().orElse(null);
+
+
+        assertThat(notifyService, matchesNotifyServiceEntity(ldnMessage.getTarget()));
+        assertEquals(workflowItem.getItem().getID(), ldnMessage.getObject().getID());
+        assertEquals(QUEUE_STATUS_QUEUED, ldnMessage.getQueueStatus());
+        assertNull(ldnMessage.getOrigin());
+        assertNotNull(ldnMessage.getMessage());
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(ldnMessage.getMessage(), Notification.class);
+
+        // check id
+        assertThat(notification.getId(), containsString("urn:uuid:"));
+
+        // check object
+        assertEquals(notification.getObject().getId(),
+            configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle());
+        assertEquals(notification.getObject().getIetfCiteAs(),
+            itemService.getMetadataByMetadataString(item, "dc.identifier.uri").get(0).getValue());
+        assertEquals(notification.getObject().getUrl().getId(),
+            configurationService.getProperty("dspace.ui.url") + "/bitstreams/" +
+                item.getBundles(Constants.CONTENT_BUNDLE_NAME).get(0).getBitstreams().get(0).getID() + "/download");
+
+        // check target
+        assertEquals(notification.getTarget().getId(), notifyService.getUrl());
+        assertEquals(notification.getTarget().getInbox(), notifyService.getLdnUrl());
+        assertEquals(notification.getTarget().getType(), Set.of("Service"));
+
+        // check origin
+        assertEquals(notification.getOrigin().getId(), configurationService.getProperty("dspace.ui.url"));
+        assertEquals(notification.getOrigin().getInbox(), configurationService.getProperty("ldn.notify.inbox"));
+        assertEquals(notification.getOrigin().getType(), Set.of("Service"));
+
+        // check actor
+        assertEquals(notification.getActor().getId(), configurationService.getProperty("dspace.ui.url"));
+        assertEquals(notification.getActor().getName(), configurationService.getProperty("dspace.name"));
+        assertEquals(notification.getOrigin().getType(), Set.of("Service"));
+
+        // check types
+        assertEquals(notification.getType(), Set.of("coar-notify:ReviewAction", "Offer"));
+
+    }
+
+    @Test
+    public void testLDNMessageConsumerRequestReviewAutomatic() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyService)
+                                          .withPattern("request-review")
+                                          .withConstraint("simple-demo_filter")
+                                          .isAutomatic(true)
+                                          .build();
+
+        //3. a workspace item ready to go
+        WorkspaceItem workspaceItem =
+            WorkspaceItemBuilder.createWorkspaceItem(context, collection)
+                                .withTitle("demo Item")
+                                .withIssueDate("2023-11-20")
+                                .withFulltext("test.txt", "test", InputStream.nullInputStream())
+                                .grantLicense()
+                                .build();
+
+        WorkflowItem workflowItem = workflowService.start(context, workspaceItem);
+        Item item = workflowItem.getItem();
+        context.dispatchEvents();
+        context.restoreAuthSystemState();
+
+        LDNMessageEntity ldnMessage =
+            ldnMessageService.findAll(context).stream().findFirst().orElse(null);
+
+
+        assertThat(notifyService, matchesNotifyServiceEntity(ldnMessage.getTarget()));
+        assertEquals(workflowItem.getItem().getID(), ldnMessage.getObject().getID());
+        assertEquals(QUEUE_STATUS_QUEUED, ldnMessage.getQueueStatus());
+        assertNull(ldnMessage.getOrigin());
+        assertNotNull(ldnMessage.getMessage());
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(ldnMessage.getMessage(), Notification.class);
+
+        // check id
+        assertThat(notification.getId(), containsString("urn:uuid:"));
+
+        // check object
+        assertEquals(notification.getObject().getId(),
+            configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle());
+        assertEquals(notification.getObject().getIetfCiteAs(),
+            itemService.getMetadataByMetadataString(item, "dc.identifier.uri").get(0).getValue());
+        assertEquals(notification.getObject().getUrl().getId(),
+            configurationService.getProperty("dspace.ui.url") + "/bitstreams/" +
+                item.getBundles(Constants.CONTENT_BUNDLE_NAME).get(0).getBitstreams().get(0).getID() + "/download");
+
+        // check target
+        assertEquals(notification.getTarget().getId(), notifyService.getUrl());
+        assertEquals(notification.getTarget().getInbox(), notifyService.getLdnUrl());
+        assertEquals(notification.getTarget().getType(), Set.of("Service"));
+
+        // check origin
+        assertEquals(notification.getOrigin().getId(), configurationService.getProperty("dspace.ui.url"));
+        assertEquals(notification.getOrigin().getInbox(), configurationService.getProperty("ldn.notify.inbox"));
+        assertEquals(notification.getOrigin().getType(), Set.of("Service"));
+
+        // check actor
+        assertEquals(notification.getActor().getId(), configurationService.getProperty("dspace.ui.url"));
+        assertEquals(notification.getActor().getName(), configurationService.getProperty("dspace.name"));
+        assertEquals(notification.getOrigin().getType(), Set.of("Service"));
+
+        // check types
+        assertEquals(notification.getType(), Set.of("coar-notify:ReviewAction", "Offer"));
+
+    }
+
+    @Test
+    public void testLDNMessageConsumerRequestEndorsement() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        //3. a workspace item ready to go
+        WorkspaceItem workspaceItem =
+            WorkspaceItemBuilder.createWorkspaceItem(context, collection)
+                                .withTitle("Submission Item")
+                                .withIssueDate("2023-11-20")
+                                .withCOARNotifyService(notifyService, "request-endorsement")
+                                .withFulltext("test.txt", "test", InputStream.nullInputStream())
+                                .grantLicense()
+                                .build();
+
+        WorkflowItem workflowItem = workflowService.start(context, workspaceItem);
+        Item item = workflowItem.getItem();
+        context.dispatchEvents();
+        context.restoreAuthSystemState();
+
+        LDNMessageEntity ldnMessage =
+            ldnMessageService.findAll(context).stream().findFirst().orElse(null);
+
+
+        assertThat(notifyService, matchesNotifyServiceEntity(ldnMessage.getTarget()));
+        assertEquals(workflowItem.getItem().getID(), ldnMessage.getObject().getID());
+        assertEquals(QUEUE_STATUS_QUEUED, ldnMessage.getQueueStatus());
+        assertNull(ldnMessage.getOrigin());
+        assertNotNull(ldnMessage.getMessage());
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(ldnMessage.getMessage(), Notification.class);
+
+        // check id
+        assertThat(notification.getId(), containsString("urn:uuid:"));
+
+        // check object
+        assertEquals(notification.getObject().getId(),
+            configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle());
+        assertEquals(notification.getObject().getIetfCiteAs(),
+            itemService.getMetadataByMetadataString(item, "dc.identifier.uri").get(0).getValue());
+        assertEquals(notification.getObject().getUrl().getId(),
+            configurationService.getProperty("dspace.ui.url") + "/bitstreams/" +
+                item.getBundles(Constants.CONTENT_BUNDLE_NAME).get(0).getBitstreams().get(0).getID() + "/download");
+
+        // check target
+        assertEquals(notification.getTarget().getId(), notifyService.getUrl());
+        assertEquals(notification.getTarget().getInbox(), notifyService.getLdnUrl());
+        assertEquals(notification.getTarget().getType(), Set.of("Service"));
+
+        // check origin
+        assertEquals(notification.getOrigin().getId(), configurationService.getProperty("dspace.ui.url"));
+        assertEquals(notification.getOrigin().getInbox(), configurationService.getProperty("ldn.notify.inbox"));
+        assertEquals(notification.getOrigin().getType(), Set.of("Service"));
+
+        // check actor
+        assertEquals(notification.getActor().getId(), configurationService.getProperty("dspace.ui.url"));
+        assertEquals(notification.getActor().getName(), configurationService.getProperty("dspace.name"));
+        assertEquals(notification.getOrigin().getType(), Set.of("Service"));
+
+        // check types
+        assertEquals(notification.getType(), Set.of("coar-notify:EndorsementAction", "Offer"));
+
+    }
+
+    @Test
+    public void testLDNMessageConsumerRequestIngest() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        //3. a workspace item ready to go
+        WorkspaceItem workspaceItem =
+            WorkspaceItemBuilder.createWorkspaceItem(context, collection)
+                                .withTitle("Submission Item")
+                                .withIssueDate("2023-11-20")
+                                .withCOARNotifyService(notifyService, "request-ingest")
+                                .withFulltext("test.txt", "test", InputStream.nullInputStream())
+                                .grantLicense()
+                                .build();
+
+        WorkflowItem workflowItem = workflowService.start(context, workspaceItem);
+        Item item = workflowItem.getItem();
+        context.dispatchEvents();
+        context.restoreAuthSystemState();
+
+        LDNMessageEntity ldnMessage =
+            ldnMessageService.findAll(context).stream().findFirst().orElse(null);
+
+
+        assertThat(notifyService, matchesNotifyServiceEntity(ldnMessage.getTarget()));
+        assertEquals(workflowItem.getItem().getID(), ldnMessage.getObject().getID());
+        assertEquals(QUEUE_STATUS_QUEUED, ldnMessage.getQueueStatus());
+        assertNull(ldnMessage.getOrigin());
+        assertNotNull(ldnMessage.getMessage());
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(ldnMessage.getMessage(), Notification.class);
+
+        // check id
+        assertThat(notification.getId(), containsString("urn:uuid:"));
+
+        // check object
+        assertEquals(notification.getObject().getId(),
+            configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle());
+        assertEquals(notification.getObject().getIetfCiteAs(),
+            itemService.getMetadataByMetadataString(item, "dc.identifier.uri").get(0).getValue());
+        assertEquals(notification.getObject().getUrl().getId(),
+            configurationService.getProperty("dspace.ui.url") + "/bitstreams/" +
+                item.getBundles(Constants.CONTENT_BUNDLE_NAME).get(0).getBitstreams().get(0).getID() + "/download");
+
+        // check target
+        assertEquals(notification.getTarget().getId(), notifyService.getUrl());
+        assertEquals(notification.getTarget().getInbox(), notifyService.getLdnUrl());
+        assertEquals(notification.getTarget().getType(), Set.of("Service"));
+
+        // check origin
+        assertEquals(notification.getOrigin().getId(), configurationService.getProperty("dspace.ui.url"));
+        assertEquals(notification.getOrigin().getInbox(), configurationService.getProperty("ldn.notify.inbox"));
+        assertEquals(notification.getOrigin().getType(), Set.of("Service"));
+
+        // check actor
+        assertEquals(notification.getActor().getId(), configurationService.getProperty("dspace.ui.url"));
+        assertEquals(notification.getActor().getName(), configurationService.getProperty("dspace.name"));
+        assertEquals(notification.getOrigin().getType(), Set.of("Service"));
+
+        // check types
+        assertEquals(notification.getType(), Set.of("coar-notify:IngestAction", "Offer"));
+
+    }
+
+    @Test
+    public void testLDNMessageConsumerRequestFake() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        //3. a workspace item ready to go
+        WorkspaceItem workspaceItem =
+            WorkspaceItemBuilder.createWorkspaceItem(context, collection)
+                                .withTitle("Submission Item")
+                                .withIssueDate("2023-11-20")
+                                .withCOARNotifyService(notifyService, "request-fake")
+                                .withFulltext("test.txt", "test", InputStream.nullInputStream())
+                                .grantLicense()
+                                .build();
+
+        workflowService.start(context, workspaceItem);
+        context.dispatchEvents();
+        context.restoreAuthSystemState();
+
+        LDNMessageEntity ldnMessage =
+            ldnMessageService.findAll(context).stream().findFirst().orElse(null);
+
+        assertNull(ldnMessage);
+
+    }
+
+    @Test
+    public void testLDNMessageConsumerNoRequests() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        //3. a workspace item ready to go
+        WorkspaceItem workspaceItem =
+            WorkspaceItemBuilder.createWorkspaceItem(context, collection)
+                                .withTitle("Submission Item")
+                                .withIssueDate("2023-11-20")
+                                .grantLicense()
+                                .build();
+
+        workflowService.start(context, workspaceItem);
+        context.dispatchEvents();
+        context.restoreAuthSystemState();
+
+        LDNMessageEntity ldnMessage =
+            ldnMessageService.findAll(context).stream().findFirst().orElse(null);
+
+        assertNull(ldnMessage);
+    }
+
+    @Override
+    @After
+    public void destroy() throws Exception {
+        List<LDNMessageEntity> ldnMessageEntities = ldnMessageService.findAll(context);
+        if (CollectionUtils.isNotEmpty(ldnMessageEntities)) {
+            ldnMessageEntities.forEach(ldnMessage -> {
+                try {
+                    ldnMessageService.delete(context, ldnMessage);
+                } catch (SQLException e) {
+                    throw new RuntimeException(e);
+                }
+            });
+        }
+
+        super.destroy();
+    }
+}
+
diff --git a/dspace-api/src/test/java/org/dspace/app/ldn/action/SendLDNMessageActionIT.java b/dspace-api/src/test/java/org/dspace/app/ldn/action/SendLDNMessageActionIT.java
new file mode 100644
index 0000000000..b1a6db4a07
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/app/ldn/action/SendLDNMessageActionIT.java
@@ -0,0 +1,255 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.ldn.action;
+
+import static org.dspace.app.ldn.action.LDNActionStatus.ABORT;
+import static org.dspace.app.ldn.action.LDNActionStatus.CONTINUE;
+import static org.junit.Assert.assertEquals;
+import static org.mockito.Mockito.any;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.io.InputStream;
+import java.sql.SQLException;
+import java.util.List;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.commons.collections4.CollectionUtils;
+import org.apache.http.HttpStatus;
+import org.apache.http.StatusLine;
+import org.apache.http.client.methods.CloseableHttpResponse;
+import org.apache.http.client.methods.HttpPost;
+import org.apache.http.impl.client.CloseableHttpClient;
+import org.apache.http.message.BasicStatusLine;
+import org.dspace.AbstractIntegrationTestWithDatabase;
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.factory.NotifyServiceFactory;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.EPersonBuilder;
+import org.dspace.builder.NotifyServiceBuilder;
+import org.dspace.builder.WorkspaceItemBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Item;
+import org.dspace.content.WorkspaceItem;
+import org.dspace.eperson.EPerson;
+import org.dspace.services.ConfigurationService;
+import org.dspace.services.factory.DSpaceServicesFactory;
+import org.dspace.workflow.WorkflowItem;
+import org.dspace.workflow.WorkflowService;
+import org.dspace.workflow.factory.WorkflowServiceFactory;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Integration Tests against {@link SendLDNMessageAction}
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class SendLDNMessageActionIT extends AbstractIntegrationTestWithDatabase {
+
+    private Collection collection;
+    private EPerson submitter;
+    private ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();
+    private LDNMessageService ldnMessageService = NotifyServiceFactory.getInstance().getLDNMessageService();
+    private WorkflowService workflowService = WorkflowServiceFactory.getInstance().getWorkflowService();
+    private SendLDNMessageAction sendLDNMessageAction;
+
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        configurationService.setProperty("ldn.enabled", "true");
+        sendLDNMessageAction = new SendLDNMessageAction();
+        context.turnOffAuthorisationSystem();
+        //** GIVEN **
+        //1. create a normal user to use as submitter
+        submitter = EPersonBuilder.createEPerson(context)
+                                          .withEmail("submitter@example.com")
+                                          .withPassword(password)
+                                          .build();
+
+        //2. A community with one collection.
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+
+        collection = CollectionBuilder.createCollection(context, parentCommunity)
+                                                 .withName("Collection 1")
+                                                 .withSubmitterGroup(submitter)
+                                                 .build();
+        context.setCurrentUser(submitter);
+
+        context.restoreAuthSystemState();
+    }
+
+    @Test
+    public void testLDNMessageConsumerRequestReview() throws Exception {
+        CloseableHttpResponse response = mock(CloseableHttpResponse.class);
+        StatusLine sl = mock(BasicStatusLine.class);
+        when(response.getStatusLine()).thenReturn(sl);
+        when(sl.getStatusCode()).thenReturn(HttpStatus.SC_ACCEPTED);
+        CloseableHttpClient mockedClient = mock(CloseableHttpClient.class);
+        when(mockedClient.execute(any(HttpPost.class))).
+        thenReturn(response);
+        ObjectMapper mapper = new ObjectMapper();
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://www.notify-inbox.info/")
+                                .withLdnUrl("https://notify-inbox.info/inbox/")
+                                .build();
+
+        //3. a workspace item ready to go
+        WorkspaceItem workspaceItem =
+            WorkspaceItemBuilder.createWorkspaceItem(context, collection)
+                                .withTitle("Submission Item")
+                                .withIssueDate("2023-11-20")
+                                .withCOARNotifyService(notifyService, "request-review")
+                                .withFulltext("test.txt", "test", InputStream.nullInputStream())
+                                .grantLicense()
+                                .build();
+
+        WorkflowItem workflowItem = workflowService.start(context, workspaceItem);
+        Item item = workflowItem.getItem();
+        context.dispatchEvents();
+        context.restoreAuthSystemState();
+
+        LDNMessageEntity ldnMessage =
+            ldnMessageService.findAll(context).stream().findFirst().orElse(null);
+
+        ldnMessage.getQueueStatus();
+
+        Notification notification = mapper.readValue(ldnMessage.getMessage(), Notification.class);
+
+        sendLDNMessageAction = new SendLDNMessageAction(mockedClient);
+        assertEquals(sendLDNMessageAction.execute(context, notification, item), CONTINUE);
+        mockedClient.close();
+        response.close();
+    }
+
+    @Test
+    public void testLDNMessageConsumerRequestReviewGotRedirection() throws Exception {
+        CloseableHttpResponse response = mock(CloseableHttpResponse.class);
+        StatusLine sl = mock(BasicStatusLine.class);
+        when(response.getStatusLine()).thenReturn(sl);
+        when(sl.getStatusCode()).thenReturn(HttpStatus.SC_ACCEPTED);
+        CloseableHttpClient mockedClient = mock(CloseableHttpClient.class);
+        when(mockedClient.execute(any(HttpPost.class))).
+        thenReturn(response);
+        ObjectMapper mapper = new ObjectMapper();
+
+        context.turnOffAuthorisationSystem();
+
+        // ldnUrl should be https://notify-inbox.info/inbox/
+        // but used https://notify-inbox.info/inbox for redirection
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://www.notify-inbox.info/")
+                                .withLdnUrl("https://notify-inbox.info/inbox")
+                                .build();
+
+        //3. a workspace item ready to go
+        WorkspaceItem workspaceItem =
+            WorkspaceItemBuilder.createWorkspaceItem(context, collection)
+                                .withTitle("Submission Item")
+                                .withIssueDate("2023-11-20")
+                                .withCOARNotifyService(notifyService, "request-review")
+                                .withFulltext("test.txt", "test", InputStream.nullInputStream())
+                                .grantLicense()
+                                .build();
+
+        WorkflowItem workflowItem = workflowService.start(context, workspaceItem);
+        Item item = workflowItem.getItem();
+        context.dispatchEvents();
+        context.restoreAuthSystemState();
+
+        LDNMessageEntity ldnMessage =
+            ldnMessageService.findAll(context).stream().findFirst().orElse(null);
+
+        Notification notification = mapper.readValue(ldnMessage.getMessage(), Notification.class);
+
+        sendLDNMessageAction = new SendLDNMessageAction(mockedClient);
+        assertEquals(sendLDNMessageAction.execute(context, notification, item), CONTINUE);
+        mockedClient.close();
+        response.close();
+    }
+
+    @Test
+    public void testLDNMessageConsumerRequestReviewWithInvalidLdnUrl() throws Exception {
+        CloseableHttpResponse response = mock(CloseableHttpResponse.class);
+        StatusLine sl = mock(BasicStatusLine.class);
+        when(response.getStatusLine()).thenReturn(sl);
+        when(sl.getStatusCode()).thenReturn(HttpStatus.SC_NOT_FOUND);
+        CloseableHttpClient mockedClient = mock(CloseableHttpClient.class);
+        when(mockedClient.execute(any(HttpPost.class))).
+        thenReturn(response);
+        ObjectMapper mapper = new ObjectMapper();
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://www.notify-inbox.info/")
+                                .withLdnUrl("https://notify-inbox.info/invalidLdnUrl/")
+                                .build();
+
+        //3. a workspace item ready to go
+        WorkspaceItem workspaceItem =
+            WorkspaceItemBuilder.createWorkspaceItem(context, collection)
+                                .withTitle("Submission Item")
+                                .withIssueDate("2023-11-20")
+                                .withCOARNotifyService(notifyService, "request-review")
+                                .withFulltext("test.txt", "test", InputStream.nullInputStream())
+                                .grantLicense()
+                                .build();
+
+        WorkflowItem workflowItem = workflowService.start(context, workspaceItem);
+        Item item = workflowItem.getItem();
+        context.dispatchEvents();
+        context.restoreAuthSystemState();
+
+        LDNMessageEntity ldnMessage =
+            ldnMessageService.findAll(context).stream().findFirst().orElse(null);
+
+        Notification notification = mapper.readValue(ldnMessage.getMessage(), Notification.class);
+        sendLDNMessageAction = new SendLDNMessageAction(mockedClient);
+        assertEquals(sendLDNMessageAction.execute(context, notification, item), ABORT);
+        mockedClient.close();
+        response.close();
+    }
+
+    @Override
+    @After
+    public void destroy() throws Exception {
+        List<LDNMessageEntity> ldnMessageEntities = ldnMessageService.findAll(context);
+        if (CollectionUtils.isNotEmpty(ldnMessageEntities)) {
+            ldnMessageEntities.forEach(ldnMessage -> {
+                try {
+                    ldnMessageService.delete(context, ldnMessage);
+                } catch (SQLException e) {
+                    throw new RuntimeException(e);
+                }
+            });
+        }
+
+        super.destroy();
+    }
+}
+
diff --git a/dspace-api/src/test/java/org/dspace/app/suggestion/MockSolrSuggestionProvider.java b/dspace-api/src/test/java/org/dspace/app/suggestion/MockSolrSuggestionProvider.java
new file mode 100644
index 0000000000..af890da455
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/app/suggestion/MockSolrSuggestionProvider.java
@@ -0,0 +1,20 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.core.Context;
+import org.dspace.external.model.ExternalDataObject;
+
+public class MockSolrSuggestionProvider extends SolrSuggestionProvider {
+
+    @Override
+    protected boolean isExternalDataObjectPotentiallySuggested(Context context, ExternalDataObject externalDataObject) {
+        return StringUtils.equals(MockSuggestionExternalDataSource.NAME, externalDataObject.getSource());
+    }
+}
diff --git a/dspace-api/src/test/java/org/dspace/app/suggestion/MockSolrSuggestionStorageService.java b/dspace-api/src/test/java/org/dspace/app/suggestion/MockSolrSuggestionStorageService.java
new file mode 100644
index 0000000000..1c843026d4
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/app/suggestion/MockSolrSuggestionStorageService.java
@@ -0,0 +1,38 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import org.dspace.solr.MockSolrServer;
+import org.springframework.beans.factory.DisposableBean;
+import org.springframework.beans.factory.InitializingBean;
+import org.springframework.stereotype.Service;
+
+/**
+ * Mock SOLR service for the suggestion Core.
+ */
+@Service
+public class MockSolrSuggestionStorageService extends SolrSuggestionStorageServiceImpl
+        implements InitializingBean, DisposableBean {
+    private MockSolrServer mockSolrServer;
+
+    @Override
+    public void afterPropertiesSet() throws Exception {
+        mockSolrServer = new MockSolrServer("suggestion");
+        solrSuggestionClient = mockSolrServer.getSolrServer();
+    }
+
+    /** Clear all records from the search core. */
+    public void reset() {
+        mockSolrServer.reset();
+    }
+
+    @Override
+    public void destroy() throws Exception {
+        mockSolrServer.destroy();
+    }
+}
\ No newline at end of file
diff --git a/dspace-api/src/test/java/org/dspace/app/suggestion/MockSuggestionExternalDataSource.java b/dspace-api/src/test/java/org/dspace/app/suggestion/MockSuggestionExternalDataSource.java
new file mode 100644
index 0000000000..cf0303debd
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/app/suggestion/MockSuggestionExternalDataSource.java
@@ -0,0 +1,67 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import java.util.List;
+import java.util.Optional;
+
+import org.apache.commons.codec.binary.StringUtils;
+import org.dspace.core.Context;
+import org.dspace.external.model.ExternalDataObject;
+import org.dspace.external.provider.AbstractExternalDataProvider;
+import org.dspace.services.RequestService;
+import org.dspace.services.model.Request;
+import org.dspace.utils.DSpace;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+@Component
+public class MockSuggestionExternalDataSource extends AbstractExternalDataProvider {
+    public static final String NAME = "suggestion";
+
+    @Autowired
+    private SuggestionService suggestionService;
+
+    @Override
+    public String getSourceIdentifier() {
+        return NAME;
+    }
+
+    @Override
+    public Optional<ExternalDataObject> getExternalDataObject(String id) {
+        RequestService requestService = new DSpace().getRequestService();
+        Request currentRequest = requestService.getCurrentRequest();
+        Context context = (Context) currentRequest.getAttribute("dspace.context");
+        Suggestion suggestion = suggestionService.findUnprocessedSuggestion(context, id);
+        if (suggestion != null) {
+            ExternalDataObject extDataObj = new ExternalDataObject(NAME);
+            extDataObj.setDisplayValue(suggestion.getDisplay());
+            extDataObj.setId(suggestion.getExternalSourceUri()
+                    .substring(suggestion.getExternalSourceUri().lastIndexOf("/") + 1));
+            extDataObj.setMetadata(suggestion.getMetadata());
+            return Optional.of(extDataObj);
+        }
+        return null;
+    }
+
+    @Override
+    public List<ExternalDataObject> searchExternalDataObjects(String query, int start, int limit) {
+        return null;
+    }
+
+    @Override
+    public boolean supports(String source) {
+        return StringUtils.equals(NAME, source);
+    }
+
+    @Override
+    public int getNumberOfResults(String query) {
+        return 0;
+    }
+
+}
diff --git a/dspace-api/src/test/java/org/dspace/app/suggestion/SuggestionUtilsIT.java b/dspace-api/src/test/java/org/dspace/app/suggestion/SuggestionUtilsIT.java
new file mode 100644
index 0000000000..dd9c0d8f5f
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/app/suggestion/SuggestionUtilsIT.java
@@ -0,0 +1,218 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.suggestion;
+
+import static java.util.Optional.of;
+import static org.dspace.app.suggestion.SuggestionUtils.getFirstEntryByMetadatum;
+import static org.dspace.orcid.model.OrcidProfileSectionType.EXTERNAL_IDS;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.greaterThan;
+import static org.junit.Assert.assertTrue;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.when;
+
+import java.io.File;
+import java.net.URL;
+import java.util.Date;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Optional;
+import javax.xml.bind.JAXBContext;
+import javax.xml.bind.Unmarshaller;
+
+import org.apache.commons.collections.CollectionUtils;
+import org.dspace.AbstractIntegrationTestWithDatabase;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Item;
+import org.dspace.content.MetadataValue;
+import org.dspace.content.dto.MetadataValueDTO;
+import org.dspace.content.factory.ContentServiceFactory;
+import org.dspace.content.service.ItemService;
+import org.dspace.external.factory.ExternalServiceFactory;
+import org.dspace.external.model.ExternalDataObject;
+import org.dspace.external.provider.ExternalDataProvider;
+import org.dspace.external.provider.impl.OrcidPublicationDataProvider;
+import org.dspace.external.service.ExternalDataService;
+import org.dspace.kernel.ServiceManager;
+import org.dspace.orcid.client.OrcidClient;
+import org.dspace.orcid.client.OrcidConfiguration;
+import org.dspace.orcid.factory.OrcidServiceFactory;
+import org.dspace.orcid.model.OrcidTokenResponseDTO;
+import org.dspace.orcid.service.OrcidProfileSectionFactoryService;
+import org.dspace.services.ConfigurationService;
+import org.dspace.services.factory.DSpaceServicesFactory;
+import org.dspace.utils.DSpace;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Test;
+import org.orcid.jaxb.model.v3.release.record.Work;
+import org.orcid.jaxb.model.v3.release.record.WorkBulk;
+import org.orcid.jaxb.model.v3.release.record.summary.Works;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Tests for suggestion utilities @see SuggestionUtils
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ */
+public class SuggestionUtilsIT extends AbstractIntegrationTestWithDatabase  {
+
+    private static ConfigurationService cfg;
+    private static final String ORCID = "0000-1111-2222-3333";
+    private static final String ACCESS_TOKEN = "32c83ccb-c6d5-4981-b6ea-6a34a36de8ab";
+    private static final String BASE_XML_DIR_PATH = "org/dspace/app/orcid-works/";
+    private OrcidPublicationDataProvider dataProvider;
+    private SolrSuggestionProvider solrSuggestionProvider;
+    private OrcidProfileSectionFactoryService profileSectionFactoryService;
+    private ItemService itemService;
+    private Collection collection;
+    private ExternalDataProvider primaryProvider;
+    private Collection persons;
+    private OrcidConfiguration orcidConfiguration;
+    private OrcidClient orcidClientMock;
+    private OrcidClient orcidClient;
+    private String originalClientId;
+
+    @Autowired
+    private SuggestionService suggestionService;
+
+    @Before
+    public void setup() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        parentCommunity = CommunityBuilder.createCommunity(context)
+            .withName("Parent Community")
+            .build();
+
+        persons = CollectionBuilder.createCollection(context, parentCommunity)
+            .withEntityType("Person")
+            .withName("Profiles")
+            .build();
+
+        profileSectionFactoryService = OrcidServiceFactory.getInstance().getOrcidProfileSectionFactoryService();
+        itemService = ContentServiceFactory.getInstance().getItemService();
+
+        context.restoreAuthSystemState();
+
+        cfg = DSpaceServicesFactory.getInstance().getConfigurationService();
+
+        ServiceManager serviceManager = DSpaceServicesFactory.getInstance().getServiceManager();
+        HashMap<String,SuggestionProvider> providers = serviceManager.getServiceByName("suggestionProviders",
+            HashMap.class);
+        solrSuggestionProvider = (SolrSuggestionProvider) providers.get("scopus");
+        dataProvider = new DSpace().getServiceManager()
+            .getServiceByName("orcidPublicationDataProvider", OrcidPublicationDataProvider.class);
+        ExternalDataService externalDataService = ExternalServiceFactory.getInstance().getExternalDataService();
+        primaryProvider = externalDataService.getExternalDataProvider("openaireFunding");
+
+        orcidConfiguration = new DSpace().getServiceManager()
+            .getServiceByName("org.dspace.orcid.client.OrcidConfiguration", OrcidConfiguration.class);
+
+        orcidClientMock = mock(OrcidClient.class);
+        orcidClient = dataProvider.getOrcidClient();
+
+        dataProvider.setReadPublicAccessToken(null);
+        dataProvider.setOrcidClient(orcidClientMock);
+
+        originalClientId = orcidConfiguration.getClientId();
+        orcidConfiguration.setClientId("DSPACE-CLIENT-ID");
+        orcidConfiguration.setClientSecret("DSPACE-CLIENT-SECRET");
+
+        when(orcidClientMock.getReadPublicAccessToken()).thenReturn(buildTokenResponse(ACCESS_TOKEN));
+
+        when(orcidClientMock.getWorks(any(), eq(ORCID))).thenReturn(unmarshall("works.xml", Works.class));
+        when(orcidClientMock.getWorks(eq(ORCID))).thenReturn(unmarshall("works.xml", Works.class));
+
+        when(orcidClientMock.getObject(any(), eq(ORCID), any(), eq(Work.class)))
+            .then((invocation) -> of(unmarshall("work-" + invocation.getArgument(2) + ".xml", Work.class)));
+        when(orcidClientMock.getObject(eq(ORCID), any(), eq(Work.class)))
+            .then((invocation) -> of(unmarshall("work-" + invocation.getArgument(1) + ".xml", Work.class)));
+
+        when(orcidClientMock.getWorkBulk(any(), eq(ORCID), any()))
+            .then((invocation) -> unmarshallWorkBulk(invocation.getArgument(2)));
+        when(orcidClientMock.getWorkBulk(eq(ORCID), any()))
+            .then((invocation) -> unmarshallWorkBulk(invocation.getArgument(1)));
+    }
+
+    @After
+    public void after() {
+        dataProvider.setOrcidClient(orcidClient);
+        orcidConfiguration.setClientId(originalClientId);
+    }
+
+    @Test
+    public void testGetAllEntriesByMetadatum() {
+        context.turnOffAuthorisationSystem();
+        Item item = ItemBuilder.createItem(context, persons)
+            .withTitle("Test profile")
+            .withScopusAuthorIdentifier("SCOPUS-123456")
+            .withResearcherIdentifier("R-ID-01")
+            .build();
+        context.restoreAuthSystemState();
+
+        List<MetadataValue> values = List.of(getMetadata(item, "person.identifier.scopus-author-id", 0));
+
+        Object firstOrcidObject = profileSectionFactoryService.createOrcidObject(context, values, EXTERNAL_IDS);
+        Optional<ExternalDataObject> optional = dataProvider.getExternalDataObject(ORCID + "::277902");
+
+        ExternalDataObject externalDataObject = optional.get();
+        String openAireId = externalDataObject.getId();
+        Suggestion suggestion = new Suggestion(solrSuggestionProvider.getSourceName(), item, openAireId);
+        suggestion.getMetadata().add(
+                new MetadataValueDTO("dc", "title", null, null, "dcTitle"));
+        suggestion.setDisplay(getFirstEntryByMetadatum(externalDataObject, "dc", "title", null));
+        suggestion.getMetadata().add(new MetadataValueDTO("dc", "date", "issued", null, new Date().toString()));
+        suggestion.getMetadata().add(new MetadataValueDTO("dc", "description", "abstract", null, "description"));
+        suggestion.setExternalSourceUri(cfg.getProperty("dspace.server.url")
+                + "/api/integration/externalsources/" + primaryProvider.getSourceIdentifier() + "/entryValues/"
+                + openAireId);
+        List<String> result = SuggestionUtils.getAllEntriesByMetadatum(externalDataObject, "dc", "title", null);
+
+        assertTrue(result != null && !result.isEmpty());
+
+        assertTrue(CollectionUtils.isEqualCollection(
+            SuggestionUtils.getAllEntriesByMetadatum(externalDataObject, "dc.title"),
+            result));
+
+        String firstResult = SuggestionUtils.getFirstEntryByMetadatum(externalDataObject, "dc", "title", null);
+        assertTrue("Another cautionary tale.".equalsIgnoreCase(firstResult));
+        firstResult = SuggestionUtils.getFirstEntryByMetadatum(externalDataObject, "dc.title");
+        assertTrue("Another cautionary tale.".equalsIgnoreCase(firstResult));
+    }
+
+    private MetadataValue getMetadata(Item item, String metadataField, int place) {
+        List<MetadataValue> values = itemService.getMetadataByMetadataString(item, metadataField);
+        assertThat(values.size(), greaterThan(place));
+        return values.get(place);
+    }
+
+    private OrcidTokenResponseDTO buildTokenResponse(String accessToken) {
+        OrcidTokenResponseDTO response = new OrcidTokenResponseDTO();
+        response.setAccessToken(accessToken);
+        return response;
+    }
+
+    private WorkBulk unmarshallWorkBulk(List<String> putCodes) throws Exception {
+        return unmarshall("workBulk-" + String.join("-", putCodes) + ".xml", WorkBulk.class);
+    }
+
+    @SuppressWarnings("unchecked")
+    private <T> T unmarshall(String fileName, Class<T> clazz) throws Exception {
+        JAXBContext jaxbContext = JAXBContext.newInstance(clazz);
+        Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();
+        URL resource = getClass().getClassLoader().getResource(BASE_XML_DIR_PATH + fileName);
+        if (resource == null) {
+            throw new IllegalStateException("No resource found named " + BASE_XML_DIR_PATH + fileName);
+        }
+        return (T) unmarshaller.unmarshal(new File(resource.getFile()));
+    }
+}
diff --git a/dspace-api/src/test/java/org/dspace/builder/AbstractBuilder.java b/dspace-api/src/test/java/org/dspace/builder/AbstractBuilder.java
index f84d17fc7a..5c18835c4f 100644
--- a/dspace-api/src/test/java/org/dspace/builder/AbstractBuilder.java
+++ b/dspace-api/src/test/java/org/dspace/builder/AbstractBuilder.java
@@ -14,8 +14,14 @@ import org.apache.commons.collections4.CollectionUtils;
 import org.apache.logging.log4j.LogManager;
 import org.apache.logging.log4j.Logger;
 import org.dspace.alerts.service.SystemWideAlertService;
+import org.dspace.app.ldn.factory.NotifyServiceFactory;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.ldn.service.NotifyPatternToTriggerService;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
 import org.dspace.app.requestitem.factory.RequestItemServiceFactory;
 import org.dspace.app.requestitem.service.RequestItemService;
+import org.dspace.app.suggestion.SolrSuggestionStorageService;
 import org.dspace.app.util.SubmissionConfigReaderException;
 import org.dspace.authorize.AuthorizeException;
 import org.dspace.authorize.factory.AuthorizeServiceFactory;
@@ -49,6 +55,7 @@ import org.dspace.orcid.factory.OrcidServiceFactory;
 import org.dspace.orcid.service.OrcidHistoryService;
 import org.dspace.orcid.service.OrcidQueueService;
 import org.dspace.orcid.service.OrcidTokenService;
+import org.dspace.qaevent.service.QAEventService;
 import org.dspace.scripts.factory.ScriptServiceFactory;
 import org.dspace.scripts.service.ProcessService;
 import org.dspace.services.factory.DSpaceServicesFactory;
@@ -56,6 +63,7 @@ import org.dspace.submit.factory.SubmissionServiceFactory;
 import org.dspace.submit.service.SubmissionConfigService;
 import org.dspace.supervision.factory.SupervisionOrderServiceFactory;
 import org.dspace.supervision.service.SupervisionOrderService;
+import org.dspace.utils.DSpace;
 import org.dspace.versioning.factory.VersionServiceFactory;
 import org.dspace.versioning.service.VersionHistoryService;
 import org.dspace.versioning.service.VersioningService;
@@ -113,7 +121,13 @@ public abstract class AbstractBuilder<T, S> {
     static SubmissionConfigService submissionConfigService;
     static SubscribeService subscribeService;
     static SupervisionOrderService supervisionOrderService;
+    static NotifyService notifyService;
+    static NotifyServiceInboundPatternService inboundPatternService;
+    static NotifyPatternToTriggerService notifyPatternToTriggerService;
 
+    static QAEventService qaEventService;
+    static SolrSuggestionStorageService solrSuggestionService;
+    static LDNMessageService ldnMessageService;
 
     protected Context context;
 
@@ -182,6 +196,12 @@ public abstract class AbstractBuilder<T, S> {
         }
         subscribeService = ContentServiceFactory.getInstance().getSubscribeService();
         supervisionOrderService = SupervisionOrderServiceFactory.getInstance().getSupervisionOrderService();
+        notifyService = NotifyServiceFactory.getInstance().getNotifyService();
+        inboundPatternService = NotifyServiceFactory.getInstance().getNotifyServiceInboundPatternService();
+        notifyPatternToTriggerService = NotifyServiceFactory.getInstance().getNotifyPatternToTriggerService();
+        qaEventService = new DSpace().getSingletonService(QAEventService.class);
+        solrSuggestionService = new DSpace().getSingletonService(SolrSuggestionStorageService.class);
+        ldnMessageService = NotifyServiceFactory.getInstance().getLDNMessageService();
     }
 
 
@@ -219,6 +239,11 @@ public abstract class AbstractBuilder<T, S> {
         submissionConfigService = null;
         subscribeService = null;
         supervisionOrderService = null;
+        notifyService = null;
+        inboundPatternService = null;
+        notifyPatternToTriggerService = null;
+        qaEventService = null;
+        ldnMessageService = null;
 
     }
 
diff --git a/dspace-api/src/test/java/org/dspace/builder/ItemBuilder.java b/dspace-api/src/test/java/org/dspace/builder/ItemBuilder.java
index 3e5ab0f38f..87efc2d2e1 100644
--- a/dspace-api/src/test/java/org/dspace/builder/ItemBuilder.java
+++ b/dspace-api/src/test/java/org/dspace/builder/ItemBuilder.java
@@ -185,6 +185,10 @@ public class ItemBuilder extends AbstractDSpaceObjectBuilder<Item> {
         return addMetadataValue(item, "iiif", "image", "height", String.valueOf(i));
     }
 
+    public ItemBuilder withDSpaceObjectOwner(String name, String authority) {
+        return addMetadataValue(item, "dspace", "object", "owner", null, name, authority, 600);
+    }
+
     public ItemBuilder withMetadata(final String schema, final String element, final String qualifier,
         final String value) {
         return addMetadataValue(item, schema, element, qualifier, value);
@@ -281,8 +285,8 @@ public class ItemBuilder extends AbstractDSpaceObjectBuilder<Item> {
     }
 
     /**
-     * Withdrawn the item under build. Please note that an user need to be loggedin the context to avoid NPE during the
-     * creation of the provenance metadata
+     * Withdraw the item under build. Please note that the Context must be
+     * logged in to avoid NPE during the creation of the provenance metadata.
      *
      * @return the ItemBuilder
      */
diff --git a/dspace-api/src/test/java/org/dspace/builder/LDNMessageBuilder.java b/dspace-api/src/test/java/org/dspace/builder/LDNMessageBuilder.java
new file mode 100644
index 0000000000..1ed3694573
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/builder/LDNMessageBuilder.java
@@ -0,0 +1,127 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.builder;
+
+import java.sql.SQLException;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.core.Context;
+import org.dspace.discovery.SearchServiceException;
+
+/**
+ * Builder for {@link LDNMessageEntity} entities.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ *
+ */
+public class LDNMessageBuilder extends AbstractBuilder<LDNMessageEntity, LDNMessageService> {
+
+    /* Log4j logger*/
+    private static final Logger log = LogManager.getLogger();
+
+    private LDNMessageEntity ldnMessageEntity;
+
+    protected LDNMessageBuilder(Context context) {
+        super(context);
+    }
+
+    @Override
+    protected LDNMessageService getService() {
+        return ldnMessageService;
+    }
+
+    @Override
+    public void cleanup() throws Exception {
+        try (Context c = new Context()) {
+            c.setDispatcher("noindex");
+            c.turnOffAuthorisationSystem();
+            // Ensure object and any related objects are reloaded before checking to see what needs cleanup
+            ldnMessageEntity = c.reloadEntity(ldnMessageEntity);
+            if (ldnMessageEntity != null) {
+                delete(ldnMessageEntity);
+            }
+            c.complete();
+            indexingService.commit();
+        }
+    }
+
+    @Override
+    public void delete(Context c, LDNMessageEntity ldnMessageEntity) throws Exception {
+        if (ldnMessageEntity != null) {
+            getService().delete(c, ldnMessageEntity);
+        }
+    }
+
+    @Override
+    public LDNMessageEntity build() {
+        try {
+
+            ldnMessageService.update(context, ldnMessageEntity);
+            context.dispatchEvents();
+
+            indexingService.commit();
+        } catch (SearchServiceException | SQLException e) {
+            log.error(e);
+        }
+        return ldnMessageEntity;
+    }
+
+    public void delete(LDNMessageEntity ldnMessageEntity) throws Exception {
+        try (Context c = new Context()) {
+            c.turnOffAuthorisationSystem();
+            LDNMessageEntity nsEntity = c.reloadEntity(ldnMessageEntity);
+            if (nsEntity != null) {
+                getService().delete(c, nsEntity);
+            }
+            c.complete();
+        }
+
+        indexingService.commit();
+    }
+
+    public static LDNMessageBuilder createNotifyServiceBuilder(Context context, String id) {
+        LDNMessageBuilder ldnMessageServiceBuilder = new LDNMessageBuilder(context);
+        return ldnMessageServiceBuilder.create(context, id);
+    }
+
+    public static LDNMessageBuilder createNotifyServiceBuilder(Context context, Notification notification) {
+        LDNMessageBuilder ldnMessageServiceBuilder = new LDNMessageBuilder(context);
+        return ldnMessageServiceBuilder.create(context, notification);
+    }
+
+    private LDNMessageBuilder create(Context context, String id) {
+        try {
+
+            this.context = context;
+            this.ldnMessageEntity = ldnMessageService.create(context, id);
+
+        } catch (SQLException e) {
+            log.warn("Failed to create the NotifyService", e);
+        }
+
+        return this;
+    }
+
+    private LDNMessageBuilder create(Context context, Notification notification) {
+        try {
+
+            this.context = context;
+            this.ldnMessageEntity = ldnMessageService.create(context, notification, "127.0.0.1");
+
+        } catch (SQLException e) {
+            log.warn("Failed to create the NotifyService", e);
+        }
+
+        return this;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/test/java/org/dspace/builder/NotifyServiceBuilder.java b/dspace-api/src/test/java/org/dspace/builder/NotifyServiceBuilder.java
new file mode 100644
index 0000000000..e71dbb211e
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/builder/NotifyServiceBuilder.java
@@ -0,0 +1,154 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.builder;
+
+import java.math.BigDecimal;
+import java.sql.SQLException;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.core.Context;
+import org.dspace.discovery.SearchServiceException;
+
+/**
+ * Builder for {@link NotifyServiceEntity} entities.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ *
+ */
+public class NotifyServiceBuilder extends AbstractBuilder<NotifyServiceEntity, NotifyService> {
+
+    /* Log4j logger*/
+    private static final Logger log = LogManager.getLogger();
+
+    private NotifyServiceEntity notifyServiceEntity;
+
+    protected NotifyServiceBuilder(Context context) {
+        super(context);
+    }
+
+    @Override
+    protected NotifyService getService() {
+        return notifyService;
+    }
+
+    @Override
+    public void cleanup() throws Exception {
+        try (Context c = new Context()) {
+            c.setDispatcher("noindex");
+            c.turnOffAuthorisationSystem();
+            // Ensure object and any related objects are reloaded before checking to see what needs cleanup
+            notifyServiceEntity = c.reloadEntity(notifyServiceEntity);
+            if (notifyServiceEntity != null) {
+                delete(notifyServiceEntity);
+            }
+            c.complete();
+            indexingService.commit();
+        }
+    }
+
+    @Override
+    public void delete(Context c, NotifyServiceEntity notifyServiceEntity) throws Exception {
+        if (notifyServiceEntity != null) {
+            getService().delete(c, notifyServiceEntity);
+        }
+    }
+
+    @Override
+    public NotifyServiceEntity build() {
+        try {
+
+            notifyService.update(context, notifyServiceEntity);
+            context.dispatchEvents();
+
+            indexingService.commit();
+        } catch (SearchServiceException | SQLException e) {
+            log.error(e);
+        }
+        return notifyServiceEntity;
+    }
+
+    public void delete(NotifyServiceEntity notifyServiceEntity) throws Exception {
+        try (Context c = new Context()) {
+            c.turnOffAuthorisationSystem();
+            NotifyServiceEntity nsEntity = c.reloadEntity(notifyServiceEntity);
+            if (nsEntity != null) {
+                getService().delete(c, nsEntity);
+            }
+            c.complete();
+        }
+
+        indexingService.commit();
+    }
+
+    public static NotifyServiceBuilder createNotifyServiceBuilder(Context context) {
+        NotifyServiceBuilder notifyServiceBuilder = new NotifyServiceBuilder(context);
+        return notifyServiceBuilder.create(context);
+    }
+
+    private NotifyServiceBuilder create(Context context) {
+        try {
+
+            this.context = context;
+            this.notifyServiceEntity = notifyService.create(context);
+
+        } catch (SQLException e) {
+            log.warn("Failed to create the NotifyService", e);
+        }
+
+        return this;
+    }
+
+    public NotifyServiceBuilder withName(String name) {
+        notifyServiceEntity.setName(name);
+        return this;
+    }
+
+    public NotifyServiceBuilder withDescription(String description) {
+        notifyServiceEntity.setDescription(description);
+        return this;
+    }
+
+    public NotifyServiceBuilder withUrl(String url) {
+        notifyServiceEntity.setUrl(url);
+        return this;
+    }
+
+    public NotifyServiceBuilder withLdnUrl(String ldnUrl) {
+        notifyServiceEntity.setLdnUrl(ldnUrl);
+        return this;
+    }
+
+    public NotifyServiceBuilder withStatus(boolean enabled) {
+        notifyServiceEntity.setEnabled(enabled);
+        return this;
+    }
+
+    public NotifyServiceBuilder withScore(BigDecimal score) {
+        notifyServiceEntity.setScore(score);
+        return this;
+    }
+
+    public NotifyServiceBuilder isEnabled(boolean enabled) {
+        notifyServiceEntity.setEnabled(enabled);
+        return this;
+    }
+
+    public NotifyServiceBuilder withLowerIp(String lowerIp) {
+        notifyServiceEntity.setLowerIp(lowerIp);
+        return this;
+    }
+
+    public NotifyServiceBuilder withUpperIp(String upperIp) {
+        notifyServiceEntity.setUpperIp(upperIp);
+        return this;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/test/java/org/dspace/builder/NotifyServiceInboundPatternBuilder.java b/dspace-api/src/test/java/org/dspace/builder/NotifyServiceInboundPatternBuilder.java
new file mode 100644
index 0000000000..5ae20b0001
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/builder/NotifyServiceInboundPatternBuilder.java
@@ -0,0 +1,126 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.builder;
+
+import java.sql.SQLException;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.core.Context;
+import org.dspace.discovery.SearchServiceException;
+
+/**
+ * Builder for {@link NotifyServiceInboundPattern} entities.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ *
+ */
+public class NotifyServiceInboundPatternBuilder
+    extends AbstractBuilder<NotifyServiceInboundPattern, NotifyServiceInboundPatternService> {
+
+    /* Log4j logger*/
+    private static final Logger log = LogManager.getLogger();
+
+    private NotifyServiceInboundPattern notifyServiceInboundPattern;
+
+    protected NotifyServiceInboundPatternBuilder(Context context) {
+        super(context);
+    }
+
+    @Override
+    protected NotifyServiceInboundPatternService getService() {
+        return inboundPatternService;
+    }
+
+    @Override
+    public void cleanup() throws Exception {
+        try (Context c = new Context()) {
+            c.setDispatcher("noindex");
+            c.turnOffAuthorisationSystem();
+            // Ensure object and any related objects are reloaded before checking to see what needs cleanup
+            notifyServiceInboundPattern = c.reloadEntity(notifyServiceInboundPattern);
+            if (notifyServiceInboundPattern != null) {
+                delete(notifyServiceInboundPattern);
+            }
+            c.complete();
+            indexingService.commit();
+        }
+    }
+
+    @Override
+    public void delete(Context c, NotifyServiceInboundPattern notifyServiceInboundPattern) throws Exception {
+        if (notifyServiceInboundPattern != null) {
+            getService().delete(c, notifyServiceInboundPattern);
+        }
+    }
+
+    @Override
+    public NotifyServiceInboundPattern build() {
+        try {
+
+            inboundPatternService.update(context, notifyServiceInboundPattern);
+            context.dispatchEvents();
+
+            indexingService.commit();
+        } catch (SearchServiceException | SQLException e) {
+            log.error(e);
+        }
+        return notifyServiceInboundPattern;
+    }
+
+    public void delete(NotifyServiceInboundPattern notifyServiceInboundPattern) throws Exception {
+        try (Context c = new Context()) {
+            c.turnOffAuthorisationSystem();
+            NotifyServiceInboundPattern nsEntity = c.reloadEntity(notifyServiceInboundPattern);
+            if (nsEntity != null) {
+                getService().delete(c, nsEntity);
+            }
+            c.complete();
+        }
+
+        indexingService.commit();
+    }
+
+    public static NotifyServiceInboundPatternBuilder createNotifyServiceInboundPatternBuilder(
+        Context context, NotifyServiceEntity service) {
+        NotifyServiceInboundPatternBuilder notifyServiceBuilder = new NotifyServiceInboundPatternBuilder(context);
+        return notifyServiceBuilder.create(context, service);
+    }
+
+    private NotifyServiceInboundPatternBuilder create(Context context, NotifyServiceEntity service) {
+        try {
+
+            this.context = context;
+            this.notifyServiceInboundPattern = inboundPatternService.create(context, service);
+
+        } catch (SQLException e) {
+            log.warn("Failed to create the NotifyService", e);
+        }
+
+        return this;
+    }
+
+    public NotifyServiceInboundPatternBuilder isAutomatic(boolean automatic) {
+        notifyServiceInboundPattern.setAutomatic(automatic);
+        return this;
+    }
+
+    public NotifyServiceInboundPatternBuilder withPattern(String pattern) {
+        notifyServiceInboundPattern.setPattern(pattern);
+        return this;
+    }
+
+    public NotifyServiceInboundPatternBuilder withConstraint(String constraint) {
+        notifyServiceInboundPattern.setConstraint(constraint);
+        return this;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-api/src/test/java/org/dspace/builder/QAEventBuilder.java b/dspace-api/src/test/java/org/dspace/builder/QAEventBuilder.java
new file mode 100644
index 0000000000..823080516d
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/builder/QAEventBuilder.java
@@ -0,0 +1,141 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.builder;
+
+import java.util.Date;
+
+import org.dspace.content.Collection;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.qaevent.service.QAEventService;
+
+/**
+ * Builder to construct Quality Assurance Broker Event objects
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+public class QAEventBuilder extends AbstractBuilder<QAEvent, QAEventService> {
+
+    private Item item;
+    private QAEvent target;
+    private String source = QAEvent.OPENAIRE_SOURCE;
+    /**
+     * the title of the DSpace object
+     * */
+    private String title;
+    /**
+     * the name of the Quality Assurance Event Topic
+     * */
+    private String topic;
+    /**
+     * thr original QA Event imported
+     * */
+    private String message;
+    /**
+     * uuid of the targeted DSpace object
+     * */
+    private String relatedItem;
+    private double trust = 0.5;
+    private Date lastUpdate = new Date();
+
+    protected QAEventBuilder(Context context) {
+        super(context);
+    }
+
+    public static QAEventBuilder createTarget(final Context context, final Collection col, final String name) {
+        QAEventBuilder builder = new QAEventBuilder(context);
+        return builder.create(context, col, name);
+    }
+
+    public static QAEventBuilder createTarget(final Context context, final Item item) {
+        QAEventBuilder builder = new QAEventBuilder(context);
+        return builder.create(context, item);
+    }
+
+    private QAEventBuilder create(final Context context, final Collection col, final String name) {
+        this.context = context;
+
+        try {
+            ItemBuilder itemBuilder = ItemBuilder.createItem(context, col).withTitle(name);
+            item = itemBuilder.build();
+            this.title = name;
+            context.dispatchEvents();
+            indexingService.commit();
+        } catch (Exception e) {
+            return handleException(e);
+        }
+        return this;
+    }
+
+    private QAEventBuilder create(final Context context, final Item item) {
+        this.context = context;
+        this.item = item;
+        return this;
+    }
+
+    public QAEventBuilder withTopic(final String topic) {
+        this.topic = topic;
+        return this;
+    }
+    public QAEventBuilder withSource(final String source) {
+        this.source = source;
+        return this;
+    }
+    public QAEventBuilder withTitle(final String title) {
+        this.title = title;
+        return this;
+    }
+    public QAEventBuilder withMessage(final String message) {
+        this.message = message;
+        return this;
+    }
+    public QAEventBuilder withTrust(final double trust) {
+        this.trust = trust;
+        return this;
+    }
+    public QAEventBuilder withLastUpdate(final Date lastUpdate) {
+        this.lastUpdate = lastUpdate;
+        return this;
+    }
+
+    public QAEventBuilder withRelatedItem(String relatedItem) {
+        this.relatedItem = relatedItem;
+        return this;
+    }
+
+    @Override
+    public QAEvent build() {
+        target = new QAEvent(source, "oai:www.dspace.org:" + item.getHandle(), item.getID().toString(), title, topic,
+            trust, message, lastUpdate);
+        target.setRelated(relatedItem);
+        try {
+            qaEventService.store(context, target);
+        } catch (Exception e) {
+            e.printStackTrace();
+        }
+        return target;
+    }
+
+    @Override
+    public void cleanup() throws Exception {
+        qaEventService.deleteEventByEventId(target.getEventId());
+    }
+
+    @Override
+    protected QAEventService getService() {
+        return qaEventService;
+    }
+
+    @Override
+    public void delete(Context c, QAEvent dso) throws Exception {
+        qaEventService.deleteEventByEventId(target.getEventId());
+
+//        qaEventService.deleteTarget(dso);
+    }
+}
\ No newline at end of file
diff --git a/dspace-api/src/test/java/org/dspace/builder/SuggestionTargetBuilder.java b/dspace-api/src/test/java/org/dspace/builder/SuggestionTargetBuilder.java
new file mode 100644
index 0000000000..f9671bba60
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/builder/SuggestionTargetBuilder.java
@@ -0,0 +1,161 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.builder;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.apache.solr.client.solrj.SolrServerException;
+import org.dspace.app.suggestion.MockSuggestionExternalDataSource;
+import org.dspace.app.suggestion.SolrSuggestionStorageService;
+import org.dspace.app.suggestion.Suggestion;
+import org.dspace.app.suggestion.SuggestionEvidence;
+import org.dspace.app.suggestion.SuggestionTarget;
+import org.dspace.content.Collection;
+import org.dspace.content.Item;
+import org.dspace.content.dto.MetadataValueDTO;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+
+/**
+ * Builder to construct Item objects
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+public class SuggestionTargetBuilder extends AbstractBuilder<SuggestionTarget, SolrSuggestionStorageService> {
+    public final static String EVIDENCE_MOCK_NAME = "MockEvidence";
+    public final static String EVIDENCE_MOCK_NOTE = "Generated for testing purpose...";
+    private Item item;
+    private SuggestionTarget target;
+    private List<Suggestion> suggestions;
+    private String source;
+    private int total;
+
+    protected SuggestionTargetBuilder(Context context) {
+        super(context);
+    }
+
+    public static SuggestionTargetBuilder createTarget(final Context context, final Collection col, final String name) {
+        return createTarget(context, col, name, null);
+    }
+
+    public static SuggestionTargetBuilder createTarget(final Context context, final Collection col, final String name,
+            final EPerson eperson) {
+        SuggestionTargetBuilder builder = new SuggestionTargetBuilder(context);
+        return builder.create(context, col, name, eperson);
+    }
+
+    public static SuggestionTargetBuilder createTarget(final Context context, final Item item) {
+        SuggestionTargetBuilder builder = new SuggestionTargetBuilder(context);
+        return builder.create(context, item);
+    }
+
+    private SuggestionTargetBuilder create(final Context context, final Collection col, final String name) {
+        return create(context, col, name, null);
+    }
+
+    private SuggestionTargetBuilder create(final Context context, final Collection col, final String name,
+            final EPerson eperson) {
+        this.context = context;
+
+        try {
+            ItemBuilder itemBuilder = ItemBuilder.createItem(context, col).withTitle(name);
+            if (eperson != null) {
+                itemBuilder = itemBuilder.withDSpaceObjectOwner(eperson.getFullName(), eperson.getID().toString());
+            }
+            item = itemBuilder.build();
+            context.dispatchEvents();
+            indexingService.commit();
+        } catch (Exception e) {
+            return handleException(e);
+        }
+        return this;
+    }
+
+    private SuggestionTargetBuilder create(final Context context, final Item item) {
+        this.context = context;
+        this.item = item;
+        return this;
+    }
+
+    public SuggestionTargetBuilder withSuggestionCount(final String source, final int total) {
+        this.source = source;
+        this.total = total;
+        return this;
+    }
+
+    @Override
+    public SuggestionTarget build() {
+        target = new SuggestionTarget(item);
+        target.setTotal(total);
+        target.setSource(source);
+        suggestions = generateAllSuggestion();
+        try {
+            for (Suggestion s : suggestions) {
+                solrSuggestionService.addSuggestion(s, false, false);
+            }
+            solrSuggestionService.commit();
+        } catch (SolrServerException | IOException e) {
+            e.printStackTrace();
+            throw new RuntimeException(e);
+        }
+        return target;
+    }
+
+    @Override
+    public void cleanup() throws Exception {
+        solrSuggestionService.deleteTarget(target);
+    }
+
+    @Override
+    protected SolrSuggestionStorageService getService() {
+        return solrSuggestionService;
+    }
+
+    @Override
+    public void delete(Context c, SuggestionTarget dso) throws Exception {
+        solrSuggestionService.deleteTarget(dso);
+    }
+
+    private List<Suggestion> generateAllSuggestion() {
+        List<Suggestion> allSuggestions = new ArrayList<Suggestion>();
+        for (int idx = 0; idx < target.getTotal(); idx++) {
+            String idPartStr = String.valueOf(idx + 1);
+            Suggestion sug = new Suggestion(source, item, idPartStr);
+            sug.setDisplay("Suggestion " + source + " " + idPartStr);
+            MetadataValueDTO mTitle = new MetadataValueDTO();
+            mTitle.setSchema("dc");
+            mTitle.setElement("title");
+            mTitle.setValue("Title Suggestion " + idPartStr);
+
+            MetadataValueDTO mSource1 = new MetadataValueDTO();
+            mSource1.setSchema("dc");
+            mSource1.setElement("source");
+            mSource1.setValue("Source 1");
+
+            MetadataValueDTO mSource2 = new MetadataValueDTO();
+            mSource2.setSchema("dc");
+            mSource2.setElement("source");
+            mSource2.setValue("Source 2");
+
+            sug.getMetadata().add(mTitle);
+            sug.getMetadata().add(mSource1);
+            sug.getMetadata().add(mSource2);
+
+            sug.setExternalSourceUri(
+                    "http://localhost/api/integration/externalsources/" + MockSuggestionExternalDataSource.NAME
+                            + "/entryValues/" + idPartStr);
+            sug.getEvidences().add(new SuggestionEvidence(EVIDENCE_MOCK_NAME,
+                    idx % 2 == 0 ? 100 - idx : (double) idx / 2, EVIDENCE_MOCK_NOTE));
+            allSuggestions.add(sug);
+        }
+        return allSuggestions;
+    }
+
+}
diff --git a/dspace-api/src/test/java/org/dspace/builder/WorkspaceItemBuilder.java b/dspace-api/src/test/java/org/dspace/builder/WorkspaceItemBuilder.java
index 9d786d4761..7d844415ab 100644
--- a/dspace-api/src/test/java/org/dspace/builder/WorkspaceItemBuilder.java
+++ b/dspace-api/src/test/java/org/dspace/builder/WorkspaceItemBuilder.java
@@ -11,6 +11,8 @@ import java.io.IOException;
 import java.io.InputStream;
 import java.sql.SQLException;
 
+import org.dspace.app.ldn.NotifyPatternToTrigger;
+import org.dspace.app.ldn.NotifyServiceEntity;
 import org.dspace.authorize.AuthorizeException;
 import org.dspace.content.Bitstream;
 import org.dspace.content.Collection;
@@ -219,4 +221,20 @@ public class WorkspaceItemBuilder extends AbstractBuilder<WorkspaceItem, Workspa
         }
         return this;
     }
+
+    public WorkspaceItemBuilder withCOARNotifyService(NotifyServiceEntity notifyService, String pattern) {
+        Item item = workspaceItem.getItem();
+
+        try {
+            NotifyPatternToTrigger notifyPatternToTrigger = notifyPatternToTriggerService.create(context);
+            notifyPatternToTrigger.setItem(item);
+            notifyPatternToTrigger.setNotifyService(notifyService);
+            notifyPatternToTrigger.setPattern(pattern);
+            notifyPatternToTriggerService.update(context, notifyPatternToTrigger);
+        } catch (Exception e) {
+            handleException(e);
+        }
+        return this;
+    }
+
 }
diff --git a/dspace-api/src/test/java/org/dspace/external/MockOpenAIRERestConnector.java b/dspace-api/src/test/java/org/dspace/external/MockOpenaireRestConnector.java
similarity index 90%
rename from dspace-api/src/test/java/org/dspace/external/MockOpenAIRERestConnector.java
rename to dspace-api/src/test/java/org/dspace/external/MockOpenaireRestConnector.java
index bac80e196c..c67402dfdc 100644
--- a/dspace-api/src/test/java/org/dspace/external/MockOpenAIRERestConnector.java
+++ b/dspace-api/src/test/java/org/dspace/external/MockOpenaireRestConnector.java
@@ -14,15 +14,15 @@ import eu.openaire.jaxb.helper.OpenAIREHandler;
 import eu.openaire.jaxb.model.Response;
 
 /**
- * Mock the OpenAIRE rest connector for unit testing<br>
+ * Mock the Openaire rest connector for unit testing<br>
  * will be resolved against static test xml files
  * 
  * @author pgraca
  *
  */
-public class MockOpenAIRERestConnector extends OpenAIRERestConnector {
+public class MockOpenaireRestConnector extends OpenaireRestConnector {
 
-    public MockOpenAIRERestConnector(String url) {
+    public MockOpenaireRestConnector(String url) {
         super(url);
     }
 
diff --git a/dspace-api/src/test/java/org/dspace/external/provider/impl/OpenAIREFundingDataProviderTest.java b/dspace-api/src/test/java/org/dspace/external/provider/impl/OpenaireFundingDataProviderTest.java
similarity index 59%
rename from dspace-api/src/test/java/org/dspace/external/provider/impl/OpenAIREFundingDataProviderTest.java
rename to dspace-api/src/test/java/org/dspace/external/provider/impl/OpenaireFundingDataProviderTest.java
index 5e96f06ac8..d14dc99035 100644
--- a/dspace-api/src/test/java/org/dspace/external/provider/impl/OpenAIREFundingDataProviderTest.java
+++ b/dspace-api/src/test/java/org/dspace/external/provider/impl/OpenaireFundingDataProviderTest.java
@@ -23,15 +23,15 @@ import org.junit.Before;
 import org.junit.Test;
 
 /**
- * Unit tests for OpenAIREFundingDataProvider
+ * Unit tests for OpenaireFundingDataProvider
  * 
  * @author pgraca
  *
  */
-public class OpenAIREFundingDataProviderTest extends AbstractDSpaceTest {
+public class OpenaireFundingDataProviderTest extends AbstractDSpaceTest {
 
     ExternalDataService externalDataService;
-    ExternalDataProvider openAIREFundingDataProvider;
+    ExternalDataProvider openaireFundingDataProvider;
 
     /**
      * This method will be run before every test as per @Before. It will initialize
@@ -44,38 +44,38 @@ public class OpenAIREFundingDataProviderTest extends AbstractDSpaceTest {
     public void init() {
         // Set up External Service Factory and set data providers
         externalDataService = ExternalServiceFactory.getInstance().getExternalDataService();
-        openAIREFundingDataProvider = externalDataService.getExternalDataProvider("openAIREFunding");
+        openaireFundingDataProvider = externalDataService.getExternalDataProvider("openaireFunding");
     }
 
     @Test
     public void testNumberOfResultsWSingleKeyword() {
-        assertNotNull("openAIREFundingDataProvider is not null", openAIREFundingDataProvider);
-        assertEquals("openAIREFunding.numberOfResults.query:mock", 77,
-                openAIREFundingDataProvider.getNumberOfResults("mock"));
+        assertNotNull("openaireFundingDataProvider is not null", openaireFundingDataProvider);
+        assertEquals("openaireFunding.numberOfResults.query:mock", 77,
+                openaireFundingDataProvider.getNumberOfResults("mock"));
     }
 
     @Test
     public void testNumberOfResultsWKeywords() {
-        assertNotNull("openAIREFundingDataProvider is not null", openAIREFundingDataProvider);
-        assertEquals("openAIREFunding.numberOfResults.query:mock+test", 77,
-                openAIREFundingDataProvider.getNumberOfResults("mock+test"));
+        assertNotNull("openaireFundingDataProvider is not null", openaireFundingDataProvider);
+        assertEquals("openaireFunding.numberOfResults.query:mock+test", 77,
+                openaireFundingDataProvider.getNumberOfResults("mock+test"));
     }
 
     @Test
     public void testQueryResultsWSingleKeyword() {
-        assertNotNull("openAIREFundingDataProvider is not null", openAIREFundingDataProvider);
-        List<ExternalDataObject> results = openAIREFundingDataProvider.searchExternalDataObjects("mock", 0, 10);
-        assertEquals("openAIREFunding.searchExternalDataObjects.size", 10, results.size());
+        assertNotNull("openaireFundingDataProvider is not null", openaireFundingDataProvider);
+        List<ExternalDataObject> results = openaireFundingDataProvider.searchExternalDataObjects("mock", 0, 10);
+        assertEquals("openaireFunding.searchExternalDataObjects.size", 10, results.size());
     }
 
     @Test
     public void testQueryResultsWKeywords() {
         String value = "Mushroom Robo-Pic - Development of an autonomous robotic mushroom picking system";
 
-        assertNotNull("openAIREFundingDataProvider is not null", openAIREFundingDataProvider);
-        List<ExternalDataObject> results = openAIREFundingDataProvider.searchExternalDataObjects("mock+test", 0, 10);
-        assertEquals("openAIREFunding.searchExternalDataObjects.size", 10, results.size());
-        assertTrue("openAIREFunding.searchExternalDataObjects.first.value", value.equals(results.get(0).getValue()));
+        assertNotNull("openaireFundingDataProvider is not null", openaireFundingDataProvider);
+        List<ExternalDataObject> results = openaireFundingDataProvider.searchExternalDataObjects("mock+test", 0, 10);
+        assertEquals("openaireFunding.searchExternalDataObjects.size", 10, results.size());
+        assertTrue("openaireFunding.searchExternalDataObjects.first.value", value.equals(results.get(0).getValue()));
     }
 
     @Test
@@ -84,22 +84,22 @@ public class OpenAIREFundingDataProviderTest extends AbstractDSpaceTest {
         String value = "Portuguese Wild Mushrooms: Chemical characterization and functional study"
                 + " of antiproliferative and proapoptotic properties in cancer cell lines";
 
-        assertNotNull("openAIREFundingDataProvider is not null", openAIREFundingDataProvider);
+        assertNotNull("openaireFundingDataProvider is not null", openaireFundingDataProvider);
 
-        Optional<ExternalDataObject> result = openAIREFundingDataProvider.getExternalDataObject(id);
+        Optional<ExternalDataObject> result = openaireFundingDataProvider.getExternalDataObject(id);
 
-        assertTrue("openAIREFunding.getExternalDataObject.exists", result.isPresent());
-        assertTrue("openAIREFunding.getExternalDataObject.value", value.equals(result.get().getValue()));
+        assertTrue("openaireFunding.getExternalDataObject.exists", result.isPresent());
+        assertTrue("openaireFunding.getExternalDataObject.value", value.equals(result.get().getValue()));
     }
 
     @Test
     public void testGetDataObjectWInvalidId() {
         String id = "WRONGID";
 
-        assertNotNull("openAIREFundingDataProvider is not null", openAIREFundingDataProvider);
+        assertNotNull("openaireFundingDataProvider is not null", openaireFundingDataProvider);
 
-        Optional<ExternalDataObject> result = openAIREFundingDataProvider.getExternalDataObject(id);
+        Optional<ExternalDataObject> result = openaireFundingDataProvider.getExternalDataObject(id);
 
-        assertTrue("openAIREFunding.getExternalDataObject.notExists:WRONGID", result.isEmpty());
+        assertTrue("openaireFunding.getExternalDataObject.notExists:WRONGID", result.isEmpty());
     }
 }
diff --git a/dspace-api/src/test/java/org/dspace/matcher/NotifyServiceEntityMatcher.java b/dspace-api/src/test/java/org/dspace/matcher/NotifyServiceEntityMatcher.java
new file mode 100644
index 0000000000..7b20a1c8be
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/matcher/NotifyServiceEntityMatcher.java
@@ -0,0 +1,57 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.matcher;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.hamcrest.TypeSafeMatcher;
+
+/**
+ * Implementation of {@link Matcher} to match a NotifyServiceEntity by all its
+ * attributes.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ *
+ */
+public class NotifyServiceEntityMatcher extends TypeSafeMatcher<NotifyServiceEntity> {
+
+    private final NotifyServiceEntity expectedEntity;
+
+    private NotifyServiceEntityMatcher(NotifyServiceEntity expectedEntity) {
+        this.expectedEntity = expectedEntity;
+    }
+
+    public static NotifyServiceEntityMatcher matchesNotifyServiceEntity(NotifyServiceEntity expectedEntity) {
+        return new NotifyServiceEntityMatcher(expectedEntity);
+    }
+
+    @Override
+    protected boolean matchesSafely(NotifyServiceEntity actualEntity) {
+        return actualEntity.getName().equals(expectedEntity.getName()) &&
+            actualEntity.getDescription().equals(expectedEntity.getDescription()) &&
+            actualEntity.getUrl().equals(expectedEntity.getUrl()) &&
+            actualEntity.getLdnUrl().equals(expectedEntity.getLdnUrl()) &&
+            actualEntity.getInboundPatterns() == expectedEntity.getInboundPatterns() &&
+            actualEntity.isEnabled() == expectedEntity.isEnabled() &&
+            actualEntity.getScore() == expectedEntity.getScore();
+    }
+
+    @Override
+    public void describeTo(Description description) {
+        description.appendText("a Notify Service Entity with the following attributes:")
+                   .appendText(", name ").appendValue(expectedEntity.getName())
+                   .appendText(", description ").appendValue(expectedEntity.getDescription())
+                   .appendText(", URL ").appendValue(expectedEntity.getUrl())
+                   .appendText(", LDN URL ").appendValue(expectedEntity.getLdnUrl())
+                   .appendText(", inbound patterns ").appendValue(expectedEntity.getInboundPatterns())
+                   .appendText(", enabled ").appendValue(expectedEntity.isEnabled())
+                   .appendText(", score ").appendValue(expectedEntity.getScore());
+    }
+
+}
diff --git a/dspace-api/src/test/java/org/dspace/matcher/QAEventMatcher.java b/dspace-api/src/test/java/org/dspace/matcher/QAEventMatcher.java
new file mode 100644
index 0000000000..91b3d32e03
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/matcher/QAEventMatcher.java
@@ -0,0 +1,117 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.matcher;
+
+import static org.dspace.content.QAEvent.OPENAIRE_SOURCE;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.notNullValue;
+import static org.hamcrest.Matchers.nullValue;
+
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.hamcrest.TypeSafeMatcher;
+
+/**
+ * Implementation of {@link Matcher} to match a QAEvent by all its
+ * attributes.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+public class QAEventMatcher extends TypeSafeMatcher<QAEvent> {
+
+    private Matcher<String> eventIdMatcher;
+
+    private Matcher<String> originalIdMatcher;
+
+    private Matcher<String> relatedMatcher;
+
+    private Matcher<String> sourceMatcher;
+
+    private Matcher<String> statusMatcher;
+
+    private Matcher<String> targetMatcher;
+
+    private Matcher<String> titleMatcher;
+
+    private Matcher<String> messageMatcher;
+
+    private Matcher<String> topicMatcher;
+
+    private Matcher<Double> trustMatcher;
+
+    private QAEventMatcher(Matcher<String> eventIdMatcher, Matcher<String> originalIdMatcher,
+        Matcher<String> relatedMatcher, Matcher<String> sourceMatcher, Matcher<String> statusMatcher,
+        Matcher<String> targetMatcher, Matcher<String> titleMatcher, Matcher<String> messageMatcher,
+        Matcher<String> topicMatcher, Matcher<Double> trustMatcher) {
+        this.eventIdMatcher = eventIdMatcher;
+        this.originalIdMatcher = originalIdMatcher;
+        this.relatedMatcher = relatedMatcher;
+        this.sourceMatcher = sourceMatcher;
+        this.statusMatcher = statusMatcher;
+        this.targetMatcher = targetMatcher;
+        this.titleMatcher = titleMatcher;
+        this.messageMatcher = messageMatcher;
+        this.topicMatcher = topicMatcher;
+        this.trustMatcher = trustMatcher;
+    }
+
+    /**
+     * Creates an instance of {@link QAEventMatcher} that matches an OPENAIRE
+     * QAEvent with PENDING status, with an event id, without a related item and
+     * with the given attributes.
+     * 
+     * @param  originalId the original id to match
+     * @param  target     the target to match
+     * @param  title      the title to match
+     * @param  message    the message to match
+     * @param  topic      the topic to match
+     * @param  trust      the trust to match
+     * @return            the matcher istance
+     */
+    public static QAEventMatcher pendingOpenaireEventWith(String originalId, Item target,
+        String title, String message, String topic, Double trust) {
+
+        return new QAEventMatcher(notNullValue(String.class), is(originalId), nullValue(String.class),
+            is(OPENAIRE_SOURCE), is("PENDING"), is(target.getID().toString()), is(title), is(message), is(topic),
+            is(trust));
+
+    }
+
+    @Override
+    public boolean matchesSafely(QAEvent event) {
+        return eventIdMatcher.matches(event.getEventId())
+            && originalIdMatcher.matches(event.getOriginalId())
+            && relatedMatcher.matches(event.getRelated())
+            && sourceMatcher.matches(event.getSource())
+            && statusMatcher.matches(event.getStatus())
+            && targetMatcher.matches(event.getTarget())
+            && titleMatcher.matches(event.getTitle())
+            && messageMatcher.matches(event.getMessage())
+            && topicMatcher.matches(event.getTopic())
+            && trustMatcher.matches(event.getTrust());
+    }
+
+    @Override
+    public void describeTo(Description description) {
+        description.appendText("a QA event with the following attributes:")
+            .appendText(" event id ").appendDescriptionOf(eventIdMatcher)
+            .appendText(", original id ").appendDescriptionOf(originalIdMatcher)
+            .appendText(", related ").appendDescriptionOf(relatedMatcher)
+            .appendText(", source ").appendDescriptionOf(sourceMatcher)
+            .appendText(", status ").appendDescriptionOf(statusMatcher)
+            .appendText(", target ").appendDescriptionOf(targetMatcher)
+            .appendText(", title ").appendDescriptionOf(titleMatcher)
+            .appendText(", message ").appendDescriptionOf(messageMatcher)
+            .appendText(", topic ").appendDescriptionOf(topicMatcher)
+            .appendText(" and trust ").appendDescriptionOf(trustMatcher);
+    }
+
+}
diff --git a/dspace-api/src/test/java/org/dspace/matcher/QASourceMatcher.java b/dspace-api/src/test/java/org/dspace/matcher/QASourceMatcher.java
new file mode 100644
index 0000000000..5555e24f5c
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/matcher/QASourceMatcher.java
@@ -0,0 +1,58 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.matcher;
+
+import static org.hamcrest.Matchers.is;
+
+import org.dspace.qaevent.QASource;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.hamcrest.TypeSafeMatcher;
+
+/**
+ * Implementation of {@link Matcher} to match a QASource by all its
+ * attributes.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+public class QASourceMatcher extends TypeSafeMatcher<QASource> {
+
+    private Matcher<String> nameMatcher;
+
+    private Matcher<Long> totalEventsMatcher;
+
+    private QASourceMatcher(Matcher<String> nameMatcher, Matcher<Long> totalEventsMatcher) {
+        this.nameMatcher = nameMatcher;
+        this.totalEventsMatcher = totalEventsMatcher;
+    }
+
+    /**
+     * Creates an instance of {@link QASourceMatcher} that matches a QATopic with
+     * the given name and total events count.
+     * @param  name        the name to match
+     * @param  totalEvents the total events count to match
+     * @return             the matcher instance
+     */
+    public static QASourceMatcher with(String name, long totalEvents) {
+        return new QASourceMatcher(is(name), is(totalEvents));
+    }
+
+    @Override
+    public boolean matchesSafely(QASource event) {
+        return nameMatcher.matches(event.getName()) && totalEventsMatcher.matches(event.getTotalEvents());
+    }
+
+    @Override
+    public void describeTo(Description description) {
+        description.appendText("a QA source with the following attributes:")
+            .appendText(" name ").appendDescriptionOf(nameMatcher)
+            .appendText(" and total events ").appendDescriptionOf(totalEventsMatcher);
+    }
+
+}
diff --git a/dspace-api/src/test/java/org/dspace/matcher/QATopicMatcher.java b/dspace-api/src/test/java/org/dspace/matcher/QATopicMatcher.java
new file mode 100644
index 0000000000..5fa5c25119
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/matcher/QATopicMatcher.java
@@ -0,0 +1,58 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.matcher;
+
+import static org.hamcrest.Matchers.is;
+
+import org.dspace.qaevent.QATopic;
+import org.hamcrest.Description;
+import org.hamcrest.Matcher;
+import org.hamcrest.TypeSafeMatcher;
+
+/**
+ * Implementation of {@link Matcher} to match a QATopic by all its
+ * attributes.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+public class QATopicMatcher extends TypeSafeMatcher<QATopic> {
+
+    private Matcher<String> keyMatcher;
+
+    private Matcher<Long> totalEventsMatcher;
+
+    private QATopicMatcher(Matcher<String> keyMatcher, Matcher<Long> totalEventsMatcher) {
+        this.keyMatcher = keyMatcher;
+        this.totalEventsMatcher = totalEventsMatcher;
+    }
+
+    /**
+     * Creates an instance of {@link QATopicMatcher} that matches a QATopic with the
+     * given key and total events count.
+     * @param  key         the key to match
+     * @param  totalEvents the total events count to match
+     * @return             the matcher instance
+     */
+    public static QATopicMatcher with(String key, long totalEvents) {
+        return new QATopicMatcher(is(key), is(totalEvents));
+    }
+
+    @Override
+    public boolean matchesSafely(QATopic event) {
+        return keyMatcher.matches(event.getKey()) && totalEventsMatcher.matches(event.getTotalEvents());
+    }
+
+    @Override
+    public void describeTo(Description description) {
+        description.appendText("a QA topic with the following attributes:")
+            .appendText(" key ").appendDescriptionOf(keyMatcher)
+            .appendText(" and total events ").appendDescriptionOf(totalEventsMatcher);
+    }
+
+}
diff --git a/dspace-api/src/test/java/org/dspace/qaevent/MockQAEventService.java b/dspace-api/src/test/java/org/dspace/qaevent/MockQAEventService.java
new file mode 100644
index 0000000000..3d460015f7
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/qaevent/MockQAEventService.java
@@ -0,0 +1,46 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent;
+
+import java.io.IOException;
+
+import org.apache.solr.client.solrj.SolrServerException;
+import org.dspace.qaevent.service.impl.QAEventServiceImpl;
+import org.dspace.solr.MockSolrServer;
+import org.springframework.beans.factory.DisposableBean;
+import org.springframework.beans.factory.InitializingBean;
+import org.springframework.stereotype.Service;
+
+/**
+ * Mock SOLR service for the qaevents Core.
+ */
+@Service
+public class MockQAEventService extends QAEventServiceImpl implements InitializingBean, DisposableBean {
+    private MockSolrServer mockSolrServer;
+
+    @Override
+    public void afterPropertiesSet() throws Exception {
+        mockSolrServer = new MockSolrServer("qaevent");
+        solr = mockSolrServer.getSolrServer();
+    }
+
+    /** Clear all records from the search core. */
+    public void reset() {
+        mockSolrServer.reset();
+        try {
+            mockSolrServer.getSolrServer().commit();
+        } catch (SolrServerException | IOException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    public void destroy() throws Exception {
+        mockSolrServer.destroy();
+    }
+}
\ No newline at end of file
diff --git a/dspace-api/src/test/java/org/dspace/qaevent/script/OpenaireEventsImportIT.java b/dspace-api/src/test/java/org/dspace/qaevent/script/OpenaireEventsImportIT.java
new file mode 100644
index 0000000000..9be78b9a15
--- /dev/null
+++ b/dspace-api/src/test/java/org/dspace/qaevent/script/OpenaireEventsImportIT.java
@@ -0,0 +1,543 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.qaevent.script;
+
+import static java.util.List.of;
+import static org.dspace.content.QAEvent.COAR_NOTIFY_SOURCE;
+import static org.dspace.content.QAEvent.OPENAIRE_SOURCE;
+import static org.dspace.matcher.QAEventMatcher.pendingOpenaireEventWith;
+import static org.dspace.qaevent.service.impl.QAEventServiceImpl.QAEVENTS_SOURCES;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.containsInAnyOrder;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.empty;
+import static org.hamcrest.Matchers.hasItem;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.instanceOf;
+import static org.hamcrest.Matchers.is;
+import static org.mockito.ArgumentMatchers.any;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doAnswer;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.verify;
+import static org.mockito.Mockito.verifyNoInteractions;
+import static org.mockito.Mockito.verifyNoMoreInteractions;
+import static org.mockito.Mockito.when;
+
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.OutputStream;
+import java.net.URL;
+import java.util.List;
+
+import eu.dnetlib.broker.BrokerClient;
+import org.apache.commons.io.IOUtils;
+import org.dspace.AbstractIntegrationTestWithDatabase;
+import org.dspace.app.launcher.ScriptLauncher;
+import org.dspace.app.scripts.handler.impl.TestDSpaceRunnableHandler;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.matcher.QASourceMatcher;
+import org.dspace.matcher.QATopicMatcher;
+import org.dspace.qaevent.QANotifyPatterns;
+import org.dspace.qaevent.QATopic;
+import org.dspace.qaevent.service.OpenaireClientFactory;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.qaevent.service.impl.OpenaireClientFactoryImpl;
+import org.dspace.services.ConfigurationService;
+import org.dspace.utils.DSpace;
+import org.junit.After;
+import org.junit.Before;
+import org.junit.Ignore;
+import org.junit.Test;
+
+/**
+ * Integration tests for {@link OpenaireEventsImport}.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+public class OpenaireEventsImportIT extends AbstractIntegrationTestWithDatabase {
+
+    private static final String ORDER_FIELD = "topic";
+    private static final String BASE_JSON_DIR_PATH = "org/dspace/app/openaire-events/";
+
+    private QAEventService qaEventService = new DSpace().getSingletonService(QAEventService.class);
+
+    private Collection collection;
+
+    private BrokerClient brokerClient = OpenaireClientFactory.getInstance().getBrokerClient();
+
+    private BrokerClient mockBrokerClient = mock(BrokerClient.class);
+
+    private ConfigurationService configurationService = new DSpace().getConfigurationService();
+
+    @Before
+    public void setup() {
+
+        context.turnOffAuthorisationSystem();
+        // we want all the test in this class to be run using the administrator user as OpenAIRE events are only visible
+        // to administrators.
+        // Please note that test related to forbidden and unauthorized access to qaevent are included in
+        // the QAEventRestRepositoryIT here we are only testing that the import script is creating the expected events
+        context.setCurrentUser(admin);
+        parentCommunity = CommunityBuilder.createCommunity(context)
+            .withName("Parent Community")
+            .build();
+
+        collection = CollectionBuilder.createCollection(context, parentCommunity)
+            .withName("Collection")
+            .build();
+
+        context.restoreAuthSystemState();
+        configurationService.setProperty(QAEVENTS_SOURCES, new String[] { QAEvent.OPENAIRE_SOURCE });
+        ((OpenaireClientFactoryImpl) OpenaireClientFactory.getInstance()).setBrokerClient(mockBrokerClient);
+    }
+
+    @After
+    public void after() {
+        ((OpenaireClientFactoryImpl) OpenaireClientFactory.getInstance()).setBrokerClient(brokerClient);
+    }
+
+    @Test
+    public void testWithoutParameters() throws Exception {
+        TestDSpaceRunnableHandler handler = new TestDSpaceRunnableHandler();
+
+        String[] args = new String[] { "import-openaire-events" };
+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), handler, kernelImpl);
+
+        assertThat(handler.getErrorMessages(), empty());
+        assertThat(handler.getWarningMessages(), empty());
+        assertThat(handler.getInfoMessages(), empty());
+
+        Exception exception = handler.getException();
+        assertThat(exception, instanceOf(IllegalArgumentException.class));
+        assertThat(exception.getMessage(), is("One parameter between the location of the file and the email "
+            + "must be entered to proceed with the import."));
+
+        verifyNoInteractions(mockBrokerClient);
+    }
+
+    @Test
+    public void testWithBothFileAndEmailParameters() throws Exception {
+        TestDSpaceRunnableHandler handler = new TestDSpaceRunnableHandler();
+
+        String[] args = new String[] { "import-openaire-events", "-f", getFileLocation("events.json"),
+            "-e", "test@user.com" };
+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), handler, kernelImpl);
+
+        assertThat(handler.getErrorMessages(), empty());
+        assertThat(handler.getWarningMessages(), empty());
+        assertThat(handler.getInfoMessages(), empty());
+
+        Exception exception = handler.getException();
+        assertThat(exception, instanceOf(IllegalArgumentException.class));
+        assertThat(exception.getMessage(), is("Only one parameter between the location of the file and the email "
+            + "must be entered to proceed with the import."));
+
+        verifyNoInteractions(mockBrokerClient);
+    }
+
+    @Test
+    public void testManyEventsImportFromFile() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        Item firstItem = createItem("Test item", "123456789/99998");
+        Item secondItem = createItem("Test item 2", "123456789/99999");
+
+        context.restoreAuthSystemState();
+
+        TestDSpaceRunnableHandler handler = new TestDSpaceRunnableHandler();
+
+        String[] args = new String[] { "import-openaire-events", "-f", getFileLocation("events.json") };
+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), handler, kernelImpl);
+
+        assertThat(handler.getErrorMessages(), empty());
+        assertThat(handler.getWarningMessages(), empty());
+        assertThat(handler.getInfoMessages(), contains(
+            "Trying to read the QA events from the provided file",
+            "Found 5 events in the given file"));
+
+        assertThat(qaEventService.findAllSources(context, 0, 20),
+            hasItem(QASourceMatcher.with(OPENAIRE_SOURCE, 5L))
+        );
+
+        List<QATopic> topicList = qaEventService.findAllTopicsBySource(context, OPENAIRE_SOURCE, 0, 20,
+            ORDER_FIELD, false);
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MORE_PROJECT, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MORE_PID, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MISSING_PROJECT, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 1L)));
+
+        String projectMessage = "{\"projects[0].acronym\":\"PAThs\",\"projects[0].code\":\"687567\","
+            + "\"projects[0].funder\":\"EC\",\"projects[0].fundingProgram\":\"H2020\","
+            + "\"projects[0].jurisdiction\":\"EU\","
+            + "\"projects[0].openaireId\":\"40|corda__h2020::6e32f5eb912688f2424c68b851483ea4\","
+            + "\"projects[0].title\":\"Tracking Papyrus and Parchment Paths\"}";
+
+        assertThat(qaEventService.findEventsByTopic(context, OPENAIRE_SOURCE,
+            QANotifyPatterns.TOPIC_ENRICH_MORE_PROJECT, 0, 20, ORDER_FIELD, true),
+                contains(
+            pendingOpenaireEventWith("oai:www.openstarts.units.it:123456789/99998", firstItem,
+                "Egypt, crossroad of translations and literary interweavings", projectMessage,
+                QANotifyPatterns.TOPIC_ENRICH_MORE_PROJECT, 1.00d)));
+
+        String abstractMessage = "{\"abstracts[0]\":\"Missing Abstract\"}";
+
+        assertThat(qaEventService.findEventsByTopic(context, OPENAIRE_SOURCE,
+            QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 0, 20, ORDER_FIELD, true),
+                contains(
+            pendingOpenaireEventWith("oai:www.openstarts.units.it:123456789/99999",
+                secondItem, "Test Publication",
+                abstractMessage, QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 1.00d)));
+
+        verifyNoInteractions(mockBrokerClient);
+    }
+
+    @Test
+    public void testManyEventsImportFromFileWithUnknownHandle() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        Item item = createItem("Test item", "123456789/99999");
+
+        context.restoreAuthSystemState();
+
+        TestDSpaceRunnableHandler handler = new TestDSpaceRunnableHandler();
+
+        String[] args = new String[] { "import-openaire-events", "-f", getFileLocation("events.json") };
+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), handler, kernelImpl);
+
+        assertThat(handler.getErrorMessages(), empty());
+        assertThat(handler.getWarningMessages(),
+                contains("An error occurs storing the event with id 406fb9c5656c7f11cac8995abb746887: "
+                        + "Skipped event 406fb9c5656c7f11cac8995abb746887 related to the oai record "
+                        + "oai:www.openstarts.units.it:123456789/99998 as the record was not found",
+                        "An error occurs storing the event with id eafd747feee49cca7603d30ba4e768dc: "
+                        + "Skipped event eafd747feee49cca7603d30ba4e768dc related to the oai record "
+                        + "oai:www.openstarts.units.it:123456789/99998 as the record was not found"));
+        assertThat(handler.getInfoMessages(), contains(
+            "Trying to read the QA events from the provided file",
+            "Found 5 events in the given file"));
+
+        assertThat(qaEventService.findAllSources(context, 0, 20), hasItem(QASourceMatcher.with(OPENAIRE_SOURCE, 3L)));
+
+        List<QATopic> topicList = qaEventService.findAllTopicsBySource(context, OPENAIRE_SOURCE, 0, 20,
+            ORDER_FIELD, false);
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MISSING_PROJECT, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MORE_PID, 1L)));
+
+        String abstractMessage = "{\"abstracts[0]\":\"Missing Abstract\"}";
+
+        assertThat(qaEventService.findEventsByTopic(context, OPENAIRE_SOURCE,
+                QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 0, 20,
+                ORDER_FIELD, false), contains(
+            pendingOpenaireEventWith("oai:www.openstarts.units.it:123456789/99999", item, "Test Publication",
+                abstractMessage, QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 1.00d)));
+
+        verifyNoInteractions(mockBrokerClient);
+    }
+
+    @Test
+    public void testManyEventsImportFromFileWithUnknownTopic() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        createItem("Test item", "123456789/99999");
+        Item secondItem = createItem("Test item 2", "123456789/999991");
+
+        context.restoreAuthSystemState();
+
+        TestDSpaceRunnableHandler handler = new TestDSpaceRunnableHandler();
+
+        String[] args = new String[] { "import-openaire-events", "-f", getFileLocation("unknown-topic-events.json") };
+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), handler, kernelImpl);
+
+        assertThat(handler.getErrorMessages(), empty());
+        assertThat(handler.getWarningMessages(),
+            contains("An error occurs storing the event with id 8307aa56769deba961faed7162d91aab:"
+                   + " Skipped event 8307aa56769deba961faed7162d91aab related to the oai record"
+                   + " oai:www.openstarts.units.it:123456789/99998 as the record was not found"));
+        assertThat(handler.getInfoMessages(), contains(
+            "Trying to read the QA events from the provided file",
+            "Found 2 events in the given file"));
+
+        assertThat(qaEventService.findAllSources(context, 0, 20), hasItem(QASourceMatcher.with(OPENAIRE_SOURCE, 1L)));
+
+        assertThat(qaEventService.findAllTopicsBySource(context, OPENAIRE_SOURCE, 0, 20, ORDER_FIELD, false),
+                contains(QATopicMatcher.with(org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 1L)));
+
+        String abstractMessage = "{\"abstracts[0]\":\"Missing Abstract\"}";
+
+        assertThat(qaEventService.findEventsByTopic(context, OPENAIRE_SOURCE,
+            QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 0, 20, ORDER_FIELD, false), contains(
+            pendingOpenaireEventWith("oai:www.openstarts.units.it:123456789/999991", secondItem, "Test Publication 2",
+                abstractMessage, org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 1.00d)));
+
+        verifyNoInteractions(mockBrokerClient);
+    }
+
+    @Test
+    public void testImportFromFileWithoutEvents() throws Exception {
+
+        TestDSpaceRunnableHandler handler = new TestDSpaceRunnableHandler();
+
+        String[] args = new String[] { "import-openaire-events", "-f", getFileLocation("empty-file.json") };
+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), handler, kernelImpl);
+
+        assertThat(handler.getException().getMessage(),
+            containsString("No content to map due to end-of-input"));
+        assertThat(handler.getWarningMessages(),empty());
+        assertThat(handler.getInfoMessages(), contains("Trying to read the QA events from the provided file"));
+
+        assertThat(qaEventService.findAllSources(context, 0, 20), hasItem(QASourceMatcher.with(OPENAIRE_SOURCE, 0L)));
+
+        assertThat(qaEventService.findAllTopics(context, 0, 20, ORDER_FIELD, false), empty());
+
+        verifyNoInteractions(mockBrokerClient);
+    }
+
+    @Test
+    public void testImportFromOpenaireBroker() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        Item firstItem = createItem("Test item", "123456789/99998");
+        Item secondItem = createItem("Test item 2", "123456789/99999");
+        Item thirdItem = createItem("Test item 3", "123456789/999991");
+
+        context.restoreAuthSystemState();
+
+        URL openaireURL = new URL("http://api.openaire.eu/broker");
+
+        when(mockBrokerClient.listSubscriptions(openaireURL, "user@test.com")).thenReturn(of("sub1", "sub2", "sub3"));
+
+        doAnswer(i -> writeToOutputStream(i.getArgument(2, OutputStream.class), "events.json"))
+            .when(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub1"), any());
+
+        doAnswer(i -> writeToOutputStream(i.getArgument(2, OutputStream.class), "empty-events-list.json"))
+            .when(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub2"), any());
+
+        doAnswer(i -> writeToOutputStream(i.getArgument(2, OutputStream.class), "unknown-topic-events.json"))
+            .when(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub3"), any());
+
+        TestDSpaceRunnableHandler handler = new TestDSpaceRunnableHandler();
+
+        String[] args = new String[] { "import-openaire-events", "-e", "user@test.com" };
+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), handler, kernelImpl);
+
+        assertThat(handler.getErrorMessages(), empty());
+        assertThat(handler.getWarningMessages(),
+            contains("Event for topic ENRICH/MORE/UNKNOWN is not allowed in the qaevents.cfg"));
+        assertThat(handler.getInfoMessages(), contains(
+            "Trying to read the QA events from the OPENAIRE broker",
+            "Found 3 subscriptions related to the given email",
+            "Found 5 events from the subscription sub1",
+            "Found 0 events from the subscription sub2",
+            "Found 2 events from the subscription sub3"));
+
+        assertThat(qaEventService.findAllSources(context, 0, 20), hasItem(QASourceMatcher.with(OPENAIRE_SOURCE, 6L)));
+
+        List<QATopic> topicList = qaEventService.findAllTopicsBySource(context, OPENAIRE_SOURCE,0,20,ORDER_FIELD,false);
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MORE_PROJECT, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MORE_PID, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MISSING_PROJECT, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 2L)));
+
+        String projectMessage = "{\"projects[0].acronym\":\"PAThs\",\"projects[0].code\":\"687567\","
+            + "\"projects[0].funder\":\"EC\",\"projects[0].fundingProgram\":\"H2020\","
+            + "\"projects[0].jurisdiction\":\"EU\","
+            + "\"projects[0].openaireId\":\"40|corda__h2020::6e32f5eb912688f2424c68b851483ea4\","
+            + "\"projects[0].title\":\"Tracking Papyrus and Parchment Paths\"}";
+
+        assertThat(qaEventService.findEventsByTopic(context, OPENAIRE_SOURCE,
+                QANotifyPatterns.TOPIC_ENRICH_MORE_PROJECT, 0 , 20,
+                ORDER_FIELD, false), contains(
+            pendingOpenaireEventWith("oai:www.openstarts.units.it:123456789/99998", firstItem,
+                "Egypt, crossroad of translations and literary interweavings", projectMessage,
+                QANotifyPatterns.TOPIC_ENRICH_MORE_PROJECT, 1.00d)));
+
+        String abstractMessage = "{\"abstracts[0]\":\"Missing Abstract\"}";
+
+        assertThat(qaEventService.findEventsByTopic(context, OPENAIRE_SOURCE,
+                QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 0, 20,
+                ORDER_FIELD, false), containsInAnyOrder(
+            pendingOpenaireEventWith("oai:www.openstarts.units.it:123456789/99999", secondItem, "Test Publication",
+                abstractMessage, QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 1.00d),
+            pendingOpenaireEventWith("oai:www.openstarts.units.it:123456789/999991", thirdItem, "Test Publication 2",
+                abstractMessage, QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 1.00d)));
+
+        verify(mockBrokerClient).listSubscriptions(openaireURL, "user@test.com");
+        verify(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub1"), any());
+        verify(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub2"), any());
+        verify(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub3"), any());
+
+        verifyNoMoreInteractions(mockBrokerClient);
+    }
+
+    @Test
+    public void testImportFromOpenaireBrokerWithErrorDuringListSubscription() throws Exception {
+
+        URL openaireURL = new URL("http://api.openaire.eu/broker");
+
+        when(mockBrokerClient.listSubscriptions(openaireURL, "user@test.com"))
+            .thenThrow(new RuntimeException("Connection refused"));
+
+        TestDSpaceRunnableHandler handler = new TestDSpaceRunnableHandler();
+
+        String[] args = new String[] { "import-openaire-events", "-e", "user@test.com" };
+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), handler, kernelImpl);
+
+        assertThat(handler.getException().getMessage(),
+            is("An error occurs retriving the subscriptions from the OPENAIRE broker: Connection refused"));
+        assertThat(handler.getWarningMessages(), empty());
+        assertThat(handler.getInfoMessages(), contains("Trying to read the QA events from the OPENAIRE broker"));
+
+        assertThat(qaEventService.findAllSources(context, 0, 20), hasItem(QASourceMatcher.with(OPENAIRE_SOURCE, 0L)));
+
+        assertThat(qaEventService.findAllTopics(context, 0, 20, ORDER_FIELD, false), empty());
+
+        verify(mockBrokerClient).listSubscriptions(openaireURL, "user@test.com");
+
+        verifyNoMoreInteractions(mockBrokerClient);
+
+    }
+
+    @Test
+    public void testImportFromOpenaireBrokerWithErrorDuringEventsDownload() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        createItem("Test item", "123456789/99998");
+        createItem("Test item 2", "123456789/99999");
+        createItem("Test item 3", "123456789/999991");
+
+        context.restoreAuthSystemState();
+
+        URL openaireURL = new URL("http://api.openaire.eu/broker");
+
+        when(mockBrokerClient.listSubscriptions(openaireURL, "user@test.com")).thenReturn(of("sub1", "sub2", "sub3"));
+
+        doAnswer(i -> writeToOutputStream(i.getArgument(2, OutputStream.class), "events.json"))
+            .when(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub1"), any());
+
+        doThrow(new RuntimeException("Invalid subscription id"))
+            .when(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub2"), any());
+
+        doAnswer(i -> writeToOutputStream(i.getArgument(2, OutputStream.class), "unknown-topic-events.json"))
+            .when(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub3"), any());
+
+        TestDSpaceRunnableHandler handler = new TestDSpaceRunnableHandler();
+
+        String[] args = new String[] { "import-openaire-events", "-e", "user@test.com" };
+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), handler, kernelImpl);
+
+        assertThat(handler.getWarningMessages(),
+            contains("Event for topic ENRICH/MORE/UNKNOWN is not allowed in the qaevents.cfg"));
+        assertThat(handler.getInfoMessages(), contains(
+            "Trying to read the QA events from the OPENAIRE broker",
+            "Found 3 subscriptions related to the given email",
+            "Found 5 events from the subscription sub1",
+            "Found 0 events from the subscription sub2",
+            "Found 2 events from the subscription sub3"));
+
+        assertThat(qaEventService.findAllSources(context, 0, 20), hasItem(QASourceMatcher.with(OPENAIRE_SOURCE, 6L)));
+
+        List<QATopic> topicList = qaEventService.findAllTopicsBySource(context, OPENAIRE_SOURCE, 0, 20,
+            ORDER_FIELD, false);
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MORE_PROJECT, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MORE_PID, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MISSING_PROJECT, 1L)));
+        assertThat(topicList, hasItem(QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 2L)));
+
+        assertThat(qaEventService.findEventsByTopic(context, OPENAIRE_SOURCE,
+                   QANotifyPatterns.TOPIC_ENRICH_MORE_PROJECT, 0, 20, ORDER_FIELD, false), hasSize(1));
+        assertThat(qaEventService.findEventsByTopic(context, OPENAIRE_SOURCE,
+                   QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 0, 20, ORDER_FIELD, false), hasSize(2));
+
+        verify(mockBrokerClient).listSubscriptions(openaireURL, "user@test.com");
+        verify(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub1"), any());
+        verify(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub2"), any());
+        verify(mockBrokerClient).downloadEvents(eq(openaireURL), eq("sub3"), any());
+
+        verifyNoMoreInteractions(mockBrokerClient);
+    }
+
+    /**
+     * Improper test for ENRICH/MORE/REVIEW qa. It has the COAR_NOTIFY source
+     * which must be tested via LDNMessage at DNInboxControllerIT
+    */
+    @Test
+    @Ignore
+    public void testImportFromFileEventMoreReview() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+        Item firstItem = createItem("Test item", "123456789/99998");
+        Item secondItem = createItem("Test item 2", "123456789/99999");
+
+        context.restoreAuthSystemState();
+
+        TestDSpaceRunnableHandler handler = new TestDSpaceRunnableHandler();
+
+        String[] args = new String[] { "import-openaire-events", "-f", getFileLocation("event-more-review.json") };
+        ScriptLauncher.handleScript(args, ScriptLauncher.getConfig(kernelImpl), handler, kernelImpl);
+
+        assertThat(qaEventService.findAllTopicsBySource(context, COAR_NOTIFY_SOURCE, 0, 20,
+            ORDER_FIELD, false), contains(
+            QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MORE_REVIEW, 1L)));
+
+        assertThat(qaEventService.findAllSources(context, 0, 20),
+            hasItem(QASourceMatcher.with(COAR_NOTIFY_SOURCE, 1L)));
+
+        verifyNoInteractions(mockBrokerClient);
+    }
+
+    private Item createItem(String title, String handle) {
+        return ItemBuilder.createItem(context, collection)
+            .withTitle(title)
+            .withHandle(handle)
+            .build();
+    }
+
+    private Void writeToOutputStream(OutputStream outputStream, String fileName) {
+        try {
+            byte[] fileContent = getFileContent(fileName);
+            IOUtils.write(fileContent, outputStream);
+            return null;
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private byte[] getFileContent(String fileName) throws Exception {
+        String fileLocation = getFileLocation(fileName);
+        try (FileInputStream fis = new FileInputStream(new File(fileLocation))) {
+            return IOUtils.toByteArray(fis);
+        }
+    }
+
+    private String getFileLocation(String fileName) throws Exception {
+        URL resource = getClass().getClassLoader().getResource(BASE_JSON_DIR_PATH + fileName);
+        if (resource == null) {
+            throw new IllegalStateException("No resource found named " + BASE_JSON_DIR_PATH + fileName);
+        }
+        return new File(resource.getFile()).getAbsolutePath();
+    }
+}
+
diff --git a/dspace-api/src/test/resources/org/dspace/app/openaire-events/empty-events-list.json b/dspace-api/src/test/resources/org/dspace/app/openaire-events/empty-events-list.json
new file mode 100644
index 0000000000..0637a088a0
--- /dev/null
+++ b/dspace-api/src/test/resources/org/dspace/app/openaire-events/empty-events-list.json
@@ -0,0 +1 @@
+[]
\ No newline at end of file
diff --git a/dspace-api/src/test/resources/org/dspace/app/openaire-events/empty-file.json b/dspace-api/src/test/resources/org/dspace/app/openaire-events/empty-file.json
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/dspace-api/src/test/resources/org/dspace/app/openaire-events/events.json b/dspace-api/src/test/resources/org/dspace/app/openaire-events/events.json
new file mode 100644
index 0000000000..9bb8daae36
--- /dev/null
+++ b/dspace-api/src/test/resources/org/dspace/app/openaire-events/events.json
@@ -0,0 +1,62 @@
+[
+
+	{
+		"originalId": "oai:www.openstarts.units.it:123456789/99998",
+		"title": "Egypt, crossroad of translations and literary interweavings",
+		"topic": "ENRICH/MORE/PROJECT",
+		"trust": 1.0,
+		"message": {
+			"projects[0].acronym": "PAThs",
+			"projects[0].code": "687567",
+			"projects[0].funder": "EC",
+			"projects[0].fundingProgram": "H2020",
+			"projects[0].jurisdiction": "EU",
+			"projects[0].openaireId": "40|corda__h2020::6e32f5eb912688f2424c68b851483ea4",
+			"projects[0].title": "Tracking Papyrus and Parchment Paths"
+		}
+	},
+	
+	{
+		"originalId": "oai:www.openstarts.units.it:123456789/99999",
+		"title": "Test Publication",
+		"topic": "ENRICH/MISSING/ABSTRACT",
+		"trust": 1.0,
+		"message": {
+			"abstracts[0]": "Missing Abstract"
+		}
+	},
+    {
+        "originalId": "oai:www.openstarts.units.it:123456789/99998",
+        "title": "Egypt, crossroad of translations and literary interweavings",
+        "topic": "ENRICH/MISSING/PID",
+        "trust": 1.0,
+        "message": {
+            "pids[0].type": "doi",
+            "pids[0].value": "10.13137/2282-572x/987"
+        }
+    },
+    {
+        "originalId": "oai:www.openstarts.units.it:123456789/99999",
+        "title": "Test Publication",
+        "topic": "ENRICH/MORE/PID",
+        "trust": 0.375,
+        "message": {
+            "pids[0].type": "doi",
+            "pids[0].value": "987654"
+        }
+    },
+    {
+        "originalId": "oai:www.openstarts.units.it:123456789/99999",
+        "title": "Test Publication",
+        "topic": "ENRICH/MISSING/PROJECT",
+        "trust": 1.0,
+        "message": {
+            "projects[0].acronym": "02.SNES missing project acronym",
+            "projects[0].code": "prjcode_snes",
+            "projects[0].funder": "02.SNES missing project funder",
+            "projects[0].fundingProgram": "02.SNES missing project fundingProgram",
+            "projects[0].jurisdiction": "02.SNES missing project jurisdiction",
+            "projects[0].title": "Project01"
+        }
+    }
+]
\ No newline at end of file
diff --git a/dspace-api/src/test/resources/org/dspace/app/openaire-events/unknown-topic-events.json b/dspace-api/src/test/resources/org/dspace/app/openaire-events/unknown-topic-events.json
new file mode 100644
index 0000000000..3caa72cf35
--- /dev/null
+++ b/dspace-api/src/test/resources/org/dspace/app/openaire-events/unknown-topic-events.json
@@ -0,0 +1,20 @@
+[
+
+	{
+		"originalId": "oai:www.openstarts.units.it:123456789/99998",
+		"title": "Egypt, crossroad of translations and literary interweavings (3rd-6th centuries). A reconsideration of earlier Coptic literature",
+		"topic": "ENRICH/MORE/UNKNOWN",
+		"trust": 1.0
+	},
+	
+	{
+		"originalId": "oai:www.openstarts.units.it:123456789/999991",
+		"title": "Test Publication 2",
+		"topic": "ENRICH/MISSING/ABSTRACT",
+		"trust": 1.0,
+		"message": {
+			"abstracts[0]": "Missing Abstract"
+		}
+	}
+	
+]
\ No newline at end of file
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/Application.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/Application.java
index 07b802b684..7e8934a2dc 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/Application.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/Application.java
@@ -12,6 +12,8 @@ import java.sql.SQLException;
 import java.util.List;
 import javax.servlet.Filter;
 
+import org.dspace.app.ldn.LDNQueueExtractor;
+import org.dspace.app.ldn.LDNQueueTimeoutChecker;
 import org.dspace.app.rest.filter.DSpaceRequestContextFilter;
 import org.dspace.app.rest.model.hateoas.DSpaceLinkRelationProvider;
 import org.dspace.app.rest.parameter.resolver.SearchFilterResolver;
@@ -76,6 +78,22 @@ public class Application extends SpringBootServletInitializer {
         GenerateSitemaps.generateSitemapsScheduled();
     }
 
+    @Scheduled(cron = "${ldn.queue.extractor.cron:-}")
+    public void ldnExtractFromQueue() throws IOException, SQLException {
+        if (!configuration.getLdnEnabled()) {
+            return;
+        }
+        LDNQueueExtractor.extractMessageFromQueue();
+    }
+
+    @Scheduled(cron = "${ldn.queue.timeout.checker.cron:-}")
+    public void ldnQueueTimeoutCheck() throws IOException, SQLException {
+        if (!configuration.getLdnEnabled()) {
+            return;
+        }
+        LDNQueueTimeoutChecker.checkQueueMessageTimeout();
+    }
+
     @Scheduled(cron = "${solr-database-resync.cron:-}")
     public void solrDatabaseResync() throws Exception {
         SolrDatabaseResyncCli.runScheduled();
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/LDNInboxController.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/LDNInboxController.java
new file mode 100644
index 0000000000..5d18494fc2
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/LDNInboxController.java
@@ -0,0 +1,145 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import java.sql.SQLException;
+import java.util.regex.Pattern;
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.commons.validator.routines.UrlValidator;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.LDNRouter;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.InvalidLDNMessageException;
+import org.dspace.core.Context;
+import org.dspace.services.ConfigurationService;
+import org.dspace.web.ContextUtil;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;
+import org.springframework.http.HttpMethod;
+import org.springframework.http.ResponseEntity;
+import org.springframework.stereotype.Controller;
+import org.springframework.web.bind.annotation.ExceptionHandler;
+import org.springframework.web.bind.annotation.PostMapping;
+import org.springframework.web.bind.annotation.RequestBody;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RequestMethod;
+import org.springframework.web.server.ResponseStatusException;
+
+@Controller
+@RequestMapping("/ldn")
+@ConditionalOnProperty("ldn.enabled")
+public class LDNInboxController {
+
+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger();
+
+    @Autowired
+    private LDNRouter router;
+
+    @Autowired
+    private LDNMessageService ldnMessageService;
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    /**
+     * LDN DSpace inbox.
+     *
+     * @param notification received notification
+     * @return ResponseEntity 400 not stored, 202 stored
+     * @throws Exception
+     */
+    @PostMapping(value = "/inbox", consumes = "application/ld+json")
+    public ResponseEntity<Object> inbox(HttpServletRequest request, @RequestBody Notification notification)
+        throws Exception {
+
+        Context context = ContextUtil.obtainCurrentRequestContext();
+        validate(context, notification, request.getRemoteAddr());
+
+        LDNMessageEntity ldnMsgEntity = ldnMessageService.create(context, notification, request.getRemoteAddr());
+        log.info("stored ldn message {}", ldnMsgEntity);
+        context.commit();
+
+        return ResponseEntity.accepted()
+            .body(String.format("Successfully stored notification %s %s",
+                notification.getId(), notification.getType()));
+    }
+
+    /**
+     * LDN DSpace inbox options.
+     *
+     * @return ResponseEntity 200 with allow and accept-post headers
+     */
+    @RequestMapping(value = "/inbox", method = RequestMethod.OPTIONS)
+    public ResponseEntity<Void> options() {
+        return ResponseEntity.ok()
+            .allow(HttpMethod.OPTIONS, HttpMethod.POST)
+            .header("Accept-Post", "application/ld+json")
+            .build();
+    }
+
+    /**
+     * @param e
+     * @return ResponseEntity<String>
+     */
+    @ExceptionHandler(ResponseStatusException.class)
+    public ResponseEntity<String> handleResponseStatusException(ResponseStatusException e) {
+        return ResponseEntity.status(e.getStatus().value())
+                .body(e.getMessage());
+    }
+
+    private void validate(Context context, Notification notification, String sourceIp) {
+        String id = notification.getId();
+        Pattern URNRegex =
+            Pattern.compile("^urn:uuid:[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}$");
+
+        if (!URNRegex.matcher(id).matches() && !new UrlValidator().isValid(id)) {
+            throw new InvalidLDNMessageException("Invalid URI format for 'id' field.");
+        }
+
+        if (notification.getOrigin() == null || notification.getTarget() == null || notification.getObject() == null) {
+            throw new InvalidLDNMessageException("Origin or Target or Object is missing");
+        }
+
+        if (configurationService.getBooleanProperty("ldn.notify.inbox.block-untrusted", true)) {
+            try {
+                NotifyServiceEntity originNotifyService =
+                    ldnMessageService.findNotifyService(context, notification.getOrigin());
+                if (originNotifyService == null) {
+                    throw new DSpaceBadRequestException("Notify Service [" + notification.getOrigin()
+                        + "] unknown. LDN message can not be received.");
+                }
+            } catch (SQLException sqle) {
+                throw new DSpaceBadRequestException("Notify Service [" + notification.getOrigin()
+                + "] unknown. LDN message can not be received.");
+            }
+        }
+        if (configurationService.getBooleanProperty("ldn.notify.inbox.block-untrusted-ip", true)) {
+            try {
+                NotifyServiceEntity originNotifyService =
+                    ldnMessageService.findNotifyService(context, notification.getOrigin());
+                if (originNotifyService == null) {
+                    throw new DSpaceBadRequestException("Notify Service [" + notification.getOrigin()
+                        + "] unknown. LDN message can not be received.");
+                }
+                boolean isValidIp = ldnMessageService.isValidIp(originNotifyService, sourceIp);
+                if (!isValidIp) {
+                    throw new DSpaceBadRequestException("Source IP for Incoming LDN Message [" + notification.getId()
+                        + "] out of its Notify Service IP Range. LDN message can not be received.");
+                }
+            } catch (SQLException sqle) {
+                throw new DSpaceBadRequestException("Notify Service [" + notification.getOrigin()
+                + "] unknown. LDN message can not be received.");
+            }
+        }
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/LDNMessageRestController.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/LDNMessageRestController.java
new file mode 100644
index 0000000000..92335cb5cc
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/LDNMessageRestController.java
@@ -0,0 +1,94 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static org.dspace.app.rest.utils.RegexUtils.REGEX_REQUESTMAPPING_IDENTIFIER_AS_URN_UUID;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.rest.converter.ConverterService;
+import org.dspace.app.rest.model.LDNMessageEntityRest;
+import org.dspace.app.rest.utils.ContextUtil;
+import org.dspace.app.rest.utils.Utils;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.InitializingBean;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.rest.webmvc.ResourceNotFoundException;
+import org.springframework.hateoas.Link;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.web.bind.annotation.PathVariable;
+import org.springframework.web.bind.annotation.PostMapping;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RestController;
+
+/**
+ * Rest Controller for requesting the reprocessing of LDNMessageEntity
+ *
+ * @author Stefano Maffei (stefano.maffei at 4science.com)
+ */
+@RestController
+@RequestMapping("/api/" + LDNMessageEntityRest.CATEGORY + "/"
+    + LDNMessageEntityRest.NAME_PLURALS + REGEX_REQUESTMAPPING_IDENTIFIER_AS_URN_UUID + "/enqueueretry")
+public class LDNMessageRestController implements InitializingBean {
+
+    private static final Logger log = LogManager.getLogger(LDNMessageRestController.class);
+
+    @Autowired
+    private ConverterService converterService;
+
+    @Autowired
+    private LDNMessageService ldnMessageService;
+
+    @Autowired
+    private Utils utils;
+
+    @Autowired
+    private DiscoverableEndpointsService discoverableEndpointsService;
+
+    @Override
+    public void afterPropertiesSet() {
+        discoverableEndpointsService.register(this,
+            List.of(Link.of("/api/" + LDNMessageEntityRest.CATEGORY + "/"
+                + LDNMessageEntityRest.NAME_PLURALS + "/{id}/enqueueretry",
+                "enqueueretry")));
+    }
+
+    @PostMapping(produces = "application/json")
+    @PreAuthorize("hasAuthority('ADMIN')")
+    public ResponseEntity<String> findByItem(@PathVariable("id") String id)
+        throws SQLException, AuthorizeException, JsonProcessingException {
+
+        Context context = ContextUtil.obtainCurrentRequestContext();
+        LDNMessageEntity ldnMessageEntity = ldnMessageService.find(context, id);
+        if (ldnMessageEntity == null) {
+            throw new ResourceNotFoundException("No such item: " + id);
+        }
+        ldnMessageEntity.setQueueStatus(LDNMessageEntity.QUEUE_STATUS_QUEUED_FOR_RETRY);
+        ldnMessageService.update(context, ldnMessageEntity);
+
+        LDNMessageEntityRest resultRequestStatusRests = converterService.toRest(
+            ldnMessageEntity, utils.obtainProjection());
+
+        context.complete();
+        String result = new ObjectMapper()
+            .writerWithDefaultPrettyPrinter().writeValueAsString(resultRequestStatusRests);
+
+        return new ResponseEntity<>(result, HttpStatus.OK);
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/NotifyRequestStatusRestController.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/NotifyRequestStatusRestController.java
new file mode 100644
index 0000000000..63d6e3cf23
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/NotifyRequestStatusRestController.java
@@ -0,0 +1,107 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static org.dspace.app.rest.utils.RegexUtils.REGEX_REQUESTMAPPING_IDENTIFIER_AS_UUID;
+
+import java.sql.SQLException;
+import java.util.List;
+import java.util.UUID;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.ldn.model.NotifyRequestStatus;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.rest.converter.ConverterService;
+import org.dspace.app.rest.model.NotifyRequestStatusRest;
+import org.dspace.app.rest.utils.ContextUtil;
+import org.dspace.app.rest.utils.Utils;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.authorize.service.AuthorizeService;
+import org.dspace.content.Item;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+import org.springframework.beans.factory.InitializingBean;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.rest.webmvc.ResourceNotFoundException;
+import org.springframework.hateoas.Link;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.web.bind.annotation.GetMapping;
+import org.springframework.web.bind.annotation.PathVariable;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RestController;
+
+
+/**
+ * Rest Controller for NotifyRequestStatus targeting items
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science dot it)
+ */
+@RestController
+@RequestMapping("/api/" + NotifyRequestStatusRest.CATEGORY + "/" + NotifyRequestStatusRest.NAME +
+    REGEX_REQUESTMAPPING_IDENTIFIER_AS_UUID)
+public class NotifyRequestStatusRestController implements InitializingBean {
+
+    private static final Logger log = LogManager.getLogger(NotifyRequestStatusRestController.class);
+
+    @Autowired
+    private ConverterService converterService;
+
+    @Autowired
+    private Utils utils;
+
+    @Autowired
+    private LDNMessageService ldnMessageService;
+
+    @Autowired
+    private ItemService itemService;
+
+    @Autowired
+    private AuthorizeService authorizeService;
+
+    @Autowired
+    private DiscoverableEndpointsService discoverableEndpointsService;
+
+    @Override
+    public void afterPropertiesSet() {
+        discoverableEndpointsService.register(this,
+            List.of(Link.of("/api/" + NotifyRequestStatusRest.CATEGORY + "/" + NotifyRequestStatusRest.NAME,
+                NotifyRequestStatusRest.NAME)));
+    }
+
+    @GetMapping(produces = "application/json")
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    public ResponseEntity<String> findByItem(@PathVariable UUID uuid)
+        throws SQLException, AuthorizeException, JsonProcessingException {
+
+        Context context = ContextUtil.obtainCurrentRequestContext();
+        Item item = itemService.find(context, uuid);
+        if (item == null) {
+            throw new ResourceNotFoundException("No such item: " + uuid);
+        }
+        EPerson currentUser = context.getCurrentUser();
+        if (!currentUser.equals(item.getSubmitter()) && !authorizeService.isAdmin(context)) {
+            throw new AuthorizeException("User unauthorized");
+        }
+        NotifyRequestStatus resultRequests = ldnMessageService.findRequestsByItem(context, item);
+        NotifyRequestStatusRest resultRequestStatusRests = converterService.toRest(
+            resultRequests, utils.obtainProjection());
+
+        context.complete();
+        String result = new ObjectMapper()
+            .writerWithDefaultPrettyPrinter().writeValueAsString(resultRequestStatusRests);
+
+        return new ResponseEntity<>(result, HttpStatus.OK);
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/QAEventRelatedRestController.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/QAEventRelatedRestController.java
new file mode 100644
index 0000000000..e45e292c65
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/QAEventRelatedRestController.java
@@ -0,0 +1,142 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static org.dspace.app.rest.utils.RegexUtils.REGEX_REQUESTMAPPING_IDENTIFIER_AS_STRING_VERSION_STRONG;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.UUID;
+
+import org.dspace.app.rest.converter.ConverterService;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.ItemRest;
+import org.dspace.app.rest.model.QAEventRest;
+import org.dspace.app.rest.model.hateoas.ItemResource;
+import org.dspace.app.rest.utils.ContextUtil;
+import org.dspace.app.rest.utils.Utils;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.qaevent.service.QAEventService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.rest.webmvc.ControllerUtils;
+import org.springframework.data.rest.webmvc.ResourceNotFoundException;
+import org.springframework.hateoas.RepresentationModel;
+import org.springframework.http.HttpHeaders;
+import org.springframework.http.HttpStatus;
+import org.springframework.http.ResponseEntity;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.web.bind.annotation.DeleteMapping;
+import org.springframework.web.bind.annotation.PathVariable;
+import org.springframework.web.bind.annotation.PostMapping;
+import org.springframework.web.bind.annotation.RequestMapping;
+import org.springframework.web.bind.annotation.RequestParam;
+import org.springframework.web.bind.annotation.RestController;
+
+/**
+ * This RestController will take care to manipulate the related item eventually
+ * associated with a qa event
+ * "/api/integration/qualityassuranceevents/{qaeventid}/related"
+ */
+@RestController
+@RequestMapping("/api/" + QAEventRest.CATEGORY + "/" + QAEventRest.PLURAL_NAME
+    + REGEX_REQUESTMAPPING_IDENTIFIER_AS_STRING_VERSION_STRONG + "/" + QAEventRest.RELATED)
+public class QAEventRelatedRestController {
+
+    @Autowired
+    protected Utils utils;
+
+    @Autowired
+    private ConverterService converterService;
+
+    @Autowired
+    private ItemService itemService;
+
+    @Autowired
+    private QAEventService qaEventService;
+
+    /**
+     * This method associate an item to a qa event
+     * 
+     * @param id       The qa event id
+     * @param relatedItemUUID The uuid of the related item to associate with the qa event
+     * @return The related item
+     * @throws SQLException       If something goes wrong
+     * @throws AuthorizeException If something goes wrong
+     */
+    @PostMapping
+    @PreAuthorize("hasAuthority('ADMIN')")
+    public ResponseEntity<RepresentationModel<?>> addRelatedItem(@PathVariable(name = "id") String id,
+        @RequestParam(name = "item") UUID relatedItemUUID) throws SQLException, AuthorizeException {
+
+        Context context = ContextUtil.obtainCurrentRequestContext();
+        QAEvent qaevent = qaEventService.findEventByEventId(id);
+        if (qaevent == null) {
+            throw new ResourceNotFoundException("No such qa event: " + id);
+        }
+
+        if (!qaEventService.isRelatedItemSupported(qaevent)) {
+            throw new UnprocessableEntityException("The given event does not supports a related item");
+        }
+
+        if (qaevent.getRelated() != null) {
+            throw new UnprocessableEntityException("The given event already has a related item");
+        }
+
+        Item relatedItem = itemService.find(context, relatedItemUUID);
+        if (relatedItem == null) {
+            throw new UnprocessableEntityException("The proposed related item was not found");
+        }
+
+        qaevent.setRelated(relatedItemUUID.toString());
+        qaEventService.store(context, qaevent);
+
+        ItemRest relatedItemRest = converterService.toRest(relatedItem, utils.obtainProjection());
+        ItemResource itemResource = converterService.toResource(relatedItemRest);
+
+        context.complete();
+
+        return ControllerUtils.toResponseEntity(HttpStatus.CREATED, new HttpHeaders(), itemResource);
+    }
+
+    /**
+     * This method remove the association to a related item from a qa event
+     * 
+     * @param id       The qa event id
+     * @return The related item
+     * @throws SQLException       If something goes wrong
+     * @throws AuthorizeException If something goes wrong
+     */
+    @DeleteMapping
+    @PreAuthorize("hasAuthority('ADMIN')")
+    public ResponseEntity<RepresentationModel<?>> removeRelatedItem(@PathVariable(name = "id") String id)
+        throws SQLException, AuthorizeException, IOException {
+
+        Context context = ContextUtil.obtainCurrentRequestContext();
+        QAEvent qaevent = qaEventService.findEventByEventId(id);
+
+        if (qaevent == null) {
+            throw new ResourceNotFoundException("No such qa event: " + id);
+        }
+
+        if (!qaEventService.isRelatedItemSupported(qaevent)) {
+            throw new UnprocessableEntityException("The given event does not supports a related item");
+        }
+
+        if (qaevent.getRelated() != null) {
+            qaevent.setRelated(null);
+            qaEventService.store(context, qaevent);
+            context.complete();
+        }
+
+        return ControllerUtils.toEmptyResponse(HttpStatus.NO_CONTENT);
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/RestResourceController.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/RestResourceController.java
index b82b483075..b92e03b478 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/RestResourceController.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/RestResourceController.java
@@ -151,7 +151,7 @@ public class RestResourceController implements InitializingBean {
      */
     @RequestMapping(method = RequestMethod.GET, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_DIGIT)
     public HALResource<RestAddressableModel> findOne(@PathVariable String apiCategory, @PathVariable String model,
-                                                        @PathVariable Integer id) {
+                                                     @PathVariable Integer id) {
         return findOneInternal(apiCategory, model, id);
     }
 
@@ -182,7 +182,7 @@ public class RestResourceController implements InitializingBean {
      */
     @RequestMapping(method = RequestMethod.GET, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_STRING_VERSION_STRONG)
     public HALResource<RestAddressableModel> findOne(@PathVariable String apiCategory, @PathVariable String model,
-                                                        @PathVariable String id) {
+                                                     @PathVariable String id) {
         return findOneInternal(apiCategory, model, id);
     }
 
@@ -202,7 +202,7 @@ public class RestResourceController implements InitializingBean {
      */
     @RequestMapping(method = RequestMethod.GET, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_UUID)
     public HALResource<RestAddressableModel> findOne(@PathVariable String apiCategory, @PathVariable String model,
-                                                        @PathVariable UUID uuid) {
+                                                     @PathVariable UUID uuid) {
         return findOneInternal(apiCategory, model, uuid);
     }
 
@@ -215,7 +215,7 @@ public class RestResourceController implements InitializingBean {
      * @return single DSpaceResource
      */
     private <ID extends Serializable> HALResource<RestAddressableModel> findOneInternal(String apiCategory,
-                                                                                           String model, ID id) {
+                                                                                        String model, ID id) {
         DSpaceRestRepository<RestAddressableModel, ID> repository = utils.getResourceRepository(apiCategory, model);
         Optional<RestAddressableModel> modelObject = Optional.empty();
         try {
@@ -245,10 +245,10 @@ public class RestResourceController implements InitializingBean {
      */
     @RequestMapping(method = RequestMethod.GET, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_DIGIT + "/{rel}")
     public RepresentationModel findRel(HttpServletRequest request, HttpServletResponse response,
-                                   @PathVariable String apiCategory,
-                                   @PathVariable String model, @PathVariable Integer id, @PathVariable String rel,
-                                   Pageable page,
-                                   PagedResourcesAssembler assembler) {
+                                       @PathVariable String apiCategory,
+                                       @PathVariable String model, @PathVariable Integer id, @PathVariable String rel,
+                                       Pageable page,
+                                       PagedResourcesAssembler assembler) {
         return findRelInternal(request, response, apiCategory, model, id, rel, page, assembler);
     }
 
@@ -269,12 +269,12 @@ public class RestResourceController implements InitializingBean {
      * @return single RepresentationModel
      */
     @RequestMapping(method = RequestMethod.GET, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_STRING_VERSION_STRONG +
-        "/{rel}")
+            "/{rel}")
     public RepresentationModel findRel(HttpServletRequest request, HttpServletResponse response,
-                                   @PathVariable String apiCategory,
-                                   @PathVariable String model, @PathVariable String id, @PathVariable String rel,
-                                   Pageable page,
-                                   PagedResourcesAssembler assembler) {
+                                       @PathVariable String apiCategory,
+                                       @PathVariable String model, @PathVariable String id, @PathVariable String rel,
+                                       Pageable page,
+                                       PagedResourcesAssembler assembler) {
         return findRelInternal(request, response, apiCategory, model, id, rel, page, assembler);
     }
 
@@ -294,10 +294,10 @@ public class RestResourceController implements InitializingBean {
      */
     @RequestMapping(method = RequestMethod.GET, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_UUID + "/{rel}")
     public RepresentationModel findRel(HttpServletRequest request, HttpServletResponse response,
-                                   @PathVariable String apiCategory,
-                                   @PathVariable String model, @PathVariable UUID uuid, @PathVariable String rel,
-                                   Pageable page,
-                                   PagedResourcesAssembler assembler) {
+                                       @PathVariable String apiCategory,
+                                       @PathVariable String model, @PathVariable UUID uuid, @PathVariable String rel,
+                                       Pageable page,
+                                       PagedResourcesAssembler assembler) {
         return findRelInternal(request, response, apiCategory, model, uuid, rel, page, assembler);
     }
 
@@ -334,17 +334,17 @@ public class RestResourceController implements InitializingBean {
      * @return
      */
     @RequestMapping(method = RequestMethod.GET, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_STRING_VERSION_STRONG +
-        "/{rel}/{relid}")
+            "/{rel}/{relid}")
     public RepresentationModel findRel(HttpServletRequest request, HttpServletResponse response,
-                                   @PathVariable String apiCategory,
-                                   @PathVariable String model, @PathVariable String id, @PathVariable String rel,
-                                   @PathVariable String relid,
-                                   Pageable page, PagedResourcesAssembler assembler) throws Throwable {
+                                       @PathVariable String apiCategory,
+                                       @PathVariable String model, @PathVariable String id, @PathVariable String rel,
+                                       @PathVariable String relid,
+                                       Pageable page, PagedResourcesAssembler assembler) throws Throwable {
         return findRelEntryInternal(request, response, apiCategory, model, id, rel, relid, page, assembler);
     }
 
     @RequestMapping(method = RequestMethod.GET, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_DIGIT +
-        "/{rel}/{relid}")
+            "/{rel}/{relid}")
     public RepresentationModel findRel(HttpServletRequest request, HttpServletResponse response,
                                        @PathVariable String apiCategory,
                                        @PathVariable String model, @PathVariable Integer id, @PathVariable String rel,
@@ -376,7 +376,7 @@ public class RestResourceController implements InitializingBean {
                                                        @PathVariable String apiCategory,
                                                        @PathVariable String model,
                                                        @RequestParam(required = false) String parent)
-        throws HttpRequestMethodNotSupportedException {
+            throws HttpRequestMethodNotSupportedException {
         return postJsonInternal(request, apiCategory, model, parent);
     }
 
@@ -402,7 +402,7 @@ public class RestResourceController implements InitializingBean {
     public ResponseEntity<RepresentationModel<?>> postWithUriListContentType(HttpServletRequest request,
                                                                              @PathVariable String apiCategory,
                                                                              @PathVariable String model)
-        throws HttpRequestMethodNotSupportedException {
+            throws HttpRequestMethodNotSupportedException {
         return postUriListInternal(request, apiCategory, model);
     }
 
@@ -420,7 +420,7 @@ public class RestResourceController implements InitializingBean {
                                                                                              String apiCategory,
                                                                                              String model,
                                                                                              String parent)
-        throws HttpRequestMethodNotSupportedException {
+            throws HttpRequestMethodNotSupportedException {
         checkModelPluralForm(apiCategory, model);
         DSpaceRestRepository<RestAddressableModel, ID> repository = utils.getResourceRepository(apiCategory, model);
 
@@ -452,7 +452,7 @@ public class RestResourceController implements InitializingBean {
             HttpServletRequest request,
             String apiCategory,
             String model)
-        throws HttpRequestMethodNotSupportedException {
+            throws HttpRequestMethodNotSupportedException {
         checkModelPluralForm(apiCategory, model);
         DSpaceRestRepository<RestAddressableModel, ID> repository = utils.getResourceRepository(apiCategory, model);
         RestAddressableModel modelObject = null;
@@ -461,7 +461,7 @@ public class RestResourceController implements InitializingBean {
             modelObject = repository.createAndReturn(stringListFromRequest);
         } catch (ClassCastException e) {
             log.error("Something went wrong whilst creating the object for apiCategory: " + apiCategory +
-                          " and model: " + model, e);
+                    " and model: " + model, e);
             return ControllerUtils.toEmptyResponse(HttpStatus.INTERNAL_SERVER_ERROR);
         }
         if (modelObject == null) {
@@ -488,13 +488,13 @@ public class RestResourceController implements InitializingBean {
      * @throws SQLException
      */
     @RequestMapping(method = RequestMethod.POST, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_DIGIT, headers =
-        "content-type=application/x-www-form-urlencoded")
+            "content-type=application/x-www-form-urlencoded")
     public ResponseEntity<RepresentationModel<?>> action(HttpServletRequest request, @PathVariable String apiCategory,
                                                          @PathVariable String model, @PathVariable Integer id)
-        throws HttpRequestMethodNotSupportedException, SQLException, IOException {
+            throws HttpRequestMethodNotSupportedException, SQLException, IOException {
         checkModelPluralForm(apiCategory, model);
         DSpaceRestRepository<RestAddressableModel, Integer> repository =
-            utils.getResourceRepository(apiCategory, model);
+                utils.getResourceRepository(apiCategory, model);
 
         RestAddressableModel modelObject = null;
         try {
@@ -531,14 +531,14 @@ public class RestResourceController implements InitializingBean {
      * @throws HttpRequestMethodNotSupportedException
      */
     @RequestMapping(method = RequestMethod.POST, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_DIGIT, headers =
-        "content-type=multipart/form-data")
+            "content-type=multipart/form-data")
     public <ID extends Serializable> ResponseEntity<RepresentationModel<?>> upload(HttpServletRequest request,
                                                                                    @PathVariable String apiCategory,
                                                                                    @PathVariable String model,
                                                                                    @PathVariable Integer id,
                                                                                    @RequestParam("file") MultipartFile
-                                                                                uploadfile)
-        throws HttpRequestMethodNotSupportedException {
+                                                                                           uploadfile)
+            throws HttpRequestMethodNotSupportedException {
         return uploadInternal(request, apiCategory, model, id, uploadfile);
     }
 
@@ -561,14 +561,14 @@ public class RestResourceController implements InitializingBean {
      * @throws HttpRequestMethodNotSupportedException
      */
     @RequestMapping(method = RequestMethod.POST, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_UUID, headers =
-        "content-type=multipart/form-data")
+            "content-type=multipart/form-data")
     public <ID extends Serializable> ResponseEntity<RepresentationModel<?>> upload(HttpServletRequest request,
                                                                                    @PathVariable String apiCategory,
                                                                                    @PathVariable String model,
                                                                                    @PathVariable UUID uuid,
                                                                                    @RequestParam("file") MultipartFile
-                                                                                uploadfile)
-        throws HttpRequestMethodNotSupportedException {
+                                                                                           uploadfile)
+            throws HttpRequestMethodNotSupportedException {
         return uploadInternal(request, apiCategory, model, uuid, uploadfile);
     }
 
@@ -594,7 +594,7 @@ public class RestResourceController implements InitializingBean {
             modelObject = repository.upload(request, apiCategory, model, id, uploadfile);
         } catch (SQLException | IOException e) {
             throw new RuntimeException("Error " + e.getMessage() +
-                                       " uploading file to " + model + " with ID= " + id, e);
+                    " uploading file to " + model + " with ID= " + id, e);
         } catch ( AuthorizeException ae) {
             throw new RESTAuthorizationException(ae);
         }
@@ -626,7 +626,7 @@ public class RestResourceController implements InitializingBean {
             @PathVariable String apiCategory,
             @PathVariable String model,
             @RequestParam("file") List<MultipartFile> uploadfile)
-        throws SQLException, FileNotFoundException, IOException, AuthorizeException {
+            throws SQLException, FileNotFoundException, IOException, AuthorizeException {
 
         checkModelPluralForm(apiCategory, model);
         DSpaceRestRepository repository = utils.getResourceRepository(apiCategory, model);
@@ -684,6 +684,28 @@ public class RestResourceController implements InitializingBean {
         return patchInternal(request, apiCategory, model, id, jsonNode);
     }
 
+    /**
+     * PATCH method, using operation on the resources following (JSON) Patch notation (https://tools.ietf
+     * .org/html/rfc6902)
+     *
+     * Note that the regular expression in the request mapping accept a UUID as identifier;
+     *
+     * @param request
+     * @param apiCategory
+     * @param model
+     * @param id
+     * @param jsonNode
+     * @return
+     * @throws HttpRequestMethodNotSupportedException
+     */
+    @RequestMapping(method = RequestMethod.PATCH, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_STRING_VERSION_STRONG)
+    public ResponseEntity<RepresentationModel<?>> patch(HttpServletRequest request, @PathVariable String apiCategory,
+                                                        @PathVariable String model,
+                                                        @PathVariable String id,
+                                                        @RequestBody(required = true) JsonNode jsonNode) {
+        return patchInternal(request, apiCategory, model, id, jsonNode);
+    }
+
     /**
      * Internal patch method
      *
@@ -707,7 +729,7 @@ public class RestResourceController implements InitializingBean {
             Patch patch = patchConverter.convert(jsonNode);
             modelObject = repository.patch(request, apiCategory, model, id, patch);
         } catch (RepositoryMethodNotImplementedException | UnprocessableEntityException |
-            DSpaceBadRequestException | ResourceNotFoundException e) {
+                 DSpaceBadRequestException | ResourceNotFoundException e) {
             log.error(e.getMessage(), e);
             throw e;
         }
@@ -731,11 +753,11 @@ public class RestResourceController implements InitializingBean {
      * @return
      */
     private <ID extends Serializable> RepresentationModel findRelEntryInternal(HttpServletRequest request,
-                                                                           HttpServletResponse response,
-                                                                           String apiCategory, String model,
-                                                                           String id, String rel, String relid,
-                                                                           Pageable page,
-                                                                           PagedResourcesAssembler assembler)
+                                                                               HttpServletResponse response,
+                                                                               String apiCategory, String model,
+                                                                               String id, String rel, String relid,
+                                                                               Pageable page,
+                                                                               PagedResourcesAssembler assembler)
             throws Throwable {
         checkModelPluralForm(apiCategory, model);
         DSpaceRestRepository<RestAddressableModel, ID> repository = utils.getResourceRepository(apiCategory, model);
@@ -760,7 +782,7 @@ public class RestResourceController implements InitializingBean {
                 // InvocationTargetException and thrown as a RunTimeException when it was actually an AccessDenied
                 // Exception and it should be returned/shown as one
                 if (e.getTargetException() instanceof AccessDeniedException ||
-                    e.getTargetException() instanceof ResourceNotFoundException) {
+                        e.getTargetException() instanceof ResourceNotFoundException) {
                     throw e.getTargetException();
                 } else {
                     throw new RuntimeException(e.getMessage(), e);
@@ -783,11 +805,9 @@ public class RestResourceController implements InitializingBean {
      * @param assembler
      * @return
      */
-    private <ID extends Serializable> RepresentationModel findRelInternal(HttpServletRequest request,
-                                                                      HttpServletResponse response, String apiCategory,
-                                                                      String model, ID uuid, String subpath,
-                                                                      Pageable page,
-                                                                      PagedResourcesAssembler assembler) {
+    private <ID extends Serializable> RepresentationModel
+        findRelInternal(HttpServletRequest request, HttpServletResponse response, String apiCategory,
+                String model, ID uuid, String subpath, Pageable page, PagedResourcesAssembler assembler) {
         checkModelPluralForm(apiCategory, model);
         DSpaceRestRepository<RestAddressableModel, ID> repository = utils.getResourceRepository(apiCategory, model);
         Class<RestAddressableModel> domainClass = repository.getDomainClass();
@@ -816,7 +836,7 @@ public class RestResourceController implements InitializingBean {
                     String querystring = request.getQueryString();
                     if (querystring != null && querystring.length() > 0) {
                         link = linkTo(this.getClass(), apiCategory, model).slash(uuid)
-                            .slash(subpath + '?' + querystring).withSelfRel();
+                                .slash(subpath + '?' + querystring).withSelfRel();
                     } else {
                         link = linkTo(this.getClass(), apiCategory, model).slash(uuid).slash(subpath).withSelfRel();
                     }
@@ -891,9 +911,9 @@ public class RestResourceController implements InitializingBean {
             int start = Math.toIntExact(page.getOffset());
             int end = (start + page.getPageSize()) > fullList.size() ? fullList.size() : (start + page.getPageSize());
             DSpaceRestRepository<RestAddressableModel, ?> resourceRepository = utils
-                .getResourceRepository(fullList.get(0).getCategory(), fullList.get(0).getType());
+                    .getResourceRepository(fullList.get(0).getCategory(), fullList.get(0).getType());
             PageImpl<RestAddressableModel> pageResult = new PageImpl(fullList.subList(start, end), page,
-                                                                     fullList.size());
+                    fullList.size());
             return assembler.toModel(pageResult.map(converter::toResource));
         } else {
             if (resource.getEmbeddedResources().get(rel) == null) {
@@ -915,9 +935,10 @@ public class RestResourceController implements InitializingBean {
      */
     @RequestMapping(method = RequestMethod.GET)
     @SuppressWarnings("unchecked")
-    public <T extends RestAddressableModel> PagedModel<DSpaceResource<T>> findAll(@PathVariable String apiCategory,
-            @PathVariable String model, Pageable page, PagedResourcesAssembler assembler, HttpServletResponse response,
-            @RequestParam MultiValueMap<String, Object> parameters) {
+    public <T extends RestAddressableModel> PagedModel<DSpaceResource<T>>
+        findAll(@PathVariable String apiCategory,
+                @PathVariable String model, Pageable page, PagedResourcesAssembler assembler,
+                HttpServletResponse response, @RequestParam MultiValueMap<String, Object> parameters) {
 
         String encodedParameterString = getEncodedParameterStringFromRequestParams(parameters);
         DSpaceRestRepository<T, ?> repository = utils.getResourceRepository(apiCategory, model);
@@ -976,11 +997,11 @@ public class RestResourceController implements InitializingBean {
             Pageable pageable, Sort sort,
             PagedResourcesAssembler assembler,
             @RequestParam MultiValueMap<String, Object> parameters)
-        throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
+            throws IllegalAccessException, IllegalArgumentException, InvocationTargetException {
         String encodedParameterString = getEncodedParameterStringFromRequestParams(parameters);
 
         Link link = linkTo(this.getClass(), apiCategory, model).slash("search").slash(searchMethodName)
-                                                               .slash(encodedParameterString).withSelfRel();
+                .slash(encodedParameterString).withSelfRel();
         DSpaceRestRepository repository = utils.getResourceRepository(apiCategory, model);
         boolean returnPage = false;
         Object searchResult = null;
@@ -996,7 +1017,7 @@ public class RestResourceController implements InitializingBean {
         }
 
         searchResult = repositoryUtils
-            .executeQueryMethod(repository, parameters, searchMethod, pageable, sort, assembler);
+                .executeQueryMethod(repository, parameters, searchMethod, pageable, sort, assembler);
 
         returnPage = searchMethod.getReturnType().isAssignableFrom(Page.class);
         RepresentationModel result = null;
@@ -1036,20 +1057,38 @@ public class RestResourceController implements InitializingBean {
         return uriComponentsBuilder.encode().build().toString();
     }
 
+    /**
+     * Method to delete an entity by ID
+     * Note that the regular expression in the request mapping accept a number as identifier;
+     *
+     * @param request
+     * @param apiCategory
+     * @param model
+     * @param id
+     * @return
+     * @throws HttpRequestMethodNotSupportedException
+     */
     @RequestMapping(method = RequestMethod.DELETE, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_DIGIT)
     public ResponseEntity<RepresentationModel<?>> delete(HttpServletRequest request, @PathVariable String apiCategory,
                                                          @PathVariable String model, @PathVariable Integer id)
-        throws HttpRequestMethodNotSupportedException {
+            throws HttpRequestMethodNotSupportedException {
         return deleteInternal(apiCategory, model, id);
     }
 
     @RequestMapping(method = RequestMethod.DELETE, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_UUID)
     public ResponseEntity<RepresentationModel<?>> delete(HttpServletRequest request, @PathVariable String apiCategory,
                                                          @PathVariable String model, @PathVariable UUID uuid)
-        throws HttpRequestMethodNotSupportedException {
+            throws HttpRequestMethodNotSupportedException {
         return deleteInternal(apiCategory, model, uuid);
     }
 
+    @RequestMapping(method = RequestMethod.DELETE, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_STRING_VERSION_STRONG)
+    public ResponseEntity<RepresentationModel<?>> delete(HttpServletRequest request, @PathVariable String apiCategory,
+                                                         @PathVariable String model, @PathVariable String id)
+        throws HttpRequestMethodNotSupportedException {
+        return deleteInternal(apiCategory, model, id);
+    }
+
     /**
      * Internal method to delete resource.
      *
@@ -1114,7 +1153,7 @@ public class RestResourceController implements InitializingBean {
      * @return the relevant REST resource
      */
     @RequestMapping(method = RequestMethod.PUT, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_DIGIT,
-        consumes = {"application/json", "application/hal+json"})
+            consumes = {"application/json", "application/hal+json"})
     public DSpaceResource<RestAddressableModel> put(HttpServletRequest request,
                                                     @PathVariable String apiCategory, @PathVariable String model,
                                                     @PathVariable Integer id,
@@ -1141,7 +1180,7 @@ public class RestResourceController implements InitializingBean {
      * @return the relevant REST resource
      */
     @RequestMapping(method = RequestMethod.PUT, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_DIGIT,
-        consumes = {"text/uri-list"})
+            consumes = {"text/uri-list"})
     public DSpaceResource<RestAddressableModel> put(HttpServletRequest request,
                                                     @PathVariable String apiCategory, @PathVariable String model,
                                                     @PathVariable Integer id) throws IOException {
@@ -1170,7 +1209,7 @@ public class RestResourceController implements InitializingBean {
      * @return the relevant REST resource
      */
     @RequestMapping(method = RequestMethod.PUT, value = REGEX_REQUESTMAPPING_IDENTIFIER_AS_HEX32,
-        consumes = {"application/json", "application/hal+json"})
+            consumes = {"application/json", "application/hal+json"})
     public DSpaceResource<RestAddressableModel> put(HttpServletRequest request,
                                                     @PathVariable String apiCategory, @PathVariable String model,
                                                     @PathVariable String id,
@@ -1189,7 +1228,7 @@ public class RestResourceController implements InitializingBean {
      * @return              The relevant DSpaceResource for this request
      */
     private <ID extends Serializable> DSpaceResource<RestAddressableModel> putOneJsonInternal(
-        HttpServletRequest request, String apiCategory, String model, ID id, JsonNode jsonNode) {
+            HttpServletRequest request, String apiCategory, String model, ID id, JsonNode jsonNode) {
         checkModelPluralForm(apiCategory, model);
         DSpaceRestRepository<RestAddressableModel, ID> repository = utils.getResourceRepository(apiCategory, model);
         RestAddressableModel modelObject = null;
@@ -1211,7 +1250,7 @@ public class RestResourceController implements InitializingBean {
      * @throws IOException  If something goes wrong
      */
     private <ID extends Serializable> DSpaceResource<RestAddressableModel> putOneUriListInternal(
-        HttpServletRequest request, String apiCategory, String model, ID id) throws IOException {
+            HttpServletRequest request, String apiCategory, String model, ID id) throws IOException {
         checkModelPluralForm(apiCategory, model);
         DSpaceRestRepository<RestAddressableModel, ID> repository = utils.getResourceRepository(apiCategory, model);
         RestAddressableModel modelObject = null;
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/CoarNotifyEnabled.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/CoarNotifyEnabled.java
new file mode 100644
index 0000000000..5ef8410e08
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/CoarNotifyEnabled.java
@@ -0,0 +1,42 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.authorization.impl;
+
+import java.sql.SQLException;
+
+import org.dspace.app.rest.authorization.AuthorizationFeature;
+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;
+import org.dspace.app.rest.model.BaseObjectRest;
+import org.dspace.app.rest.model.SiteRest;
+import org.dspace.core.Context;
+import org.dspace.discovery.SearchServiceException;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+@Component
+@AuthorizationFeatureDocumentation(name = CoarNotifyEnabled.NAME,
+        description = "It can be used to verify if the user can see the coar notify protocol is enabled")
+public class CoarNotifyEnabled implements AuthorizationFeature {
+
+    public final static String NAME = "coarNotifyEnabled";
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    @Override
+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException, SearchServiceException {
+        return configurationService.getBooleanProperty("ldn.enabled", true);
+    }
+
+    @Override
+    public String[] getSupportedTypes() {
+        return new String[]{ SiteRest.CATEGORY + "." + SiteRest.NAME };
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/QAAuthorizationFeature.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/QAAuthorizationFeature.java
new file mode 100644
index 0000000000..332c7a5989
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/authorization/impl/QAAuthorizationFeature.java
@@ -0,0 +1,46 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.authorization.impl;
+
+import java.sql.SQLException;
+
+import org.dspace.app.rest.authorization.AuthorizationFeature;
+import org.dspace.app.rest.authorization.AuthorizationFeatureDocumentation;
+import org.dspace.app.rest.model.BaseObjectRest;
+import org.dspace.app.rest.model.SiteRest;
+import org.dspace.core.Context;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * The QA Event feature. It can be used to verify if Quality Assurance can be seen.
+ *
+ * Authorization is granted if the current user has READ permissions on the given bitstream.
+ */
+@Component
+@AuthorizationFeatureDocumentation(name = QAAuthorizationFeature.NAME,
+        description = "It can be used to verify if the user can manage Quality Assurance events")
+public class QAAuthorizationFeature implements AuthorizationFeature {
+    public final static String NAME = "canSeeQA";
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    @Override
+    public boolean isAuthorized(Context context, BaseObjectRest object) throws SQLException {
+        return configurationService.getBooleanProperty("qaevents.enabled", false);
+    }
+
+    @Override
+    public String[] getSupportedTypes() {
+        return new String[]{
+            SiteRest.CATEGORY + "." + SiteRest.NAME
+        };
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/CorrectionTypeConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/CorrectionTypeConverter.java
new file mode 100644
index 0000000000..58330fdfae
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/CorrectionTypeConverter.java
@@ -0,0 +1,38 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import org.dspace.app.rest.model.CorrectionTypeRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.correctiontype.CorrectionType;
+import org.springframework.stereotype.Component;
+
+/**
+ * This class provides the method to convert a CorrectionType to its REST representation, the
+ * CorrectionTypeRest
+ * 
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@Component
+public class CorrectionTypeConverter implements DSpaceConverter<CorrectionType, CorrectionTypeRest> {
+
+    @Override
+    public CorrectionTypeRest convert(CorrectionType target, Projection projection) {
+        CorrectionTypeRest targetRest = new CorrectionTypeRest();
+        targetRest.setProjection(projection);
+        targetRest.setId(target.getId());
+        targetRest.setTopic(target.getTopic());
+        return targetRest;
+    }
+
+    @Override
+    public Class<CorrectionType> getModelClass() {
+        return CorrectionType.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/ItemFilterConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/ItemFilterConverter.java
new file mode 100644
index 0000000000..b058ef057c
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/ItemFilterConverter.java
@@ -0,0 +1,35 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import org.dspace.app.ldn.ItemFilter;
+import org.dspace.app.rest.model.ItemFilterRest;
+import org.dspace.app.rest.projection.Projection;
+import org.springframework.stereotype.Component;
+
+/**
+ * This is the converter from the ItemFilter to the REST data model
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@Component
+public class ItemFilterConverter implements DSpaceConverter<ItemFilter, ItemFilterRest> {
+
+    @Override
+    public ItemFilterRest convert(ItemFilter obj, Projection projection) {
+        ItemFilterRest itemFilterRest = new ItemFilterRest();
+        itemFilterRest.setProjection(projection);
+        itemFilterRest.setId(obj.getId());
+        return itemFilterRest;
+    }
+
+    @Override
+    public Class<ItemFilter> getModelClass() {
+        return ItemFilter.class;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/LDNMessageEntityConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/LDNMessageEntityConverter.java
new file mode 100644
index 0000000000..1c0783aec4
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/LDNMessageEntityConverter.java
@@ -0,0 +1,71 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import java.util.UUID;
+
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.rest.model.LDNMessageEntityRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.content.DSpaceObject;
+import org.dspace.discovery.IndexableObject;
+import org.springframework.stereotype.Component;
+
+/**
+ * Converter to translate between {@link LDNMessageEntity} and {@link LDNMessageEntityRest} representations.
+ *  @author Stefano Maffei (stefano.maffei at 4science.com)
+ */
+@Component
+public class LDNMessageEntityConverter implements IndexableObjectConverter<LDNMessageEntity, LDNMessageEntityRest> {
+
+    @Override
+    public LDNMessageEntityRest convert(LDNMessageEntity obj, Projection projection) {
+        LDNMessageEntityRest ldnRest = new LDNMessageEntityRest();
+        ldnRest.setNotificationId(obj.getID());
+        ldnRest.setId(obj.getID());
+        ldnRest.setQueueStatus(obj.getQueueStatus());
+        ldnRest.setQueueStatusLabel(LDNMessageEntity.getQueueStatus(obj));
+        ldnRest.setContext(getObjectIdentifier(obj.getContext()));
+        ldnRest.setObject(getObjectIdentifier(obj.getObject()));
+        ldnRest.setActivityStreamType(obj.getActivityStreamType());
+        ldnRest.setCoarNotifyType(obj.getCoarNotifyType());
+        ldnRest.setTarget(getObjectIdentifier(obj.getTarget()));
+        ldnRest.setOrigin(getObjectIdentifier(obj.getOrigin()));
+        ldnRest.setInReplyTo(getObjectIdentifier(obj.getInReplyTo()));
+        ldnRest.setQueueAttempts(obj.getQueueAttempts());
+        ldnRest.setQueueLastStartTime(obj.getQueueLastStartTime());
+        ldnRest.setQueueTimeout(obj.getQueueTimeout());
+        ldnRest.setMessage(obj.getMessage());
+        ldnRest.setNotificationType(LDNMessageEntity.getNotificationType(obj));
+        return ldnRest;
+    }
+
+    private UUID getObjectIdentifier(DSpaceObject dso) {
+        return dso == null ? null : dso.getID();
+    }
+
+    private Integer getObjectIdentifier(NotifyServiceEntity nse) {
+        return nse == null ? null : nse.getID();
+    }
+
+    private String getObjectIdentifier(LDNMessageEntity msg) {
+        return msg == null ? null : msg.getID();
+    }
+
+    @Override
+    public Class<LDNMessageEntity> getModelClass() {
+        return LDNMessageEntity.class;
+    }
+
+    @Override
+    public boolean supportsModel(IndexableObject idxo) {
+        return idxo.getIndexedObject() instanceof LDNMessageEntity;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/NotifyRequestStatusConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/NotifyRequestStatusConverter.java
new file mode 100644
index 0000000000..d4a6efceee
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/NotifyRequestStatusConverter.java
@@ -0,0 +1,37 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import org.dspace.app.ldn.model.NotifyRequestStatus;
+import org.dspace.app.rest.model.NotifyRequestStatusRest;
+import org.dspace.app.rest.projection.Projection;
+import org.springframework.stereotype.Component;
+
+/**
+ * This is the converter from/to the NotifyRequestStatus in the DSpace API data model and
+ * the REST data model
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ */
+@Component
+public class NotifyRequestStatusConverter implements DSpaceConverter<NotifyRequestStatus, NotifyRequestStatusRest> {
+
+    @Override
+    public NotifyRequestStatusRest convert(NotifyRequestStatus modelObject, Projection projection) {
+        NotifyRequestStatusRest result = new NotifyRequestStatusRest();
+        result.setItemuuid(modelObject.getItemUuid());
+        result.setNotifyStatus(modelObject.getNotifyStatus());
+        return result;
+    }
+
+    @Override
+    public Class<NotifyRequestStatus> getModelClass() {
+        return NotifyRequestStatus.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/NotifyServiceConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/NotifyServiceConverter.java
new file mode 100644
index 0000000000..8e0225f43f
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/NotifyServiceConverter.java
@@ -0,0 +1,68 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.rest.model.NotifyServiceInboundPatternRest;
+import org.dspace.app.rest.model.NotifyServiceRest;
+import org.dspace.app.rest.projection.Projection;
+import org.springframework.stereotype.Component;
+
+/**
+ * This is the converter from the NotifyServiceEntity to the REST data model
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@Component
+public class NotifyServiceConverter implements DSpaceConverter<NotifyServiceEntity, NotifyServiceRest> {
+
+    @Override
+    public NotifyServiceRest convert(NotifyServiceEntity obj, Projection projection) {
+        NotifyServiceRest notifyServiceRest = new NotifyServiceRest();
+
+        notifyServiceRest.setProjection(projection);
+        notifyServiceRest.setId(obj.getID());
+        notifyServiceRest.setName(obj.getName());
+        notifyServiceRest.setDescription(obj.getDescription());
+        notifyServiceRest.setUrl(obj.getUrl());
+        notifyServiceRest.setLdnUrl(obj.getLdnUrl());
+        notifyServiceRest.setEnabled(obj.isEnabled());
+        notifyServiceRest.setScore(obj.getScore());
+        notifyServiceRest.setLowerIp(obj.getLowerIp());
+        notifyServiceRest.setUpperIp(obj.getUpperIp());
+
+        if (obj.getInboundPatterns() != null) {
+            notifyServiceRest.setNotifyServiceInboundPatterns(
+                convertInboundPatternToRest(obj.getInboundPatterns()));
+        }
+
+        return notifyServiceRest;
+    }
+
+    private List<NotifyServiceInboundPatternRest> convertInboundPatternToRest(
+        List<NotifyServiceInboundPattern> inboundPatterns) {
+        List<NotifyServiceInboundPatternRest> inboundPatternRests = new ArrayList<>();
+        for (NotifyServiceInboundPattern inboundPattern : inboundPatterns) {
+            NotifyServiceInboundPatternRest inboundPatternRest = new NotifyServiceInboundPatternRest();
+            inboundPatternRest.setPattern(inboundPattern.getPattern());
+            inboundPatternRest.setConstraint(inboundPattern.getConstraint());
+            inboundPatternRest.setAutomatic(inboundPattern.isAutomatic());
+            inboundPatternRests.add(inboundPatternRest);
+        }
+        return inboundPatternRests;
+    }
+
+    @Override
+    public Class<NotifyServiceEntity> getModelClass() {
+        return NotifyServiceEntity.class;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/QAEventConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/QAEventConverter.java
new file mode 100644
index 0000000000..b908bf3e41
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/QAEventConverter.java
@@ -0,0 +1,145 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.util.Locale;
+import javax.annotation.PostConstruct;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.DeserializationFeature;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.json.JsonMapper;
+import org.dspace.app.rest.model.CorrectionTypeQAEventMessageRest;
+import org.dspace.app.rest.model.NotifyQAEventMessageRest;
+import org.dspace.app.rest.model.OpenaireQAEventMessageRest;
+import org.dspace.app.rest.model.QAEventMessageRest;
+import org.dspace.app.rest.model.QAEventRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.content.QAEvent;
+import org.dspace.qaevent.service.dto.CorrectionTypeMessageDTO;
+import org.dspace.qaevent.service.dto.NotifyMessageDTO;
+import org.dspace.qaevent.service.dto.OpenaireMessageDTO;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+import org.dspace.services.ConfigurationService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation of {@link DSpaceConverter} that converts {@link QAEvent} to
+ * {@link QAEventRest}.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@Component
+public class QAEventConverter implements DSpaceConverter<QAEvent, QAEventRest> {
+
+    private static final String OPENAIRE_PID_HREF_PREFIX_PROPERTY = "qaevents.openaire.pid-href-prefix.";
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    private ObjectMapper jsonMapper;
+
+    @PostConstruct
+    public void setup() {
+        jsonMapper = new JsonMapper();
+        jsonMapper.configure(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES, false);
+    }
+
+    @Override
+    public QAEventRest convert(QAEvent modelObject, Projection projection) {
+        QAEventRest rest = new QAEventRest();
+        rest.setId(modelObject.getEventId());
+        try {
+            rest.setMessage(convertMessage(jsonMapper.readValue(modelObject.getMessage(),
+                                                                modelObject.getMessageDtoClass())));
+        } catch (JsonProcessingException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+        rest.setSource(modelObject.getSource());
+        rest.setOriginalId(modelObject.getOriginalId());
+        rest.setProjection(projection);
+        rest.setTitle(modelObject.getTitle());
+        rest.setTopic(modelObject.getTopic());
+        rest.setEventDate(modelObject.getLastUpdate());
+        DecimalFormat decimalFormat = new DecimalFormat("0.000", new DecimalFormatSymbols(Locale.ENGLISH));
+        rest.setTrust(decimalFormat.format(modelObject.getTrust()));
+        // right now only the pending status can be found in persisted qa events
+        rest.setStatus(modelObject.getStatus());
+        return rest;
+    }
+
+    private QAEventMessageRest convertMessage(QAMessageDTO dto) {
+        if (dto instanceof OpenaireMessageDTO) {
+            return convertOpenaireMessage(dto);
+        } else if (dto instanceof NotifyMessageDTO) {
+            return convertNotifyMessage(dto);
+        }
+        if (dto instanceof CorrectionTypeMessageDTO) {
+            return convertCorrectionTypeMessage(dto);
+        }
+        throw new IllegalArgumentException("Unknown message type: " + dto.getClass());
+    }
+
+    private QAEventMessageRest convertNotifyMessage(QAMessageDTO dto) {
+        NotifyMessageDTO notifyDto = (NotifyMessageDTO) dto;
+        NotifyQAEventMessageRest message = new NotifyQAEventMessageRest();
+        message.setServiceName(notifyDto.getServiceName());
+        message.setServiceId(notifyDto.getServiceId());
+        message.setHref(notifyDto.getHref());
+        message.setRelationship(notifyDto.getRelationship());
+        return message;
+    }
+
+    private QAEventMessageRest convertCorrectionTypeMessage(QAMessageDTO dto) {
+        CorrectionTypeMessageDTO correctionTypeDto = (CorrectionTypeMessageDTO) dto;
+        CorrectionTypeQAEventMessageRest message = new CorrectionTypeQAEventMessageRest();
+        message.setReason(correctionTypeDto.getReason());
+        return message;
+    }
+
+    private QAEventMessageRest convertOpenaireMessage(QAMessageDTO dto) {
+        OpenaireMessageDTO openaireDto = (OpenaireMessageDTO) dto;
+        OpenaireQAEventMessageRest message = new OpenaireQAEventMessageRest();
+        message.setAbstractValue(openaireDto.getAbstracts());
+        message.setOpenaireId(openaireDto.getOpenaireId());
+        message.setAcronym(openaireDto.getAcronym());
+        message.setCode(openaireDto.getCode());
+        message.setFunder(openaireDto.getFunder());
+        message.setFundingProgram(openaireDto.getFundingProgram());
+        message.setJurisdiction(openaireDto.getJurisdiction());
+        message.setTitle(openaireDto.getTitle());
+        message.setType(openaireDto.getType());
+        message.setValue(openaireDto.getValue());
+        message.setPidHref(calculateOpenairePidHref(openaireDto.getType(), openaireDto.getValue()));
+        return message;
+    }
+
+    private String calculateOpenairePidHref(String type, String value) {
+        if (type == null) {
+            return null;
+        }
+
+        String hrefType = type.toLowerCase();
+        if (!configurationService.hasProperty(OPENAIRE_PID_HREF_PREFIX_PROPERTY + hrefType)) {
+            return null;
+        }
+
+        String hrefPrefix = configurationService.getProperty(OPENAIRE_PID_HREF_PREFIX_PROPERTY + hrefType, "");
+        return hrefPrefix + value;
+    }
+
+    @Override
+    public Class<QAEvent> getModelClass() {
+        return QAEvent.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/QASourceConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/QASourceConverter.java
new file mode 100644
index 0000000000..c358c7323e
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/QASourceConverter.java
@@ -0,0 +1,41 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import org.dspace.app.rest.model.QASourceRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.qaevent.QASource;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation of {@link DSpaceConverter} that converts {@link QASource} to
+ * {@link QASourceRest}.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+@Component
+public class QASourceConverter implements DSpaceConverter<QASource, QASourceRest> {
+
+    @Override
+    public Class<QASource> getModelClass() {
+        return QASource.class;
+    }
+
+    @Override
+    public QASourceRest convert(QASource modelObject, Projection projection) {
+        QASourceRest rest = new QASourceRest();
+        rest.setProjection(projection);
+        rest.setId(modelObject.getName()
+                + (modelObject.getFocus() != null ? ":" + modelObject.getFocus().toString() : ""));
+        rest.setLastEvent(modelObject.getLastEvent());
+        rest.setTotalEvents(modelObject.getTotalEvents());
+        return rest;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/QATopicConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/QATopicConverter.java
new file mode 100644
index 0000000000..e6334924c1
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/QATopicConverter.java
@@ -0,0 +1,43 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import org.dspace.app.rest.model.QATopicRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.qaevent.QATopic;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation of {@link DSpaceConverter} that converts {@link QATopic} to
+ * {@link QATopicRest}.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@Component
+public class QATopicConverter implements DSpaceConverter<QATopic, QATopicRest> {
+
+    @Override
+    public Class<QATopic> getModelClass() {
+        return QATopic.class;
+    }
+
+    @Override
+    public QATopicRest convert(QATopic modelObject, Projection projection) {
+        QATopicRest rest = new QATopicRest();
+        rest.setProjection(projection);
+        rest.setId(modelObject.getSource() + ":" +
+                modelObject.getKey().replace("/", "!") +
+                (modelObject.getFocus() != null ? ":" + modelObject.getFocus().toString() : ""));
+        rest.setName(modelObject.getKey());
+        rest.setLastEvent(modelObject.getLastEvent());
+        rest.setTotalEvents(modelObject.getTotalEvents());
+        return rest;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SubmissionCOARNotifyConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SubmissionCOARNotifyConverter.java
new file mode 100644
index 0000000000..8cfcb6c063
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SubmissionCOARNotifyConverter.java
@@ -0,0 +1,47 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import org.dspace.app.rest.model.SubmissionCOARNotifyRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.coarnotify.NotifySubmissionConfiguration;
+import org.springframework.stereotype.Component;
+
+/**
+ * This converter is responsible for transforming the model representation of an COARNotify to the REST
+ * representation of an COARNotifySubmissionConfiguration and vice versa
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ **/
+@Component
+public class SubmissionCOARNotifyConverter
+    implements DSpaceConverter<NotifySubmissionConfiguration, SubmissionCOARNotifyRest> {
+
+    /**
+     * Convert a COARNotify to its REST representation
+     * @param modelObject   - the COARNotify to convert
+     * @param projection    - the projection
+     * @return the corresponding SubmissionCOARNotifyRest object
+     */
+    @Override
+    public SubmissionCOARNotifyRest convert(final NotifySubmissionConfiguration modelObject,
+                                            final Projection projection) {
+
+        SubmissionCOARNotifyRest submissionCOARNotifyRest = new SubmissionCOARNotifyRest();
+        submissionCOARNotifyRest.setProjection(projection);
+        submissionCOARNotifyRest.setId(modelObject.getId());
+        submissionCOARNotifyRest.setPatterns(modelObject.getPatterns());
+        return submissionCOARNotifyRest;
+    }
+
+    @Override
+    public Class<NotifySubmissionConfiguration> getModelClass() {
+        return NotifySubmissionConfiguration.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SuggestionConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SuggestionConverter.java
new file mode 100644
index 0000000000..8eed5fb78a
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SuggestionConverter.java
@@ -0,0 +1,52 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import org.dspace.app.rest.model.SuggestionRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.app.suggestion.Suggestion;
+import org.dspace.app.suggestion.SuggestionEvidence;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * This class provides the method to convert a Suggestion to its REST representation, the
+ * SuggestionRest
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+@Component
+public class SuggestionConverter
+        implements DSpaceConverter<Suggestion, SuggestionRest> {
+
+    @Autowired
+    private MetadataValueDTOListConverter metadataConverter;
+
+    @Override
+    public SuggestionRest convert(Suggestion target, Projection projection) {
+        SuggestionRest targetRest = new SuggestionRest();
+        targetRest.setProjection(projection);
+        targetRest.setId(target.getID());
+        targetRest.setDisplay(target.getDisplay());
+        targetRest.setExternalSourceUri(target.getExternalSourceUri());
+        targetRest.setSource(target.getSource());
+        targetRest.setScore(String.format("%.2f", target.getScore()));
+        for (SuggestionEvidence se : target.getEvidences()) {
+            targetRest.getEvidences().put(se.getName(),
+                    new SuggestionRest.EvidenceRest(String.format("%.2f", se.getScore()), se.getNotes()));
+        }
+        targetRest.setMetadata(metadataConverter.convert(target.getMetadata()));
+        return targetRest;
+    }
+
+    @Override
+    public Class<Suggestion> getModelClass() {
+        return Suggestion.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SuggestionSourceConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SuggestionSourceConverter.java
new file mode 100644
index 0000000000..3506133b6f
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SuggestionSourceConverter.java
@@ -0,0 +1,39 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import org.dspace.app.rest.model.SuggestionSourceRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.app.suggestion.SuggestionSource;
+import org.springframework.stereotype.Component;
+
+/**
+ * This class provides the method to convert a SuggestionSource to its REST representation, the
+ * SuggestionSourceRest
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+@Component
+public class SuggestionSourceConverter
+        implements DSpaceConverter<SuggestionSource, SuggestionSourceRest> {
+
+    @Override
+    public SuggestionSourceRest convert(SuggestionSource target, Projection projection) {
+        SuggestionSourceRest targetRest = new SuggestionSourceRest();
+        targetRest.setProjection(projection);
+        targetRest.setId(target.getID());
+        targetRest.setTotal(target.getTotal());
+        return targetRest;
+    }
+
+    @Override
+    public Class<SuggestionSource> getModelClass() {
+        return SuggestionSource.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SuggestionTargetConverter.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SuggestionTargetConverter.java
new file mode 100644
index 0000000000..df355dac1f
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/converter/SuggestionTargetConverter.java
@@ -0,0 +1,43 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.converter;
+
+import org.dspace.app.rest.model.SuggestionTargetRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.app.suggestion.SuggestionTarget;
+import org.springframework.stereotype.Component;
+
+/**
+ * This class provides the method to convert a SuggestionTarget to its REST representation, the
+ * SuggestionTargetRest
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+@Component
+public class SuggestionTargetConverter
+        implements DSpaceConverter<SuggestionTarget, SuggestionTargetRest> {
+
+    @Override
+    public SuggestionTargetRest convert(SuggestionTarget target, Projection projection) {
+        SuggestionTargetRest targetRest = new SuggestionTargetRest();
+        targetRest.setProjection(projection);
+        targetRest.setId(target.getID());
+        if (target != null && target.getTarget() != null) {
+            targetRest.setDisplay(target.getTarget().getName());
+        }
+        targetRest.setTotal(target.getTotal());
+        targetRest.setSource(target.getSource());
+        return targetRest;
+    }
+
+    @Override
+    public Class<SuggestionTarget> getModelClass() {
+        return SuggestionTarget.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/exception/InvalidLDNMessageException.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/exception/InvalidLDNMessageException.java
new file mode 100644
index 0000000000..0542ef02cd
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/exception/InvalidLDNMessageException.java
@@ -0,0 +1,26 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.exception;
+
+
+/**
+ * This exception is thrown when the given LDN Message json is invalid
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class InvalidLDNMessageException extends RuntimeException {
+
+    public InvalidLDNMessageException(String message, Throwable cause) {
+        super(message, cause);
+    }
+
+    public InvalidLDNMessageException(String message) {
+        super(message);
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/CorrectionTypeQAEventMessageRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/CorrectionTypeQAEventMessageRest.java
new file mode 100644
index 0000000000..6929f39071
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/CorrectionTypeQAEventMessageRest.java
@@ -0,0 +1,29 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+/**
+ * The CorrectionTypeQAEventMessageRest class implements the QAEventMessageRest
+ * interface and represents a message structure for Quality Assurance (QA)
+ * events related to correction types.
+ *
+ * @author Mykhaylo Boychuk (mykhaylo.boychuk@4science.com)
+ */
+public class CorrectionTypeQAEventMessageRest implements QAEventMessageRest {
+
+    private String reason;
+
+    public String getReason() {
+        return reason;
+    }
+
+    public void setReason(String reason) {
+        this.reason = reason;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/CorrectionTypeRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/CorrectionTypeRest.java
new file mode 100644
index 0000000000..6a26313f92
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/CorrectionTypeRest.java
@@ -0,0 +1,57 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import org.dspace.app.rest.RestResourceController;
+
+/**
+ * The CorrectionType REST Resource
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class CorrectionTypeRest extends BaseObjectRest<String> {
+
+    private static final long serialVersionUID = -8297846719538025938L;
+
+    public static final String NAME = "correctiontype";
+    public static final String PLURAL_NAME = "correctiontypes";
+    public static final String CATEGORY = RestAddressableModel.CONFIGURATION;
+
+    private String topic;
+
+    public String getTopic() {
+        return topic;
+    }
+
+    public void setTopic(String topic) {
+        this.topic = topic;
+    }
+
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
+    public String getType() {
+        return NAME;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+
+    @Override
+    public Class getController() {
+        return RestResourceController.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/DiscoveryResultsRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/DiscoveryResultsRest.java
index bf1d513a81..e63c94edc3 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/DiscoveryResultsRest.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/DiscoveryResultsRest.java
@@ -21,6 +21,7 @@ public abstract class DiscoveryResultsRest extends BaseObjectRest<String> {
 
     @JsonIgnore
     public static final String NAME = "discover";
+    public static final String PLURAL_NAME = NAME;
     public static final String CATEGORY = RestModel.DISCOVER;
     private String scope;
     private String query;
@@ -40,6 +41,14 @@ public abstract class DiscoveryResultsRest extends BaseObjectRest<String> {
         return NAME;
     }
 
+    /**
+     * The plural name is the same as the singular name
+     */
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+
     public Class getController() {
         return DiscoveryRestController.class;
     }
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/ItemFilterRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/ItemFilterRest.java
new file mode 100644
index 0000000000..5d46c62522
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/ItemFilterRest.java
@@ -0,0 +1,42 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import org.dspace.app.rest.RestResourceController;
+
+/**
+ * The ItemFilter REST Resource
+ *
+ * @author mohamed eskander (mohamed.eskander at 4science.com)
+ */
+public class ItemFilterRest extends BaseObjectRest<String> {
+    public static final String NAME = "itemfilter";
+    public static final String PLURAL_NAME = "itemfilters";
+    public static final String CATEGORY = RestAddressableModel.CONFIGURATION;
+
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
+    public String getType() {
+        return NAME;
+    }
+
+    public Class getController() {
+        return RestResourceController.class;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/LDNMessageEntityRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/LDNMessageEntityRest.java
new file mode 100644
index 0000000000..336f2c63c3
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/LDNMessageEntityRest.java
@@ -0,0 +1,200 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import java.util.Date;
+import java.util.UUID;
+
+import org.dspace.app.rest.RestResourceController;
+
+/**
+ * The LDN Message REST resource.
+ * @author Stefano Maffei (stefano.maffei at 4science.com)
+ */
+@SuppressWarnings("serial")
+public class LDNMessageEntityRest extends BaseObjectRest<String> {
+
+    public static final String NAME = "message";
+    public static final String NAME_PLURALS = "messages";
+    public static final String CATEGORY = RestAddressableModel.LDN;
+
+    private String notificationId;
+
+    private Integer queueStatus;
+
+    private String queueStatusLabel;
+
+    private UUID context;
+
+    private UUID object;
+
+    private Integer target;
+
+    private Integer origin;
+
+    private String inReplyTo;
+
+    private String activityStreamType;
+
+    private String coarNotifyType;
+
+    private Integer queueAttempts;
+
+    private Date queueLastStartTime;
+
+    private Date queueTimeout;
+
+    private String notificationType;
+
+    private String message;
+
+    public LDNMessageEntityRest() {
+        super();
+    }
+
+    @Override
+    public String getType() {
+        return NAME;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return NAME_PLURALS;
+    }
+
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    public Class getController() {
+        return RestResourceController.class;
+    }
+
+    public String getNotificationId() {
+        return notificationId;
+    }
+
+    public void setNotificationId(String notificationId) {
+        this.notificationId = notificationId;
+    }
+
+    public Integer getQueueStatus() {
+        return queueStatus;
+    }
+
+    public void setQueueStatus(Integer queueStatus) {
+        this.queueStatus = queueStatus;
+    }
+
+    public String getQueueStatusLabel() {
+        return queueStatusLabel;
+    }
+
+    public void setQueueStatusLabel(String queueStatusLabel) {
+        this.queueStatusLabel = queueStatusLabel;
+    }
+
+    public UUID getContext() {
+        return context;
+    }
+
+    public void setContext(UUID context) {
+        this.context = context;
+    }
+
+    public UUID getObject() {
+        return object;
+    }
+
+    public void setObject(UUID object) {
+        this.object = object;
+    }
+
+    public Integer getTarget() {
+        return target;
+    }
+
+    public void setTarget(Integer target) {
+        this.target = target;
+    }
+
+    public Integer getOrigin() {
+        return origin;
+    }
+
+    public void setOrigin(Integer source) {
+        this.origin = source;
+    }
+
+    public String getActivityStreamType() {
+        return activityStreamType;
+    }
+
+    public void setActivityStreamType(String activityStreamType) {
+        this.activityStreamType = activityStreamType;
+    }
+
+    public String getCoarNotifyType() {
+        return coarNotifyType;
+    }
+
+    public void setCoarNotifyType(String coarNotifyType) {
+        this.coarNotifyType = coarNotifyType;
+    }
+
+    public Integer getQueueAttempts() {
+        return queueAttempts;
+    }
+
+    public void setQueueAttempts(Integer queueAttempts) {
+        this.queueAttempts = queueAttempts;
+    }
+
+    public Date getQueueLastStartTime() {
+        return queueLastStartTime;
+    }
+
+    public void setQueueLastStartTime(Date queueLastStartTime) {
+        this.queueLastStartTime = queueLastStartTime;
+    }
+
+    public Date getQueueTimeout() {
+        return queueTimeout;
+    }
+
+    public void setQueueTimeout(Date queueTimeout) {
+        this.queueTimeout = queueTimeout;
+    }
+
+    public String getNotificationType() {
+        return notificationType;
+    }
+
+    public void setNotificationType(String notificationType) {
+        this.notificationType = notificationType;
+    }
+
+    public String getInReplyTo() {
+        return inReplyTo;
+    }
+
+    public void setInReplyTo(String inReplyTo) {
+        this.inReplyTo = inReplyTo;
+    }
+
+    public String getMessage() {
+        return message;
+    }
+
+    public void setMessage(String message) {
+        this.message = message;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyQAEventMessageRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyQAEventMessageRest.java
new file mode 100644
index 0000000000..e9acb3c775
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyQAEventMessageRest.java
@@ -0,0 +1,58 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+/**
+ * Implementation of {@link QAEventMessageRest} related to COAR NOTIFY events.
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ *
+ */
+public class NotifyQAEventMessageRest implements QAEventMessageRest {
+
+    private String serviceName;
+
+    private String serviceId;
+
+    private String href;
+
+    private String relationship;
+
+    public String getServiceName() {
+        return serviceName;
+    }
+
+    public void setServiceName(String serviceName) {
+        this.serviceName = serviceName;
+    }
+
+    public String getServiceId() {
+        return serviceId;
+    }
+
+    public void setServiceId(String serviceId) {
+        this.serviceId = serviceId;
+    }
+
+    public String getHref() {
+        return href;
+    }
+
+    public void setHref(String href) {
+        this.href = href;
+    }
+
+    public String getRelationship() {
+        return relationship;
+    }
+
+    public void setRelationship(String relationship) {
+        this.relationship = relationship;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyRequestStatusRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyRequestStatusRest.java
new file mode 100644
index 0000000000..c8b5070de3
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyRequestStatusRest.java
@@ -0,0 +1,83 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonPropertyOrder;
+import org.dspace.app.ldn.model.RequestStatus;
+import org.dspace.app.rest.NotifyRequestStatusRestController;
+
+
+/**
+ * Rest entity for LDN requests targeting items
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science dot it)
+ */
+@JsonPropertyOrder(value = {
+    "notifyStatus",
+    "itemuuid"
+})
+public class NotifyRequestStatusRest extends RestAddressableModel {
+
+    private static final long serialVersionUID = 1L;
+    public static final String CATEGORY = RestAddressableModel.LDN;
+    public static final String NAME = "notifyrequests";
+    public static final String PLURAL_NAME = "notifyrequests";
+
+    private List<RequestStatus> notifyStatus;
+    private UUID itemuuid;
+
+    public NotifyRequestStatusRest(NotifyRequestStatusRest instance) {
+        this.notifyStatus = instance.getNotifyStatus();
+    }
+
+    public NotifyRequestStatusRest() {
+        this.notifyStatus = new ArrayList<RequestStatus>();
+    }
+
+    public UUID getItemuuid() {
+        return itemuuid;
+    }
+
+    public void setItemuuid(UUID itemuuid) {
+        this.itemuuid = itemuuid;
+    }
+
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
+    public String getType() {
+        return NAME;
+    }
+
+    public Class getController() {
+        return NotifyRequestStatusRestController.class;
+    }
+
+    public List<RequestStatus> getNotifyStatus() {
+        return notifyStatus;
+    }
+
+    public void setNotifyStatus(List<RequestStatus> notifyStatus) {
+        this.notifyStatus = notifyStatus;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyServiceInboundPatternRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyServiceInboundPatternRest.java
new file mode 100644
index 0000000000..4309083869
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyServiceInboundPatternRest.java
@@ -0,0 +1,57 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+
+/**
+ * representation of the Notify Service Inbound Pattern
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyServiceInboundPatternRest {
+
+    /**
+     * https://notify.coar-repositories.org/patterns/
+     */
+    private String pattern;
+
+    /**
+     * the id of a bean implementing the ItemFilter
+     */
+    private String constraint;
+
+    /**
+     * means that the pattern is triggered automatically
+     * by dspace if the item respect the filter
+     */
+    private boolean automatic;
+
+    public String getPattern() {
+        return pattern;
+    }
+
+    public void setPattern(String pattern) {
+        this.pattern = pattern;
+    }
+
+    public String getConstraint() {
+        return constraint;
+    }
+
+    public void setConstraint(String constraint) {
+        this.constraint = constraint;
+    }
+
+    public boolean isAutomatic() {
+        return automatic;
+    }
+
+    public void setAutomatic(boolean automatic) {
+        this.automatic = automatic;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyServiceRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyServiceRest.java
new file mode 100644
index 0000000000..8a50c913d5
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/NotifyServiceRest.java
@@ -0,0 +1,129 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import java.math.BigDecimal;
+import java.util.List;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import org.dspace.app.rest.RestResourceController;
+
+/**
+ * The NotifyServiceEntity REST Resource
+ *
+ * @author mohamed eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyServiceRest extends BaseObjectRest<Integer> {
+    public static final String NAME = "ldnservice";
+    public static final String PLURAL_NAME = "ldnservices";
+    public static final String CATEGORY = RestAddressableModel.LDN;
+
+    private String name;
+    private String description;
+    private String url;
+    private String ldnUrl;
+    private boolean enabled;
+    private BigDecimal score;
+    private String lowerIp;
+    private String upperIp;
+
+    private List<NotifyServiceInboundPatternRest> notifyServiceInboundPatterns;
+
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
+    public String getType() {
+        return NAME;
+    }
+
+    public Class getController() {
+        return RestResourceController.class;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public String getDescription() {
+        return description;
+    }
+
+    public void setDescription(String description) {
+        this.description = description;
+    }
+
+    public String getUrl() {
+        return url;
+    }
+
+    public void setUrl(String url) {
+        this.url = url;
+    }
+
+    public String getLdnUrl() {
+        return ldnUrl;
+    }
+
+    public void setLdnUrl(String ldnUrl) {
+        this.ldnUrl = ldnUrl;
+    }
+
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    public void setEnabled(boolean enabled) {
+        this.enabled = enabled;
+    }
+    public List<NotifyServiceInboundPatternRest> getNotifyServiceInboundPatterns() {
+        return notifyServiceInboundPatterns;
+    }
+
+    public void setNotifyServiceInboundPatterns(
+        List<NotifyServiceInboundPatternRest> notifyServiceInboundPatterns) {
+        this.notifyServiceInboundPatterns = notifyServiceInboundPatterns;
+    }
+
+    public BigDecimal getScore() {
+        return score;
+    }
+
+    public void setScore(BigDecimal score) {
+        this.score = score;
+    }
+
+    public String getLowerIp() {
+        return lowerIp;
+    }
+
+    public void setLowerIp(String lowerIp) {
+        this.lowerIp = lowerIp;
+    }
+
+    public String getUpperIp() {
+        return upperIp;
+    }
+
+    public void setUpperIp(String upperIp) {
+        this.upperIp = upperIp;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/OpenaireQAEventMessageRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/OpenaireQAEventMessageRest.java
new file mode 100644
index 0000000000..53976b49b6
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/OpenaireQAEventMessageRest.java
@@ -0,0 +1,115 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+
+/**
+ * Implementation of {@link QAEventMessageRest} related to OPENAIRE events.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+public class OpenaireQAEventMessageRest implements QAEventMessageRest {
+
+    // pids
+    private String type;
+
+    private String value;
+
+    private String pidHref;
+
+    // abstract
+    @JsonProperty(value = "abstract")
+    private String abstractValue;
+
+    // project
+    private String openaireId;
+
+    private String acronym;
+
+    private String code;
+
+    private String funder;
+
+    private String fundingProgram;
+
+    private String jurisdiction;
+
+    private String title;
+
+    public String getType() {
+        return type;
+    }
+    public void setType(String type) {
+        this.type = type;
+    }
+    public String getValue() {
+        return value;
+    }
+    public void setValue(String value) {
+        this.value = value;
+    }
+    public String getAbstractValue() {
+        return abstractValue;
+    }
+    public void setAbstractValue(String abstractValue) {
+        this.abstractValue = abstractValue;
+    }
+    public String getOpenaireId() {
+        return openaireId;
+    }
+    public void setOpenaireId(String openaireId) {
+        this.openaireId = openaireId;
+    }
+    public String getAcronym() {
+        return acronym;
+    }
+    public void setAcronym(String acronym) {
+        this.acronym = acronym;
+    }
+    public String getCode() {
+        return code;
+    }
+    public void setCode(String code) {
+        this.code = code;
+    }
+    public String getFunder() {
+        return funder;
+    }
+    public void setFunder(String funder) {
+        this.funder = funder;
+    }
+    public String getFundingProgram() {
+        return fundingProgram;
+    }
+    public void setFundingProgram(String fundingProgram) {
+        this.fundingProgram = fundingProgram;
+    }
+    public String getJurisdiction() {
+        return jurisdiction;
+    }
+    public void setJurisdiction(String jurisdiction) {
+        this.jurisdiction = jurisdiction;
+    }
+    public String getTitle() {
+        return title;
+    }
+    public void setTitle(String title) {
+        this.title = title;
+    }
+
+    public String getPidHref() {
+        return pidHref;
+    }
+
+    public void setPidHref(String pidHref) {
+        this.pidHref = pidHref;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QAEventMessageRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QAEventMessageRest.java
new file mode 100644
index 0000000000..cc460f604c
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QAEventMessageRest.java
@@ -0,0 +1,18 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+/**
+ * Interface for classes that model a message with the details of a QA event.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+public interface QAEventMessageRest {
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QAEventRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QAEventRest.java
new file mode 100644
index 0000000000..5a74d33531
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QAEventRest.java
@@ -0,0 +1,142 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import java.util.Date;
+
+import org.dspace.app.rest.RestResourceController;
+
+/**
+ * QA event Rest object.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@LinksRest(
+        links = {
+            @LinkRest(name = "topic", method = "getTopic"),
+            @LinkRest(name = "target", method = "getTarget"),
+            @LinkRest(name = "related", method = "getRelated")
+        })
+public class QAEventRest extends BaseObjectRest<String> {
+
+    private static final long serialVersionUID = -5001130073350654793L;
+    public static final String NAME = "qualityassuranceevent";
+    public static final String PLURAL_NAME = "qualityassuranceevents";
+    public static final String CATEGORY = RestAddressableModel.INTEGRATION;
+
+    public static final String TOPIC = "topic";
+    public static final String TARGET = "target";
+    public static final String RELATED = "related";
+    private String source;
+    private String originalId;
+    private String title;
+    private String topic;
+    private String trust;
+    private Date eventDate;
+    private QAEventMessageRest message;
+    private String status;
+
+    @Override
+    public String getType() {
+        return NAME;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    public Class getController() {
+        return RestResourceController.class;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    public String getOriginalId() {
+        return originalId;
+    }
+
+    public void setOriginalId(String originalId) {
+        this.originalId = originalId;
+    }
+
+    public String getTitle() {
+        return title;
+    }
+
+    public void setTitle(String title) {
+        this.title = title;
+    }
+
+    public String getTopic() {
+        return topic;
+    }
+
+    public void setTopic(String topic) {
+        this.topic = topic;
+    }
+
+    public String getTrust() {
+        return trust;
+    }
+
+    public void setTrust(String trust) {
+        this.trust = trust;
+    }
+
+    public Date getEventDate() {
+        return eventDate;
+    }
+
+    public void setEventDate(Date eventDate) {
+        this.eventDate = eventDate;
+    }
+
+    public QAEventMessageRest getMessage() {
+        return message;
+    }
+
+    public void setMessage(QAEventMessageRest message) {
+        this.message = message;
+    }
+
+    public String getStatus() {
+        return status;
+    }
+
+    public void setStatus(String status) {
+        this.status = status;
+    }
+
+    /**
+     * @return the source
+     */
+    public String getSource() {
+        return source;
+    }
+
+    /**
+     * @param source the source to set
+     */
+    public void setSource(String source) {
+        this.source = source;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QASourceRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QASourceRest.java
new file mode 100644
index 0000000000..f62bd19f2d
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QASourceRest.java
@@ -0,0 +1,66 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import java.util.Date;
+
+import org.dspace.app.rest.RestResourceController;
+
+/**
+ * REST Representation of a quality assurance broker source
+ * 
+ * @author Luca Giamminonni (luca.giamminonni at 4Science)
+ *
+ */
+public class QASourceRest extends BaseObjectRest<String> {
+
+    private static final long serialVersionUID = -7455358581579629244L;
+
+    public static final String NAME = "qualityassurancesource";
+    public static final String PLURAL_NAME = "qualityassurancesources";
+    public static final String CATEGORY = RestAddressableModel.INTEGRATION;
+
+    private Date lastEvent;
+    private long totalEvents;
+
+    @Override
+    public String getType() {
+        return NAME;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    public Class getController() {
+        return RestResourceController.class;
+    }
+
+    public Date getLastEvent() {
+        return lastEvent;
+    }
+
+    public void setLastEvent(Date lastEvent) {
+        this.lastEvent = lastEvent;
+    }
+
+    public long getTotalEvents() {
+        return totalEvents;
+    }
+
+    public void setTotalEvents(long totalEvents) {
+        this.totalEvents = totalEvents;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QATopicRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QATopicRest.java
new file mode 100644
index 0000000000..54bf3c8141
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/QATopicRest.java
@@ -0,0 +1,84 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import java.util.Date;
+
+import org.dspace.app.rest.RestResourceController;
+
+/**
+ * REST Representation of a quality assurance broker topic
+ * 
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class QATopicRest extends BaseObjectRest<String> {
+
+    private static final long serialVersionUID = -7455358581579629244L;
+
+    public static final String NAME = "qualityassurancetopic";
+    public static final String PLURAL_NAME = "qualityassurancetopics";
+    public static final String CATEGORY = RestAddressableModel.INTEGRATION;
+
+    private String id;
+    private String name;
+    private Date lastEvent;
+    private long totalEvents;
+
+    @Override
+    public String getType() {
+        return NAME;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    public Class getController() {
+        return RestResourceController.class;
+    }
+
+    public String getId() {
+        return id;
+    }
+
+    public void setId(String id) {
+        this.id = id;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+
+    public Date getLastEvent() {
+        return lastEvent;
+    }
+
+    public void setLastEvent(Date lastEvent) {
+        this.lastEvent = lastEvent;
+    }
+
+    public long getTotalEvents() {
+        return totalEvents;
+    }
+
+    public void setTotalEvents(long totalEvents) {
+        this.totalEvents = totalEvents;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/RestModel.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/RestModel.java
index 5bc85a58b2..decc99b2ac 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/RestModel.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/RestModel.java
@@ -34,6 +34,8 @@ public interface RestModel extends Serializable {
     public static final String VERSIONING = "versioning";
     public static final String AUTHENTICATION = "authn";
     public static final String TOOLS = "tools";
+    public static final String LDN = "ldn";
+    public static final String PID = "pid";
 
     public String getType();
 
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SubmissionCOARNotifyRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SubmissionCOARNotifyRest.java
new file mode 100644
index 0000000000..3767186f76
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SubmissionCOARNotifyRest.java
@@ -0,0 +1,70 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import java.util.List;
+
+import com.fasterxml.jackson.annotation.JsonIgnore;
+import com.fasterxml.jackson.annotation.JsonProperty;
+import org.dspace.app.rest.RestResourceController;
+import org.dspace.coarnotify.NotifyPattern;
+import org.dspace.coarnotify.NotifySubmissionConfiguration;
+/**
+ * This class is the REST representation of the COARNotifySubmissionConfiguration model object
+ * and acts as a data object for the SubmissionCOARNotifyResource class.
+ *
+ * Refer to {@link NotifySubmissionConfiguration} for explanation of the properties
+ */
+public class SubmissionCOARNotifyRest extends BaseObjectRest<String> {
+    public static final String NAME = "submissioncoarnotifyconfig";
+    public static final String PLURAL_NAME = "submissioncoarnotifyconfigs";
+    public static final String CATEGORY = RestAddressableModel.CONFIGURATION;
+
+    private String id;
+
+    private List<NotifyPattern> patterns;
+
+    public String getId() {
+        return id;
+    }
+
+    public void setId(final String id) {
+        this.id = id;
+    }
+
+    public List<NotifyPattern> getPatterns() {
+        return patterns;
+    }
+
+    public void setPatterns(final List<NotifyPattern> patterns) {
+        this.patterns = patterns;
+    }
+
+    @JsonIgnore
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    @JsonProperty(access = JsonProperty.Access.READ_ONLY)
+    public String getType() {
+        return NAME;
+    }
+
+    @Override
+    @JsonIgnore
+    public Class getController() {
+        return RestResourceController.class;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SuggestionRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SuggestionRest.java
new file mode 100644
index 0000000000..c7210e8925
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SuggestionRest.java
@@ -0,0 +1,120 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import java.util.HashMap;
+import java.util.Map;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonProperty.Access;
+import org.dspace.app.rest.RestResourceController;
+
+/**
+ * The Suggestion REST Resource. A suggestion is an object, usually a
+ * publication, proposed by a source related to a specific Person (target) to be
+ * imported in the system.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+@LinksRest(links = { @LinkRest(name = SuggestionRest.TARGET, method = "getTarget") })
+public class SuggestionRest extends BaseObjectRest<String> {
+    private static final long serialVersionUID = 1L;
+    public static final String NAME = "suggestion";
+    public static final String PLURAL_NAME = "suggestions";
+    public static final String TARGET = "target";
+    public static final String CATEGORY = RestAddressableModel.INTEGRATION;
+
+    private String display;
+    private String source;
+    private String externalSourceUri;
+    private String score;
+    private Map<String, EvidenceRest> evidences = new HashMap<String, EvidenceRest>();
+    private MetadataRest metadata = new MetadataRest();
+
+    @Override
+    @JsonProperty(access = Access.READ_ONLY)
+    public String getType() {
+        return NAME;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    public Class getController() {
+        return RestResourceController.class;
+    }
+
+    public String getDisplay() {
+        return display;
+    }
+
+    public void setDisplay(String display) {
+        this.display = display;
+    }
+
+    public String getSource() {
+        return source;
+    }
+
+    public void setSource(String source) {
+        this.source = source;
+    }
+
+    public String getExternalSourceUri() {
+        return externalSourceUri;
+    }
+
+    public void setExternalSourceUri(String externalSourceUri) {
+        this.externalSourceUri = externalSourceUri;
+    }
+
+    public void setScore(String score) {
+        this.score = score;
+    }
+
+    public String getScore() {
+        return score;
+    }
+
+    public Map<String, EvidenceRest> getEvidences() {
+        return evidences;
+    }
+
+    public void setEvidences(Map<String, EvidenceRest> evidences) {
+        this.evidences = evidences;
+    }
+
+    public MetadataRest getMetadata() {
+        return metadata;
+    }
+
+    public void setMetadata(MetadataRest metadata) {
+        this.metadata = metadata;
+    }
+
+    /** 
+     * inner class to encapsulate score & notes
+     * and map {@link SuggestionEvidence}
+     * */
+    public static class EvidenceRest {
+        public String score;
+        public String notes;
+        public EvidenceRest(String score, String notes) {
+            this.score = score;
+            this.notes = notes;
+        }
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SuggestionSourceRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SuggestionSourceRest.java
new file mode 100644
index 0000000000..f8cc0e603f
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SuggestionSourceRest.java
@@ -0,0 +1,57 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonProperty.Access;
+import org.dspace.app.rest.RestResourceController;
+
+/**
+ * The Suggestion Source REST Resource. A suggestion source is a connector to an
+ * external system that provides suggestion for a target object of related
+ * objects to be imported in the system.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+public class SuggestionSourceRest extends BaseObjectRest<String> {
+    private static final long serialVersionUID = 1L;
+    public static final String CATEGORY = RestAddressableModel.INTEGRATION;
+    public static final String NAME = "suggestionsource";
+    public static final String PLURAL_NAME = "suggestionsources";
+
+    private int total;
+
+    @Override
+    @JsonProperty(access = Access.READ_ONLY)
+    public String getType() {
+        return NAME;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    public Class getController() {
+        return RestResourceController.class;
+    }
+
+    public int getTotal() {
+        return total;
+    }
+
+    public void setTotal(int total) {
+        this.total = total;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SuggestionTargetRest.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SuggestionTargetRest.java
new file mode 100644
index 0000000000..65764507e2
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/SuggestionTargetRest.java
@@ -0,0 +1,79 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model;
+
+import com.fasterxml.jackson.annotation.JsonProperty;
+import com.fasterxml.jackson.annotation.JsonProperty.Access;
+import org.dspace.app.rest.RestResourceController;
+
+/**
+ * The Suggestion Target REST Resource. A suggestion target is a Person to whom
+ * one or more suggester sources have found related objects to be importe in the
+ * system.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+@LinksRest(links = {
+        @LinkRest(name = SuggestionTargetRest.TARGET, method = "getTarget")
+})
+public class SuggestionTargetRest extends BaseObjectRest<String> {
+    private static final long serialVersionUID = 1L;
+    public static final String NAME = "suggestiontarget";
+    public static final String PLURAL_NAME = "suggestiontargets";
+    public static final String TARGET = "target";
+    public static final String CATEGORY = RestAddressableModel.INTEGRATION;
+
+    private String display;
+    private String source;
+    private int total;
+
+    @Override
+    @JsonProperty(access = Access.READ_ONLY)
+    public String getType() {
+        return NAME;
+    }
+
+    @Override
+    public String getTypePlural() {
+        return PLURAL_NAME;
+    }
+
+    @Override
+    public String getCategory() {
+        return CATEGORY;
+    }
+
+    @Override
+    public Class getController() {
+        return RestResourceController.class;
+    }
+
+    public String getDisplay() {
+        return display;
+    }
+
+    public void setDisplay(String display) {
+        this.display = display;
+    }
+
+    public String getSource() {
+        return source;
+    }
+
+    public void setSource(String source) {
+        this.source = source;
+    }
+
+    public int getTotal() {
+        return total;
+    }
+
+    public void setTotal(int total) {
+        this.total = total;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/CorrectionTypeResource.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/CorrectionTypeResource.java
new file mode 100644
index 0000000000..cb1ba5552f
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/CorrectionTypeResource.java
@@ -0,0 +1,27 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.hateoas;
+
+import org.dspace.app.rest.model.CorrectionTypeRest;
+import org.dspace.app.rest.model.hateoas.annotations.RelNameDSpaceResource;
+import org.dspace.app.rest.utils.Utils;
+
+/**
+ * CorrectionType Rest HAL Resource. The HAL Resource wraps the REST Resource
+ * adding support for the links and embedded resources
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@RelNameDSpaceResource(CorrectionTypeRest.NAME)
+public class CorrectionTypeResource extends DSpaceResource<CorrectionTypeRest> {
+
+    public CorrectionTypeResource(CorrectionTypeRest target, Utils utils) {
+        super(target, utils);
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/ItemFilterResource.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/ItemFilterResource.java
new file mode 100644
index 0000000000..666531e816
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/ItemFilterResource.java
@@ -0,0 +1,25 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.hateoas;
+
+import org.dspace.app.rest.model.ItemFilterRest;
+import org.dspace.app.rest.model.hateoas.annotations.RelNameDSpaceResource;
+import org.dspace.app.rest.utils.Utils;
+
+/**
+ * ItemFilter Rest HAL Resource. The HAL Resource wraps the REST Resource adding
+ * support for the links and embedded resources
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@RelNameDSpaceResource(ItemFilterRest.NAME)
+public class ItemFilterResource extends DSpaceResource<ItemFilterRest> {
+    public ItemFilterResource(ItemFilterRest data, Utils utils) {
+        super(data, utils);
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/LDNMessageEntityResource.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/LDNMessageEntityResource.java
new file mode 100644
index 0000000000..2ac899fa4b
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/LDNMessageEntityResource.java
@@ -0,0 +1,27 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.hateoas;
+
+import org.dspace.app.rest.model.LDNMessageEntityRest;
+import org.dspace.app.rest.model.hateoas.annotations.RelNameDSpaceResource;
+import org.dspace.app.rest.utils.Utils;
+
+/**
+ * Browse Entry Rest HAL Resource. The HAL Resource wraps the REST Resource
+ * adding support for the links and embedded resources
+ *
+ * @author Stefano Maffei (stefano.maffei at 4science.com)
+ */
+@RelNameDSpaceResource(LDNMessageEntityRest.NAME)
+public class LDNMessageEntityResource extends DSpaceResource<LDNMessageEntityRest> {
+
+    public LDNMessageEntityResource(LDNMessageEntityRest data, Utils utils) {
+        super(data, utils);
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/NotifyServiceResource.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/NotifyServiceResource.java
new file mode 100644
index 0000000000..8b2cf509d7
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/NotifyServiceResource.java
@@ -0,0 +1,25 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.hateoas;
+
+import org.dspace.app.rest.model.NotifyServiceRest;
+import org.dspace.app.rest.model.hateoas.annotations.RelNameDSpaceResource;
+import org.dspace.app.rest.utils.Utils;
+
+/**
+ * NotifyService Rest HAL Resource. The HAL Resource wraps the REST Resource adding
+ * support for the links and embedded resources
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@RelNameDSpaceResource(NotifyServiceRest.NAME)
+public class NotifyServiceResource extends DSpaceResource<NotifyServiceRest> {
+    public NotifyServiceResource(NotifyServiceRest data, Utils utils) {
+        super(data, utils);
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/QAEventResource.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/QAEventResource.java
new file mode 100644
index 0000000000..43e1584a25
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/QAEventResource.java
@@ -0,0 +1,27 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.hateoas;
+
+import org.dspace.app.rest.model.QAEventRest;
+import org.dspace.app.rest.model.hateoas.annotations.RelNameDSpaceResource;
+import org.dspace.app.rest.utils.Utils;
+
+/**
+ * QA event Rest resource.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@RelNameDSpaceResource(QAEventRest.NAME)
+public class QAEventResource extends DSpaceResource<QAEventRest> {
+
+    public QAEventResource(QAEventRest data, Utils utils) {
+        super(data, utils);
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/QASourceResource.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/QASourceResource.java
new file mode 100644
index 0000000000..860e16cee3
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/QASourceResource.java
@@ -0,0 +1,27 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.hateoas;
+
+import org.dspace.app.rest.model.QASourceRest;
+import org.dspace.app.rest.model.hateoas.annotations.RelNameDSpaceResource;
+import org.dspace.app.rest.utils.Utils;
+
+/**
+ * QA source Rest resource.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4Science)
+ *
+ */
+@RelNameDSpaceResource(QASourceRest.NAME)
+public class QASourceResource extends DSpaceResource<QASourceRest> {
+
+    public QASourceResource(QASourceRest data, Utils utils) {
+        super(data, utils);
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/QATopicResource.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/QATopicResource.java
new file mode 100644
index 0000000000..139d1e59eb
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/QATopicResource.java
@@ -0,0 +1,27 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.hateoas;
+
+import org.dspace.app.rest.model.QATopicRest;
+import org.dspace.app.rest.model.hateoas.annotations.RelNameDSpaceResource;
+import org.dspace.app.rest.utils.Utils;
+
+/**
+ * QA topic Rest resource.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@RelNameDSpaceResource(QATopicRest.NAME)
+public class QATopicResource extends DSpaceResource<QATopicRest> {
+
+    public QATopicResource(QATopicRest data, Utils utils) {
+        super(data, utils);
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SubmissionCOARNotifyResource.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SubmissionCOARNotifyResource.java
new file mode 100644
index 0000000000..b49451f8e8
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SubmissionCOARNotifyResource.java
@@ -0,0 +1,25 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.hateoas;
+
+import org.dspace.app.rest.model.SubmissionCOARNotifyRest;
+import org.dspace.app.rest.model.hateoas.annotations.RelNameDSpaceResource;
+import org.dspace.app.rest.utils.Utils;
+
+/**
+ * COARNotify HAL Resource. This resource adds the data from the REST object together with embedded objects
+ * and a set of links if applicable
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@RelNameDSpaceResource(SubmissionCOARNotifyRest.NAME)
+public class SubmissionCOARNotifyResource extends DSpaceResource<SubmissionCOARNotifyRest> {
+    public SubmissionCOARNotifyResource(SubmissionCOARNotifyRest submissionCOARNotifyRest, Utils utils) {
+        super(submissionCOARNotifyRest, utils);
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SuggestionResource.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SuggestionResource.java
new file mode 100644
index 0000000000..66165f8698
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SuggestionResource.java
@@ -0,0 +1,25 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.hateoas;
+
+import org.dspace.app.rest.model.SuggestionRest;
+import org.dspace.app.rest.model.hateoas.annotations.RelNameDSpaceResource;
+import org.dspace.app.rest.utils.Utils;
+
+/**
+ * Suggestion Rest HAL Resource. The HAL Resource wraps the REST Resource
+ * adding support for the links and embedded resources
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+@RelNameDSpaceResource(SuggestionRest.NAME)
+public class SuggestionResource extends DSpaceResource<SuggestionRest> {
+    public SuggestionResource(SuggestionRest target, Utils utils) {
+        super(target, utils);
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SuggestionSourceResource.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SuggestionSourceResource.java
new file mode 100644
index 0000000000..1f01f27d86
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SuggestionSourceResource.java
@@ -0,0 +1,25 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.hateoas;
+
+import org.dspace.app.rest.model.SuggestionSourceRest;
+import org.dspace.app.rest.model.hateoas.annotations.RelNameDSpaceResource;
+import org.dspace.app.rest.utils.Utils;
+
+/**
+ * Suggestion Source Rest HAL Resource. The HAL Resource wraps the REST Resource
+ * adding support for the links and embedded resources
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+@RelNameDSpaceResource(SuggestionSourceRest.NAME)
+public class SuggestionSourceResource extends DSpaceResource<SuggestionSourceRest> {
+    public SuggestionSourceResource(SuggestionSourceRest target, Utils utils) {
+        super(target, utils);
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SuggestionTargetResource.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SuggestionTargetResource.java
new file mode 100644
index 0000000000..26cd7c3c34
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/hateoas/SuggestionTargetResource.java
@@ -0,0 +1,25 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.hateoas;
+
+import org.dspace.app.rest.model.SuggestionTargetRest;
+import org.dspace.app.rest.model.hateoas.annotations.RelNameDSpaceResource;
+import org.dspace.app.rest.utils.Utils;
+
+/**
+ * Suggestion Target Rest HAL Resource. The HAL Resource wraps the REST Resource
+ * adding support for the links and embedded resources
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+@RelNameDSpaceResource(SuggestionTargetRest.NAME)
+public class SuggestionTargetResource extends DSpaceResource<SuggestionTargetRest> {
+    public SuggestionTargetResource(SuggestionTargetRest target, Utils utils) {
+        super(target, utils);
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/step/DataNotify.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/step/DataNotify.java
new file mode 100644
index 0000000000..0ae1fa5717
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/model/step/DataNotify.java
@@ -0,0 +1,49 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.model.step;
+
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+
+import com.fasterxml.jackson.annotation.JsonAnyGetter;
+import com.fasterxml.jackson.annotation.JsonAnySetter;
+import com.fasterxml.jackson.annotation.JsonIgnore;
+
+/**
+ * Java Bean to expose the COAR Notify Section during in progress submission.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class DataNotify implements SectionData {
+
+    private Map<String, List<Integer>> patterns = new HashMap<>();
+
+    public DataNotify() {
+
+    }
+
+    @JsonAnySetter
+    public void add(String key, List<Integer> values) {
+        patterns.put(key, values);
+    }
+
+    public DataNotify(Map<String, List<Integer>> patterns) {
+        this.patterns = patterns;
+    }
+
+    @JsonIgnore
+    public void setPatterns(Map<String, List<Integer>> patterns) {
+        this.patterns = patterns;
+    }
+
+    @JsonAnyGetter
+    public Map<String, List<Integer>> getPatterns() {
+        return patterns;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/CorrectionTypeRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/CorrectionTypeRestRepository.java
new file mode 100644
index 0000000000..6e60f3037d
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/CorrectionTypeRestRepository.java
@@ -0,0 +1,93 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import java.sql.SQLException;
+import java.util.List;
+import java.util.Objects;
+import java.util.UUID;
+
+import org.dspace.app.rest.Parameter;
+import org.dspace.app.rest.SearchRestMethod;
+import org.dspace.app.rest.exception.RESTAuthorizationException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.CorrectionTypeRest;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.content.Item;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.correctiontype.CorrectionType;
+import org.dspace.correctiontype.service.CorrectionTypeService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * The CorrectionType REST Repository
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@Component(CorrectionTypeRest.CATEGORY + "." + CorrectionTypeRest.NAME)
+public class CorrectionTypeRestRepository extends DSpaceRestRepository<CorrectionTypeRest, String> {
+
+    @Autowired
+    private ItemService itemService;
+    @Autowired
+    private CorrectionTypeService correctionTypeService;
+
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    @Override
+    public CorrectionTypeRest findOne(Context context, String id) {
+        CorrectionType correctionType = correctionTypeService.findOne(id);
+        return Objects.nonNull(correctionType) ? converter.toRest(correctionType, utils.obtainProjection()) : null;
+    }
+
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    @Override
+    public Page<CorrectionTypeRest> findAll(Context context, Pageable pageable) {
+        return converter.toRestPage(correctionTypeService.findAll(), pageable, utils.obtainProjection());
+    }
+
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    @SearchRestMethod(name = "findByItem")
+    public Page<CorrectionTypeRest> findByItem(@Parameter(value = "uuid",required = true) UUID uuid,Pageable pageable) {
+        Context context = obtainContext();
+        try {
+            Item item = itemService.find(context, uuid);
+            if (Objects.isNull(item)) {
+                throw new UnprocessableEntityException("Item with uuid:" + uuid + " not found");
+            }
+
+            List<CorrectionType> correctionTypes;
+            try {
+                correctionTypes = correctionTypeService.findByItem(context, item);
+            } catch (AuthorizeException e) {
+                throw new RESTAuthorizationException(e);
+            }
+
+            return converter.toRestPage(correctionTypes, pageable, utils.obtainProjection());
+        } catch (SQLException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+    }
+
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    @SearchRestMethod(name = "findByTopic")
+    public CorrectionTypeRest findByTopic(@Parameter(value = "topic", required = true) String topic) {
+        CorrectionType correctionType = correctionTypeService.findByTopic(topic);
+        return Objects.nonNull(correctionType) ? converter.toRest(correctionType, utils.obtainProjection()) : null;
+    }
+
+    @Override
+    public Class<CorrectionTypeRest> getDomainClass() {
+        return CorrectionTypeRest.class;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ItemFilterRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ItemFilterRestRepository.java
new file mode 100644
index 0000000000..54a18d0ba6
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ItemFilterRestRepository.java
@@ -0,0 +1,58 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import org.dspace.app.ldn.ItemFilter;
+import org.dspace.app.rest.model.ItemFilterRest;
+import org.dspace.content.ItemFilterService;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.data.rest.webmvc.ResourceNotFoundException;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * This is the repository responsible to manage ItemFilter Rest object
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+
+@Component(ItemFilterRest.CATEGORY + "." + ItemFilterRest.NAME)
+public class ItemFilterRestRepository extends DSpaceRestRepository<ItemFilterRest, String> {
+
+    @Autowired
+    private ItemFilterService itemFilterService;
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    public ItemFilterRest findOne(Context context, String id) {
+        ItemFilter itemFilter = itemFilterService.findOne(id);
+
+        if (itemFilter == null) {
+            throw new ResourceNotFoundException(
+                "No such logical item filter: " + id);
+        }
+
+        return converter.toRest(itemFilter, utils.obtainProjection());
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    public Page<ItemFilterRest> findAll(Context context, Pageable pageable) {
+        return converter.toRestPage(itemFilterService.findAll(),
+            pageable, utils.obtainProjection());
+    }
+
+    @Override
+    public Class<ItemFilterRest> getDomainClass() {
+        return ItemFilterRest.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/LDNMessageRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/LDNMessageRestRepository.java
new file mode 100644
index 0000000000..d8c8cfaf15
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/LDNMessageRestRepository.java
@@ -0,0 +1,87 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import java.sql.SQLException;
+import javax.servlet.http.HttpServletRequest;
+
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.rest.exception.MethodNotAllowedException;
+import org.dspace.app.rest.model.LDNMessageEntityRest;
+import org.dspace.app.rest.model.patch.Patch;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.data.rest.webmvc.ResourceNotFoundException;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * This is the repository responsible to manage LDNMessageEntry Rest object
+ *
+ * @author Stefano Maffei(stefano.maffei at 4science.com)
+ */
+
+@Component(LDNMessageEntityRest.CATEGORY + "." + LDNMessageEntityRest.NAME)
+public class LDNMessageRestRepository extends DSpaceRestRepository<LDNMessageEntityRest, String> {
+
+    @Autowired
+    private LDNMessageService ldnMessageService;
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    public LDNMessageEntityRest findOne(Context context, String id) {
+        try {
+            LDNMessageEntity ldnMessageEntity = ldnMessageService.find(context, id);
+            if (ldnMessageEntity == null) {
+                throw new ResourceNotFoundException("The LDNMessageEntity for ID: " + id + " could not be found");
+            }
+            return converter.toRest(ldnMessageEntity, utils.obtainProjection());
+        } catch (SQLException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    public Page<LDNMessageEntityRest> findAll(Context context, Pageable pageable) {
+        try {
+            return converter.toRestPage(ldnMessageService.findAll(context), pageable, utils.obtainProjection());
+        } catch (SQLException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    protected LDNMessageEntityRest createAndReturn(Context context) throws AuthorizeException, SQLException {
+        throw new MethodNotAllowedException("Creation of LDN Message is not supported via Endpoint");
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, String id,
+        Patch patch) throws AuthorizeException, SQLException {
+        throw new MethodNotAllowedException("Patch of LDN Message is not supported via Endpoint");
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    protected void delete(Context context, String id) throws AuthorizeException {
+        throw new MethodNotAllowedException("Deletion of LDN Message is not supported via Endpoint");
+    }
+
+    @Override
+    public Class<LDNMessageEntityRest> getDomainClass() {
+        return LDNMessageEntityRest.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/NotifyServiceRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/NotifyServiceRestRepository.java
new file mode 100644
index 0000000000..972f0944f3
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/NotifyServiceRestRepository.java
@@ -0,0 +1,212 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import static java.lang.String.format;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+import javax.servlet.ServletInputStream;
+import javax.servlet.http.HttpServletRequest;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.Parameter;
+import org.dspace.app.rest.SearchRestMethod;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.NotifyServiceInboundPatternRest;
+import org.dspace.app.rest.model.NotifyServiceRest;
+import org.dspace.app.rest.model.patch.Patch;
+import org.dspace.app.rest.repository.patch.ResourcePatch;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.data.rest.webmvc.ResourceNotFoundException;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+
+/**
+ * This is the repository responsible to manage NotifyService Rest object
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+
+@Component(NotifyServiceRest.CATEGORY + "." + NotifyServiceRest.NAME)
+public class NotifyServiceRestRepository extends DSpaceRestRepository<NotifyServiceRest, Integer> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    ResourcePatch<NotifyServiceEntity> resourcePatch;
+
+    @Override
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    public NotifyServiceRest findOne(Context context, Integer id) {
+        try {
+            NotifyServiceEntity notifyServiceEntity = notifyService.find(context, id);
+            if (notifyServiceEntity == null) {
+                throw new ResourceNotFoundException("The notifyService for ID: " + id + " could not be found");
+            }
+            return converter.toRest(notifyServiceEntity, utils.obtainProjection());
+        } catch (SQLException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    public Page<NotifyServiceRest> findAll(Context context, Pageable pageable) {
+        try {
+            return converter.toRestPage(notifyService.findAll(context), pageable, utils.obtainProjection());
+        } catch (SQLException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    protected NotifyServiceRest createAndReturn(Context context) throws AuthorizeException, SQLException {
+        HttpServletRequest req = getRequestService().getCurrentRequest().getHttpServletRequest();
+        ObjectMapper mapper = new ObjectMapper();
+        NotifyServiceRest notifyServiceRest;
+        try {
+            ServletInputStream input = req.getInputStream();
+            notifyServiceRest = mapper.readValue(input, NotifyServiceRest.class);
+        } catch (IOException e1) {
+            throw new UnprocessableEntityException("Error parsing request body", e1);
+        }
+
+        if (notifyServiceRest.getScore() != null) {
+            if (notifyServiceRest.getScore().compareTo(java.math.BigDecimal.ZERO) == -1 ||
+                notifyServiceRest.getScore().compareTo(java.math.BigDecimal.ONE) == 1) {
+                throw new UnprocessableEntityException(format("Score out of range [0, 1] %s",
+                    notifyServiceRest.getScore().setScale(4).toPlainString()));
+            }
+        }
+
+        if (notifyService.findByLdnUrl(context,notifyServiceRest.getLdnUrl()) != null) {
+            throw new UnprocessableEntityException(format("LDN url already in use %s",
+                notifyServiceRest.getLdnUrl()));
+        }
+
+        NotifyServiceEntity notifyServiceEntity = notifyService.create(context);
+        notifyServiceEntity.setName(notifyServiceRest.getName());
+        notifyServiceEntity.setDescription(notifyServiceRest.getDescription());
+        notifyServiceEntity.setUrl(notifyServiceRest.getUrl());
+        notifyServiceEntity.setLdnUrl(notifyServiceRest.getLdnUrl());
+        notifyServiceEntity.setEnabled(notifyServiceRest.isEnabled());
+        notifyServiceEntity.setLowerIp(notifyServiceRest.getLowerIp());
+        notifyServiceEntity.setUpperIp(notifyServiceRest.getUpperIp());
+
+        if (notifyServiceRest.getNotifyServiceInboundPatterns() != null) {
+            appendNotifyServiceInboundPatterns(context, notifyServiceEntity,
+                notifyServiceRest.getNotifyServiceInboundPatterns());
+        }
+
+        notifyServiceEntity.setScore(notifyServiceRest.getScore());
+
+        notifyService.update(context, notifyServiceEntity);
+
+        return converter.toRest(notifyServiceEntity, utils.obtainProjection());
+    }
+
+    private void appendNotifyServiceInboundPatterns(Context context, NotifyServiceEntity notifyServiceEntity,
+        List<NotifyServiceInboundPatternRest> inboundPatternRests) throws SQLException {
+
+        List<NotifyServiceInboundPattern> inboundPatterns = new ArrayList<>();
+
+        for (NotifyServiceInboundPatternRest inboundPatternRest : inboundPatternRests) {
+            NotifyServiceInboundPattern inboundPattern = inboundPatternService.create(context, notifyServiceEntity);
+            inboundPattern.setPattern(inboundPatternRest.getPattern());
+            inboundPattern.setConstraint(inboundPatternRest.getConstraint());
+            inboundPattern.setAutomatic(inboundPatternRest.isAutomatic());
+
+            inboundPatterns.add(inboundPattern);
+        }
+
+        notifyServiceEntity.setInboundPatterns(inboundPatterns);
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    protected void patch(Context context, HttpServletRequest request, String apiCategory, String model, Integer id,
+                         Patch patch) throws AuthorizeException, SQLException {
+        NotifyServiceEntity notifyServiceEntity = notifyService.find(context, id);
+        if (notifyServiceEntity == null) {
+            throw new ResourceNotFoundException(
+                NotifyServiceRest.CATEGORY + "." + NotifyServiceRest.NAME + " with id: " + id + " not found");
+        }
+        resourcePatch.patch(context, notifyServiceEntity, patch.getOperations());
+        notifyService.update(context, notifyServiceEntity);
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    protected void delete(Context context, Integer id) throws AuthorizeException {
+        try {
+            NotifyServiceEntity notifyServiceEntity = notifyService.find(context, id);
+            if (notifyServiceEntity == null) {
+                throw new ResourceNotFoundException(NotifyServiceRest.CATEGORY + "." +
+                    NotifyServiceRest.NAME + " with id: " + id + " not found");
+            }
+            notifyService.delete(context, notifyServiceEntity);
+        } catch (SQLException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+    }
+
+    @SearchRestMethod(name = "byLdnUrl")
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    public NotifyServiceRest findByLdnUrl(@Parameter(value = "ldnUrl", required = true) String ldnUrl) {
+        try {
+            NotifyServiceEntity notifyServiceEntity = notifyService.findByLdnUrl(obtainContext(), ldnUrl);
+            if (notifyServiceEntity == null) {
+                return null;
+            }
+            return converter.toRest(notifyServiceEntity, utils.obtainProjection());
+        } catch (SQLException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+    }
+
+    @SearchRestMethod(name = "byInboundPattern")
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    public Page<NotifyServiceRest> findManualServicesByInboundPattern(
+        @Parameter(value = "pattern", required = true) String pattern,
+        Pageable pageable) {
+        try {
+            List<NotifyServiceEntity> notifyServiceEntities =
+                notifyService.findManualServicesByInboundPattern(obtainContext(), pattern)
+                .stream()
+                .filter(NotifyServiceEntity::isEnabled)
+                .collect(Collectors.toList());
+
+            return converter.toRestPage(notifyServiceEntities, pageable, utils.obtainProjection());
+        } catch (SQLException e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+    }
+
+    @Override
+    public Class<NotifyServiceRest> getDomainClass() {
+        return NotifyServiceRest.class;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ProcessOutputLinkRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ProcessOutputLinkRepository.java
index f5b3edced2..893754525d 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ProcessOutputLinkRepository.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/ProcessOutputLinkRepository.java
@@ -68,4 +68,4 @@ public class ProcessOutputLinkRepository extends AbstractDSpaceRestRepository im
         }
         return converter.toRest(bitstream, projection);
     }
-}
\ No newline at end of file
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventRelatedLinkRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventRelatedLinkRepository.java
new file mode 100644
index 0000000000..a6caa62191
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventRelatedLinkRepository.java
@@ -0,0 +1,77 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import java.sql.SQLException;
+import java.util.UUID;
+import javax.annotation.Nullable;
+import javax.servlet.http.HttpServletRequest;
+
+import org.dspace.app.rest.model.ItemRest;
+import org.dspace.app.rest.model.QAEventRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.qaevent.service.QAEventService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Pageable;
+import org.springframework.data.rest.webmvc.ResourceNotFoundException;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * Link repository for "related" subresource of a qa event.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@Component(QAEventRest.CATEGORY + "." + QAEventRest.NAME + "." + QAEventRest.RELATED)
+public class QAEventRelatedLinkRepository extends AbstractDSpaceRestRepository implements LinkRestRepository {
+
+    @Autowired
+    private QAEventService qaEventService;
+
+    @Autowired
+    private ItemService itemService;
+
+    /**
+     * Returns the item related to the qa event with the given id. This is another
+     * item that should be linked to the target item as part of the correction
+     *
+     * @param request    the http servlet request
+     * @param id         the qa event id
+     * @param pageable   the optional pageable
+     * @param projection the projection object
+     * @return the item rest representation of the secondary item related to qa event
+     */
+    @PreAuthorize("hasPermission(#id, 'QUALITYASSURANCEEVENT', 'READ')")
+    public ItemRest getRelated(@Nullable HttpServletRequest request, String id, @Nullable Pageable pageable,
+            Projection projection) {
+        Context context = obtainContext();
+        QAEvent qaEvent = qaEventService.findEventByEventId(id);
+        if (qaEvent == null) {
+            throw new ResourceNotFoundException("No qa event with ID: " + id);
+        }
+        if (qaEvent.getRelated() == null) {
+            return null;
+        }
+        UUID itemUuid = UUID.fromString(qaEvent.getRelated());
+        Item item;
+        try {
+            item = itemService.find(context, itemUuid);
+            if (item == null) {
+                throw new ResourceNotFoundException("No related item found with id : " + id);
+            }
+            return converter.toRest(item, projection);
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventRestRepository.java
new file mode 100644
index 0000000000..b2309df1ec
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventRestRepository.java
@@ -0,0 +1,206 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.List;
+import java.util.Objects;
+import java.util.UUID;
+import javax.servlet.ServletRequest;
+import javax.servlet.http.HttpServletRequest;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.commons.lang.StringUtils;
+import org.dspace.app.rest.Parameter;
+import org.dspace.app.rest.SearchRestMethod;
+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.QAEventRest;
+import org.dspace.app.rest.model.patch.Patch;
+import org.dspace.app.rest.repository.patch.ResourcePatch;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.correctiontype.CorrectionType;
+import org.dspace.correctiontype.service.CorrectionTypeService;
+import org.dspace.eperson.EPerson;
+import org.dspace.qaevent.dao.QAEventsDAO;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.qaevent.service.dto.CorrectionTypeMessageDTO;
+import org.dspace.util.UUIDUtils;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * Rest repository that handle QA events.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@Component(QAEventRest.CATEGORY + "." + QAEventRest.NAME)
+public class QAEventRestRepository extends DSpaceRestRepository<QAEventRest, String> {
+
+    final static String ORDER_FIELD = "trust";
+
+    @Autowired
+    private QAEventService qaEventService;
+
+    @Autowired
+    private QAEventsDAO qaEventDao;
+
+    @Autowired
+    private ItemService itemService;
+
+    @Autowired
+    private ResourcePatch<QAEvent> resourcePatch;
+
+    @Autowired
+    private CorrectionTypeService correctionTypeService;
+
+    @Override
+    public Page<QAEventRest> findAll(Context context, Pageable pageable) {
+        throw new RepositoryMethodNotImplementedException(QAEventRest.NAME, "findAll");
+    }
+
+    @Override
+    @PreAuthorize("hasPermission(#id, 'QUALITYASSURANCEEVENT', 'READ')")
+    public QAEventRest findOne(Context context, String id) {
+        QAEvent qaEvent = qaEventService.findEventByEventId(id);
+        if (qaEvent == null) {
+            // check if this request is part of a patch flow
+            qaEvent = (QAEvent) requestService.getCurrentRequest().getAttribute("patchedNotificationEvent");
+            if (qaEvent != null && qaEvent.getEventId().contentEquals(id)) {
+                return converter.toRest(qaEvent, utils.obtainProjection());
+            } else {
+                return null;
+            }
+        }
+        return converter.toRest(qaEvent, utils.obtainProjection());
+    }
+
+    @SearchRestMethod(name = "findByTopic")
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    public Page<QAEventRest> findByTopic(@Parameter(value = "topic", required = true) String topic,
+        Pageable pageable) {
+        Context context = obtainContext();
+        String[] topicIdSplitted = topic.split(":", 3);
+        if (topicIdSplitted.length < 2) {
+            return null;
+        }
+        String sourceName = topicIdSplitted[0];
+        String topicName = topicIdSplitted[1].replaceAll("!", "/");
+        UUID target = topicIdSplitted.length == 3 ? UUID.fromString(topicIdSplitted[2]) : null;
+        List<QAEvent> qaEvents = qaEventService.findEventsByTopicAndTarget(context, sourceName, topicName, target,
+            pageable.getOffset(), pageable.getPageSize());
+        long count = qaEventService.countEventsByTopicAndTarget(context, sourceName, topicName, target);
+        if (qaEvents == null) {
+            return null;
+        }
+        return converter.toRestPage(qaEvents, pageable, count, utils.obtainProjection());
+    }
+
+    @Override
+    @PreAuthorize("hasPermission(#id, 'QUALITYASSURANCEEVENT', 'DELETE')")
+    protected void delete(Context context, String id) throws AuthorizeException {
+        Item item = findTargetItem(context, id);
+        EPerson eperson = context.getCurrentUser();
+        qaEventService.deleteEventByEventId(id);
+        qaEventDao.storeEvent(context, id, eperson, item);
+    }
+
+    @Override
+    @PreAuthorize("hasPermission(#id, 'QUALITYASSURANCEEVENT', 'WRITE')")
+    protected void patch(Context context, HttpServletRequest request, String apiCategory, String model,
+        String id, Patch patch) throws SQLException, AuthorizeException {
+        QAEvent qaEvent = qaEventService.findEventByEventId(id);
+        resourcePatch.patch(context, qaEvent, patch.getOperations());
+    }
+
+    private Item findTargetItem(Context context, String eventId) {
+        QAEvent qaEvent = qaEventService.findEventByEventId(eventId);
+        if (qaEvent == null) {
+            return null;
+        }
+
+        try {
+            return itemService.find(context, UUIDUtils.fromString(qaEvent.getTarget()));
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    protected QAEventRest createAndReturn(Context context) throws SQLException, AuthorizeException {
+        ServletRequest request = getRequestService().getCurrentRequest().getServletRequest();
+
+        String itemUUID = request.getParameter("target");
+        String relatedItemUUID = request.getParameter("related");
+        String correctionTypeStr = request.getParameter("correctionType");
+
+
+        if (StringUtils.isBlank(correctionTypeStr) || StringUtils.isBlank(itemUUID)) {
+            throw new UnprocessableEntityException("The target item and correctionType must be provided!");
+        }
+
+        Item targetItem = null;
+        Item relatedItem = null;
+        try {
+            targetItem = itemService.find(context, UUID.fromString(itemUUID));
+            relatedItem =  StringUtils.isNotBlank(relatedItemUUID) ?
+                                       itemService.find(context, UUID.fromString(relatedItemUUID)) : null;
+        } catch (Exception e) {
+            throw new UnprocessableEntityException(e.getMessage(), e);
+        }
+
+        if (Objects.isNull(targetItem)) {
+            throw new UnprocessableEntityException("The target item UUID is not valid!");
+        }
+
+        CorrectionType correctionType = correctionTypeService.findOne(correctionTypeStr);
+        if (Objects.isNull(correctionType)) {
+            throw new UnprocessableEntityException("The given correction type in the request is not valid!");
+        }
+
+        if (correctionType.isRequiredRelatedItem() && Objects.isNull(relatedItem)) {
+            throw new UnprocessableEntityException("The given correction type in the request is not valid!");
+        }
+
+        if (!correctionType.isAllowed(context, targetItem)) {
+            throw new UnprocessableEntityException("This item cannot be processed by this correction type!");
+        }
+
+        ObjectMapper mapper = new ObjectMapper();
+        CorrectionTypeMessageDTO reason = null;
+        try {
+            reason = mapper.readValue(request.getInputStream(), CorrectionTypeMessageDTO.class);
+        } catch (IOException exIO) {
+            throw new UnprocessableEntityException("error parsing the body " + exIO.getMessage(), exIO);
+        }
+
+        QAEvent qaEvent;
+        if (correctionType.isRequiredRelatedItem()) {
+            qaEvent = correctionType.createCorrection(context, targetItem, relatedItem, reason);
+        } else {
+            qaEvent = correctionType.createCorrection(context, targetItem, reason);
+        }
+        return converter.toRest(qaEvent, utils.obtainProjection());
+    }
+
+    @Override
+    public Class<QAEventRest> getDomainClass() {
+        return QAEventRest.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventTargetLinkRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventTargetLinkRepository.java
new file mode 100644
index 0000000000..d76b911890
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventTargetLinkRepository.java
@@ -0,0 +1,73 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import java.sql.SQLException;
+import java.util.UUID;
+import javax.annotation.Nullable;
+import javax.servlet.http.HttpServletRequest;
+
+import org.dspace.app.rest.model.ItemRest;
+import org.dspace.app.rest.model.QAEventRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.qaevent.service.QAEventService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Pageable;
+import org.springframework.data.rest.webmvc.ResourceNotFoundException;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * Link repository for "target" subresource of a qa event.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@Component(QAEventRest.CATEGORY + "." + QAEventRest.NAME + "." + QAEventRest.TARGET)
+public class QAEventTargetLinkRepository extends AbstractDSpaceRestRepository implements LinkRestRepository {
+
+    @Autowired
+    private QAEventService qaEventService;
+
+    @Autowired
+    private ItemService itemService;
+
+    /**
+     * Returns the item target of the qa event with the given id.
+     *
+     * @param request    the http servlet request
+     * @param id         the qa event id
+     * @param pageable   the optional pageable
+     * @param projection the projection object
+     * @return           the item rest representation of the qa event target
+     */
+    @PreAuthorize("hasPermission(#id, 'QUALITYASSURANCEEVENT', 'READ')")
+    public ItemRest getTarget(@Nullable HttpServletRequest request, String id, @Nullable Pageable pageable,
+            Projection projection) {
+        Context context = obtainContext();
+        QAEvent qaEvent = qaEventService.findEventByEventId(id);
+        if (qaEvent == null) {
+            throw new ResourceNotFoundException("No qa event with ID: " + id);
+        }
+        UUID itemUuid = UUID.fromString(qaEvent.getTarget());
+        Item item;
+        try {
+            item = itemService.find(context, itemUuid);
+            if (item == null) {
+                throw new ResourceNotFoundException("No target item found with id : " + id);
+            }
+            return converter.toRest(item, projection);
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventTopicLinkRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventTopicLinkRepository.java
new file mode 100644
index 0000000000..b363500fc7
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QAEventTopicLinkRepository.java
@@ -0,0 +1,64 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import javax.annotation.Nullable;
+import javax.servlet.http.HttpServletRequest;
+
+import org.dspace.app.rest.model.QAEventRest;
+import org.dspace.app.rest.model.QATopicRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.qaevent.QATopic;
+import org.dspace.qaevent.service.QAEventService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Pageable;
+import org.springframework.data.rest.webmvc.ResourceNotFoundException;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * Link repository for "topic" subresource of a qa event.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@Component(QAEventRest.CATEGORY + "." + QAEventRest.NAME + "." + QAEventRest.TOPIC)
+public class QAEventTopicLinkRepository extends AbstractDSpaceRestRepository implements LinkRestRepository {
+
+    @Autowired
+    private QAEventService qaEventService;
+
+    /**
+     * Returns the topic of the qa event with the given id.
+     *
+     * @param request    the http servlet request
+     * @param id         the qa event id
+     * @param pageable   the optional pageable
+     * @param projection the projection object
+     * @return           the qa topic rest representation
+     */
+    @PreAuthorize("hasPermission(#id, 'QUALITYASSURANCEEVENT', 'READ')")
+    public QATopicRest getTopic(@Nullable HttpServletRequest request, String id, @Nullable Pageable pageable,
+            Projection projection) {
+        Context context = obtainContext();
+        QAEvent qaEvent = qaEventService.findEventByEventId(id);
+        if (qaEvent == null) {
+            throw new ResourceNotFoundException("No qa event with ID: " + id);
+        }
+        String source = qaEvent.getSource();
+        String topicName = qaEvent.getTopic();
+        QATopic topic = qaEventService
+                .findTopicBySourceAndNameAndTarget(context, source, topicName, null);
+        if (topic == null) {
+            throw new ResourceNotFoundException("No topic found with source: " + source + " topic: " + topicName);
+        }
+        return converter.toRest(topic, projection);
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QASourceRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QASourceRestRepository.java
new file mode 100644
index 0000000000..8af833b8a3
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QASourceRestRepository.java
@@ -0,0 +1,74 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import java.util.List;
+import java.util.UUID;
+
+import org.dspace.app.rest.Parameter;
+import org.dspace.app.rest.SearchRestMethod;
+import org.dspace.app.rest.model.QASourceRest;
+import org.dspace.core.Context;
+import org.dspace.qaevent.QASource;
+import org.dspace.qaevent.service.QAEventService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * Rest repository that handle QA sources.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+@Component(QASourceRest.CATEGORY + "." + QASourceRest.NAME)
+public class QASourceRestRepository extends DSpaceRestRepository<QASourceRest, String> {
+
+    @Autowired
+    private QAEventService qaEventService;
+
+    @Override
+    @PreAuthorize("hasPermission(#id, 'QUALITYASSURANCESOURCE', 'READ')")
+    public QASourceRest findOne(Context context, String id) {
+        QASource qaSource = qaEventService.findSource(context, id);
+        if (qaSource == null) {
+            return null;
+        }
+        return converter.toRest(qaSource, utils.obtainProjection());
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    public Page<QASourceRest> findAll(Context context, Pageable pageable) {
+        List<QASource> qaSources = qaEventService.findAllSources(context, pageable.getOffset(), pageable.getPageSize());
+        long count = qaEventService.countSources(context);
+        return converter.toRestPage(qaSources, pageable, count, utils.obtainProjection());
+    }
+
+    @SearchRestMethod(name = "byTarget")
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    public Page<QASourceRest> findByTarget(@Parameter(value = "target", required = true) UUID target,
+           Pageable pageable) {
+        Context context = obtainContext();
+        List<QASource> topics = qaEventService.findAllSourcesByTarget(context, target,
+                                        pageable.getOffset(), pageable.getPageSize());
+        long count = qaEventService.countSourcesByTarget(context, target);
+        if (topics == null) {
+            return null;
+        }
+        return converter.toRestPage(topics, pageable, count, utils.obtainProjection());
+    }
+
+    @Override
+    public Class<QASourceRest> getDomainClass() {
+        return QASourceRest.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QATopicRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QATopicRestRepository.java
new file mode 100644
index 0000000000..bcd0be1bd4
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/QATopicRestRepository.java
@@ -0,0 +1,105 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import java.util.List;
+import java.util.UUID;
+
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.rest.Parameter;
+import org.dspace.app.rest.SearchRestMethod;
+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;
+import org.dspace.app.rest.model.QATopicRest;
+import org.dspace.core.Context;
+import org.dspace.qaevent.QATopic;
+import org.dspace.qaevent.service.QAEventService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.data.domain.Sort.Direction;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * Rest repository that handle QA topics.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@Component(QATopicRest.CATEGORY + "." + QATopicRest.NAME)
+public class QATopicRestRepository extends DSpaceRestRepository<QATopicRest, String> {
+
+    final static String ORDER_FIELD = "topic";
+
+    @Autowired
+    private QAEventService qaEventService;
+
+    private static final Logger log = LogManager.getLogger();
+
+    @Override
+    public Page<QATopicRest> findAll(Context context, Pageable pageable) {
+        throw new RepositoryMethodNotImplementedException("Method not allowed!", "");
+    }
+
+    @Override
+    @PreAuthorize("hasPermission(#id, 'QUALITYASSURANCETOPIC', 'READ')")
+    public QATopicRest findOne(Context context, String id) {
+        String[] topicIdSplitted = id.split(":", 3);
+        if (topicIdSplitted.length < 2) {
+            return null;
+        }
+        String sourceName = topicIdSplitted[0];
+        String topicName = topicIdSplitted[1].replaceAll("!", "/");
+        UUID target = topicIdSplitted.length == 3 ? UUID.fromString(topicIdSplitted[2]) : null;
+        QATopic topic = qaEventService.findTopicBySourceAndNameAndTarget(context, sourceName, topicName, target);
+        return (topic != null) ? converter.toRest(topic, utils.obtainProjection()) : null;
+    }
+
+    @SearchRestMethod(name = "bySource")
+    @PreAuthorize("hasPermission(#source, 'QUALITYASSURANCETOPIC', 'READ')")
+    public Page<QATopicRest> findBySource(@Parameter(value = "source", required = true) String source,
+           Pageable pageable) {
+        Context context = obtainContext();
+        boolean ascending = false;
+        if (pageable.getSort() != null && pageable.getSort().getOrderFor(ORDER_FIELD) != null) {
+            ascending = pageable.getSort().getOrderFor(ORDER_FIELD).getDirection() == Direction.ASC;
+        }
+        List<QATopic> topics = qaEventService.findAllTopicsBySource(context, source,
+                                              pageable.getOffset(), pageable.getPageSize(), ORDER_FIELD, ascending);
+        long count = qaEventService.countTopicsBySource(context, source);
+        if (topics == null) {
+            return null;
+        }
+        return converter.toRestPage(topics, pageable, count, utils.obtainProjection());
+    }
+
+    @SearchRestMethod(name = "byTarget")
+    @PreAuthorize("hasPermission(#target, 'ITEM', 'READ')")
+    public Page<QATopicRest> findByTarget(@Parameter(value = "target", required = true) UUID target,
+        @Parameter(value = "source", required = true) String source, Pageable pageable) {
+        Context context = obtainContext();
+        boolean ascending = false;
+        if (pageable.getSort() != null && pageable.getSort().getOrderFor(ORDER_FIELD) != null) {
+            ascending = pageable.getSort().getOrderFor(ORDER_FIELD).getDirection() == Direction.ASC;
+        }
+        List<QATopic> topics = qaEventService.findAllTopicsBySourceAndTarget(context, source, target,
+                                              pageable.getOffset(), pageable.getPageSize(), ORDER_FIELD, ascending);
+        long count = qaEventService.countTopicsBySourceAndTarget(context, source, target);
+        if (topics == null) {
+            return null;
+        }
+        return converter.toRestPage(topics, pageable, count, utils.obtainProjection());
+    }
+
+    @Override
+    public Class<QATopicRest> getDomainClass() {
+        return QATopicRest.class;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SubmissionAccessOptionRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SubmissionAccessOptionRestRepository.java
index a4117a6176..e31db7d5bb 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SubmissionAccessOptionRestRepository.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SubmissionAccessOptionRestRepository.java
@@ -48,4 +48,4 @@ public class SubmissionAccessOptionRestRepository extends DSpaceRestRepository<S
         return SubmissionAccessOptionRest.class;
     }
 
-}
\ No newline at end of file
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SubmissionCoarNotifyRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SubmissionCoarNotifyRestRepository.java
new file mode 100644
index 0000000000..7b88743e8f
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SubmissionCoarNotifyRestRepository.java
@@ -0,0 +1,54 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import org.dspace.app.rest.model.SubmissionCOARNotifyRest;
+import org.dspace.coarnotify.NotifySubmissionConfiguration;
+import org.dspace.coarnotify.service.SubmissionNotifyService;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.data.rest.webmvc.ResourceNotFoundException;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * This is the repository that is responsible to manage Submission COAR Notify Rest objects
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@Component(SubmissionCOARNotifyRest.CATEGORY + "." + SubmissionCOARNotifyRest.NAME)
+public class SubmissionCoarNotifyRestRepository extends DSpaceRestRepository<SubmissionCOARNotifyRest, String> {
+
+    @Autowired
+    protected SubmissionNotifyService submissionCOARNotifyService;
+
+    @Override
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    public SubmissionCOARNotifyRest findOne(final Context context, final String id) {
+        NotifySubmissionConfiguration coarNotifySubmissionConfiguration = submissionCOARNotifyService.findOne(id);
+        if (coarNotifySubmissionConfiguration == null) {
+            throw new ResourceNotFoundException(
+                "No COAR Notify Submission Configuration found for ID: " + id );
+        }
+        return converter.toRest(coarNotifySubmissionConfiguration, utils.obtainProjection());
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('AUTHENTICATED')")
+    public Page<SubmissionCOARNotifyRest> findAll(final Context context, final Pageable pageable) {
+        return converter.toRestPage(submissionCOARNotifyService.findAll(),
+            pageable, utils.obtainProjection());
+    }
+
+    @Override
+    public Class<SubmissionCOARNotifyRest> getDomainClass() {
+        return SubmissionCOARNotifyRest.class;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionRestRepository.java
new file mode 100644
index 0000000000..e2e1c3ce7c
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionRestRepository.java
@@ -0,0 +1,88 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import java.util.List;
+import java.util.UUID;
+
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.rest.Parameter;
+import org.dspace.app.rest.SearchRestMethod;
+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;
+import org.dspace.app.rest.model.SuggestionRest;
+import org.dspace.app.rest.model.SuggestionTargetRest;
+import org.dspace.app.suggestion.Suggestion;
+import org.dspace.app.suggestion.SuggestionService;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.data.domain.Sort.Direction;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * This is the repository responsible to manage Suggestion Target Rest object
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+
+@Component(SuggestionRest.CATEGORY + "." + SuggestionRest.NAME)
+public class SuggestionRestRepository extends DSpaceRestRepository<SuggestionRest, String> {
+    private final static String ORDER_FIELD = "trust";
+
+    private static final Logger log = org.apache.logging.log4j.LogManager.getLogger(SuggestionRestRepository.class);
+
+    @Autowired
+    private SuggestionService suggestionService;
+
+    @Override
+    @PreAuthorize("hasPermission(#id, 'SUGGESTION', 'READ')")
+    public SuggestionRest findOne(Context context, String id) {
+        Suggestion suggestion = suggestionService.findUnprocessedSuggestion(context, id);
+        if (suggestion == null) {
+            return null;
+        }
+        return converter.toRest(suggestion, utils.obtainProjection());
+    }
+
+    @Override
+    @PreAuthorize("permitAll()")
+    public Page<SuggestionRest> findAll(Context context, Pageable pageable) {
+        throw new RepositoryMethodNotImplementedException(SuggestionTargetRest.NAME, "findAll");
+    }
+
+    @PreAuthorize("hasPermission(#target, 'SUGGESTION.TARGET', 'READ')")
+    @SearchRestMethod(name = "findByTargetAndSource")
+    public Page<SuggestionRest> findByTargetAndSource(
+            @Parameter(required = true, value = "source") String source,
+            @Parameter(required = true, value = "target") UUID target, Pageable pageable) {
+        Context context = obtainContext();
+        boolean ascending = false;
+        if (pageable.getSort() != null && pageable.getSort().getOrderFor(ORDER_FIELD) != null) {
+            ascending = pageable.getSort().getOrderFor(ORDER_FIELD).getDirection() == Direction.ASC;
+        }
+        List<Suggestion> suggestions = suggestionService.findByTargetAndSource(context, target, source,
+                pageable.getPageSize(), pageable.getOffset(), ascending);
+        long tot = suggestionService.countAllByTargetAndSource(context, source, target);
+        return converter.toRestPage(suggestions, pageable, tot, utils.obtainProjection());
+    }
+
+    @Override
+    @PreAuthorize("hasPermission(#id, 'SUGGESTION', 'DELETE')")
+    protected void delete(Context context, String id)
+            throws AuthorizeException, RepositoryMethodNotImplementedException {
+        suggestionService.rejectSuggestion(context, id);
+    }
+
+    @Override
+    public Class<SuggestionRest> getDomainClass() {
+        return SuggestionRest.class;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionSourceRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionSourceRestRepository.java
new file mode 100644
index 0000000000..6bc251749b
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionSourceRestRepository.java
@@ -0,0 +1,64 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import java.util.List;
+
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.rest.model.SuggestionSourceRest;
+import org.dspace.app.suggestion.SuggestionService;
+import org.dspace.app.suggestion.SuggestionSource;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * This is the repository responsible to manage Suggestion Target Rest object
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+
+@Component(SuggestionSourceRest.CATEGORY + "." + SuggestionSourceRest.NAME)
+public class SuggestionSourceRestRepository extends DSpaceRestRepository<SuggestionSourceRest, String> {
+
+    private static final Logger log = org.apache.logging.log4j.LogManager
+            .getLogger(SuggestionSourceRestRepository.class);
+
+    @Autowired
+    private SuggestionService suggestionService;
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    public SuggestionSourceRest findOne(Context context, String source) {
+        SuggestionSource suggestionSource = suggestionService.findSource(context, source);
+        if (suggestionSource == null) {
+            return null;
+        }
+        return converter.toRest(suggestionSource, utils.obtainProjection());
+    }
+
+    @Override
+    @PreAuthorize("hasAuthority('ADMIN')")
+    public Page<SuggestionSourceRest> findAll(Context context, Pageable pageable) {
+        List<SuggestionSource> suggestionSources = suggestionService.findAllSources(context, pageable.getPageSize(),
+                pageable.getOffset());
+        long count = suggestionService.countSources(context);
+        if (suggestionSources == null) {
+            return null;
+        }
+        return converter.toRestPage(suggestionSources, pageable, count, utils.obtainProjection());
+    }
+
+    @Override
+    public Class<SuggestionSourceRest> getDomainClass() {
+        return SuggestionSourceRest.class;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionTargetRestRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionTargetRestRepository.java
new file mode 100644
index 0000000000..e8498cb68c
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionTargetRestRepository.java
@@ -0,0 +1,98 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import java.util.List;
+import java.util.UUID;
+
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.rest.Parameter;
+import org.dspace.app.rest.SearchRestMethod;
+import org.dspace.app.rest.exception.RepositoryMethodNotImplementedException;
+import org.dspace.app.rest.model.SuggestionTargetRest;
+import org.dspace.app.suggestion.SuggestionService;
+import org.dspace.app.suggestion.SuggestionTarget;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Page;
+import org.springframework.data.domain.Pageable;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * This is the repository responsible to manage Suggestion Target Rest object
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ */
+
+@Component(SuggestionTargetRest.CATEGORY + "." + SuggestionTargetRest.NAME)
+public class SuggestionTargetRestRepository extends DSpaceRestRepository<SuggestionTargetRest, String> {
+
+    private static final Logger log = org.apache.logging.log4j.LogManager
+            .getLogger(SuggestionTargetRestRepository.class);
+
+    @Autowired
+    private SuggestionService suggestionService;
+
+    @Override
+    @PreAuthorize("hasPermission(#id, 'SUGGESTIONTARGET', 'READ')")
+    public SuggestionTargetRest findOne(Context context, String id) {
+        String source = null;
+        UUID uuid = null;
+        try {
+            source = id.split(":")[0];
+            uuid = UUID.fromString(id.split(":")[1]);
+        } catch (Exception e) {
+            return null;
+        }
+        SuggestionTarget suggestionTarget = suggestionService.find(context, source, uuid);
+        if (suggestionTarget == null) {
+            return null;
+        }
+        return converter.toRest(suggestionTarget, utils.obtainProjection());
+    }
+
+    @Override
+    @PreAuthorize("permitAll()")
+    public Page<SuggestionTargetRest> findAll(Context context, Pageable pageable) {
+        throw new RepositoryMethodNotImplementedException(SuggestionTargetRest.NAME, "findAll");
+    }
+
+    @PreAuthorize("hasAuthority('ADMIN')")
+    @SearchRestMethod(name = "findBySource")
+    public Page<SuggestionTargetRest> findBySource(@Parameter(required = true, value = "source") String source,
+            Pageable pageable) {
+        Context context = obtainContext();
+        List<SuggestionTarget> suggestionTargets = suggestionService.findAllTargets(context, source,
+                pageable.getPageSize(), pageable.getOffset());
+        long tot = suggestionService.countAll(context, source);
+        if (suggestionTargets == null) {
+            return null;
+        }
+        return converter.toRestPage(suggestionTargets, pageable, tot, utils.obtainProjection());
+    }
+
+    @PreAuthorize("hasPermission(#target, 'SUGGESTIONTARGET.TARGET', 'READ')")
+    @SearchRestMethod(name = "findByTarget")
+    public Page<SuggestionTargetRest> findByTarget(@Parameter(required = true, value = "target") UUID target,
+            Pageable pageable) {
+        Context context = obtainContext();
+        List<SuggestionTarget> suggestionTargets = suggestionService.findByTarget(context, target,
+                pageable.getPageSize(), pageable.getOffset());
+        long tot = suggestionService.countAllByTarget(context, target);
+        if (suggestionTargets == null) {
+            return null;
+        }
+        return converter.toRestPage(suggestionTargets, pageable, tot, utils.obtainProjection());
+    }
+
+    @Override
+    public Class<SuggestionTargetRest> getDomainClass() {
+        return SuggestionTargetRest.class;
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionTargetTargetLinkRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionTargetTargetLinkRepository.java
new file mode 100644
index 0000000000..50c6e4d48e
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/SuggestionTargetTargetLinkRepository.java
@@ -0,0 +1,70 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository;
+
+import java.sql.SQLException;
+import java.util.UUID;
+import javax.annotation.Nullable;
+import javax.servlet.http.HttpServletRequest;
+
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.app.rest.model.ItemRest;
+import org.dspace.app.rest.model.SuggestionTargetRest;
+import org.dspace.app.rest.projection.Projection;
+import org.dspace.content.Item;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.data.domain.Pageable;
+import org.springframework.data.rest.webmvc.ResourceNotFoundException;
+import org.springframework.security.access.prepost.PreAuthorize;
+import org.springframework.stereotype.Component;
+
+/**
+ * Link repository for "target" subresource of an suggestion target.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@Component(SuggestionTargetRest.CATEGORY + "." + SuggestionTargetRest.NAME + "." + SuggestionTargetRest.TARGET)
+public class SuggestionTargetTargetLinkRepository extends AbstractDSpaceRestRepository implements LinkRestRepository {
+
+    @Autowired
+    private ItemService itemService;
+
+    /**
+     * Returns the item related to the suggestion target with the given id.
+     *
+     * @param request    the http servlet request
+     * @param id         the suggestion target UUID
+     * @param pageable   the optional pageable
+     * @param projection the projection object
+     * @return the target item rest representation
+     */
+    @PreAuthorize("hasPermission(#id, 'SUGGESTIONTARGET', 'READ')")
+    public ItemRest getTarget(@Nullable HttpServletRequest request, String id,
+        @Nullable Pageable pageable, Projection projection) {
+        String source = id.split(":")[0];
+        UUID uuid = UUID.fromString(id.split(":")[1]);
+        if (StringUtils.isBlank(source) || uuid == null) {
+            throw new ResourceNotFoundException("No such item related to a suggestion target with UUID: " + id);
+        }
+        try {
+            Context context = obtainContext();
+            Item profile = itemService.find(context, uuid);
+            if (profile == null) {
+                throw new ResourceNotFoundException("No such item related to a suggestion target with UUID: " + id);
+            }
+
+            return converter.toRest(profile, projection);
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/VersionHistoryDraftVersionLinkRepository.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/VersionHistoryDraftVersionLinkRepository.java
index 21d90ddda0..4416f78fd3 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/VersionHistoryDraftVersionLinkRepository.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/VersionHistoryDraftVersionLinkRepository.java
@@ -79,4 +79,4 @@ public class VersionHistoryDraftVersionLinkRepository extends AbstractDSpaceRest
         return null;
     }
 
-}
\ No newline at end of file
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/handler/ExternalSourceCorrectionTypeUriListHandler.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/handler/ExternalSourceCorrectionTypeUriListHandler.java
new file mode 100644
index 0000000000..f3776e217e
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/handler/ExternalSourceCorrectionTypeUriListHandler.java
@@ -0,0 +1,72 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.handler;
+
+import java.sql.SQLException;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import javax.servlet.http.HttpServletRequest;
+
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.core.Context;
+import org.dspace.correctiontype.CorrectionType;
+import org.dspace.correctiontype.service.CorrectionTypeService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * This class extends the {@link ExternalSourceEntryItemUriListHandler} abstract class and implements it specifically
+ * for the List<{@link CorrectionType}> objects.
+ * 
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@Component
+public class ExternalSourceCorrectionTypeUriListHandler extends ExternalSourceEntryItemUriListHandler<CorrectionType> {
+
+    @Autowired
+    private CorrectionTypeService correctionTypeService;
+
+    @Override
+    @SuppressWarnings("rawtypes")
+    public boolean supports(List<String> uriList, String method,Class clazz) {
+        return clazz != CorrectionType.class ? false : true;
+    }
+
+    @Override
+    public CorrectionType handle(Context context, HttpServletRequest request, List<String> uriList)
+            throws SQLException, AuthorizeException {
+        return getObjectFromUriList(context, uriList);
+    }
+
+    @Override
+    public boolean validate(Context context, HttpServletRequest request, List<String> uriList)
+        throws AuthorizeException {
+        return uriList.size() > 1 ? false : true;
+    }
+
+
+    private CorrectionType getObjectFromUriList(Context context, List<String> uriList) {
+        CorrectionType correctionType = null;
+        String url = uriList.get(0);
+        Pattern pattern = Pattern.compile("\\/api\\/config\\/correctiontypes\\/(.*)");
+        Matcher matcher = pattern.matcher(url);
+        if (!matcher.find()) {
+            throw new DSpaceBadRequestException("The uri: " + url + " doesn't resolve to an correction type");
+        }
+        String id = matcher.group(1);
+        try {
+            correctionType = correctionTypeService.findOne(id);
+        } catch (Exception e) {
+            throw new RuntimeException(e.getMessage(), e);
+        }
+        return correctionType;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/PatchOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/PatchOperation.java
index 0842746f32..9864dae09d 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/PatchOperation.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/PatchOperation.java
@@ -59,7 +59,7 @@ public abstract class PatchOperation<M> {
      * @return the original or derived boolean value
      * @throws DSpaceBadRequestException
      */
-    Boolean getBooleanOperationValue(Object value) {
+    protected Boolean getBooleanOperationValue(Object value) {
         Boolean bool;
 
         if (value instanceof String) {
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/QAEventStatusReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/QAEventStatusReplaceOperation.java
new file mode 100644
index 0000000000..5f6ff02acc
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/QAEventStatusReplaceOperation.java
@@ -0,0 +1,60 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation;
+
+import java.sql.SQLException;
+
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.qaevent.service.QAEventActionService;
+import org.dspace.services.RequestService;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Replace operation related to the {@link QAEvent} status.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@Component
+public class QAEventStatusReplaceOperation extends PatchOperation<QAEvent> {
+    @Autowired
+    private RequestService requestService;
+
+    @Autowired
+    private QAEventActionService qaEventActionService;
+
+    @Override
+    public QAEvent perform(Context context, QAEvent qaevent, Operation operation) throws SQLException {
+        String value = (String) operation.getValue();
+        if (StringUtils.equalsIgnoreCase(value, QAEvent.ACCEPTED)) {
+            qaEventActionService.accept(context, qaevent);
+        } else if (StringUtils.equalsIgnoreCase(value, QAEvent.REJECTED)) {
+            qaEventActionService.reject(context, qaevent);
+        } else if (StringUtils.equalsIgnoreCase(value, QAEvent.DISCARDED)) {
+            qaEventActionService.discard(context, qaevent);
+        } else {
+            throw new IllegalArgumentException(
+                    "The received operation is not valid: " + operation.getPath() + " - " + value);
+        }
+        qaevent.setStatus(value.toUpperCase());
+        // HACK, we need to store the temporary object in the request so that a subsequent find would get it
+        requestService.getCurrentRequest().setAttribute("patchedNotificationEvent", qaevent);
+        return qaevent;
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return StringUtils.equals(operation.getOp(), "replace") && objectToMatch instanceof QAEvent && StringUtils
+                .containsAny(operation.getValue().toString().toLowerCase(), QAEvent.ACCEPTED, QAEvent.DISCARDED,
+                        QAEvent.REJECTED);
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceDescriptionAddOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceDescriptionAddOperation.java
new file mode 100644
index 0000000000..0f973a9760
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceDescriptionAddOperation.java
@@ -0,0 +1,77 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Description Add patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "add",
+ *  "path": "/description",
+ *  "value": "description value"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceDescriptionAddOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/description";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        checkOperationValue(operation.getValue());
+
+        Object description = operation.getValue();
+        if (description == null | !(description instanceof String)) {
+            throw new UnprocessableEntityException("The /description value must be a string");
+        }
+
+        checkNonExistingDescriptionValue(notifyServiceEntity);
+        notifyServiceEntity.setDescription((String) description);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    /**
+     * Throws PatchBadRequestException if a value is already set in the /description path.
+     *
+     * @param notifyServiceEntity the notifyServiceEntity to update
+
+     */
+    void checkNonExistingDescriptionValue(NotifyServiceEntity notifyServiceEntity) {
+        if (notifyServiceEntity.getDescription() != null) {
+            throw new DSpaceBadRequestException("Attempting to add a value to an already existing path.");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_ADD) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceDescriptionRemoveOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceDescriptionRemoveOperation.java
new file mode 100644
index 0000000000..18e9515b0f
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceDescriptionRemoveOperation.java
@@ -0,0 +1,54 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Description Remove patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "remove",
+ *  "path": "/description"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceDescriptionRemoveOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/description";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        notifyServiceEntity.setDescription(null);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REMOVE) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceDescriptionReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceDescriptionReplaceOperation.java
new file mode 100644
index 0000000000..8f7eedc758
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceDescriptionReplaceOperation.java
@@ -0,0 +1,74 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Description Replace patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "/description",
+ *  "value": "description value"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceDescriptionReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/description";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+
+        Object description = operation.getValue();
+        if (description == null | !(description instanceof String)) {
+            throw new UnprocessableEntityException("The /description value must be a string");
+        }
+
+        checkModelForExistingValue(notifyServiceEntity);
+        notifyServiceEntity.setDescription((String) description);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    /**
+     * Checks whether the description of notifyServiceEntity has an existing value to replace
+     * @param notifyServiceEntity Object on which patch is being done
+     */
+    private void checkModelForExistingValue(NotifyServiceEntity notifyServiceEntity) {
+        if (notifyServiceEntity.getDescription() == null) {
+            throw new DSpaceBadRequestException("Attempting to replace a non-existent value (description).");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceEnabledReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceEnabledReplaceOperation.java
new file mode 100644
index 0000000000..ccfa6e9020
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceEnabledReplaceOperation.java
@@ -0,0 +1,66 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Enabled Replace patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "/enabled"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceEnabledReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = "/enabled";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        checkOperationValue(operation.getValue());
+        Boolean enabled = getBooleanOperationValue(operation.getValue());
+
+        if (supports(notifyServiceEntity, operation)) {
+            notifyServiceEntity.setEnabled(enabled);
+            notifyService.update(context, notifyServiceEntity);
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceEnabledReplaceOperation does not support this operation");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternAutomaticReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternAutomaticReplaceOperation.java
new file mode 100644
index 0000000000..0f3d8c394d
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternAutomaticReplaceOperation.java
@@ -0,0 +1,83 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static org.dspace.app.rest.repository.patch.operation.ldn.NotifyServicePatchUtils.NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Inbound patterns Automatic Replace patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "notifyServiceInboundPatterns[index]/automatic"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceInboundPatternAutomaticReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = "/automatic";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation) {
+        checkOperationValue(operation.getValue());
+        Boolean automatic = getBooleanOperationValue(operation.getValue());
+        if (supports(notifyServiceEntity, operation)) {
+            try {
+                int index = notifyServicePatchUtils.extractIndexFromOperation(operation);
+
+                List<NotifyServiceInboundPattern> inboundPatterns = notifyServiceEntity.getInboundPatterns();
+
+                if (index >= inboundPatterns.size()) {
+                    throw new DSpaceBadRequestException("the provided index[" + index + "] is out of the rang");
+                }
+
+                NotifyServiceInboundPattern inboundPattern = inboundPatterns.get(index);
+                inboundPattern.setAutomatic(automatic);
+                inboundPatternService.update(context, inboundPattern);
+            } catch (SQLException e) {
+                throw new RuntimeException(e.getMessage(), e);
+            }
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceInboundPatternAutomaticReplaceOperation does not support this operation");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        String path = operation.getPath().trim();
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            path.startsWith(NOTIFY_SERVICE_INBOUND_PATTERNS + "[") &&
+            path.endsWith(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternConstraintAddOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternConstraintAddOperation.java
new file mode 100644
index 0000000000..e82243f9a7
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternConstraintAddOperation.java
@@ -0,0 +1,95 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static org.dspace.app.rest.repository.patch.operation.ldn.NotifyServicePatchUtils.NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Inbound patterns Constraint Add patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "add",
+ *  "path": "notifyServiceInboundPatterns[index]/constraint"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceInboundPatternConstraintAddOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = "/constraint";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation) {
+        checkOperationValue(operation.getValue());
+        if (supports(notifyServiceEntity, operation)) {
+            try {
+                int index = notifyServicePatchUtils.extractIndexFromOperation(operation);
+
+                List<NotifyServiceInboundPattern> inboundPatterns = notifyServiceEntity.getInboundPatterns();
+
+                if (index >= inboundPatterns.size()) {
+                    throw new DSpaceBadRequestException("the provided index[" + index + "] is out of the rang");
+                }
+
+                NotifyServiceInboundPattern inboundPattern = inboundPatterns.get(index);
+                Object constraint = operation.getValue();
+                if (constraint == null | !(constraint instanceof String)) {
+                    throw new UnprocessableEntityException("The /constraint value must be a string");
+                }
+
+                checkNonExistingConstraintValue(inboundPattern);
+                inboundPattern.setConstraint((String) constraint);
+                inboundPatternService.update(context, inboundPattern);
+            } catch (SQLException e) {
+                throw new RuntimeException(e.getMessage(), e);
+            }
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceInboundPatternConstraintAddOperation does not support this operation");
+        }
+    }
+
+    private void checkNonExistingConstraintValue(NotifyServiceInboundPattern inboundPattern) {
+        if (inboundPattern.getConstraint() != null) {
+            throw new DSpaceBadRequestException("Attempting to add a value to an already existing path.");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        String path = operation.getPath().trim();
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_ADD) &&
+            path.startsWith(NOTIFY_SERVICE_INBOUND_PATTERNS + "[") &&
+            path.endsWith(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternConstraintRemoveOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternConstraintRemoveOperation.java
new file mode 100644
index 0000000000..52d0a6bf73
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternConstraintRemoveOperation.java
@@ -0,0 +1,81 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static org.dspace.app.rest.repository.patch.operation.ldn.NotifyServicePatchUtils.NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Inbound patterns Constraint Remove patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "remove",
+ *  "path": "notifyServiceInboundPatterns[index]/constraint"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceInboundPatternConstraintRemoveOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = "/constraint";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation) {
+        if (supports(notifyServiceEntity, operation)) {
+            try {
+                int index = notifyServicePatchUtils.extractIndexFromOperation(operation);
+
+                List<NotifyServiceInboundPattern> inboundPatterns = notifyServiceEntity.getInboundPatterns();
+
+                if (index >= inboundPatterns.size()) {
+                    throw new DSpaceBadRequestException("the provided index[" + index + "] is out of the rang");
+                }
+
+                NotifyServiceInboundPattern inboundPattern = inboundPatterns.get(index);
+                inboundPattern.setConstraint(null);
+                inboundPatternService.update(context, inboundPattern);
+            } catch (SQLException e) {
+                throw new RuntimeException(e.getMessage(), e);
+            }
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceInboundPatternConstraintRemoveOperation does not support this operation");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        String path = operation.getPath().trim();
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REMOVE) &&
+            path.startsWith(NOTIFY_SERVICE_INBOUND_PATTERNS + "[") &&
+            path.endsWith(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternConstraintReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternConstraintReplaceOperation.java
new file mode 100644
index 0000000000..6faaadbfac
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternConstraintReplaceOperation.java
@@ -0,0 +1,95 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static org.dspace.app.rest.repository.patch.operation.ldn.NotifyServicePatchUtils.NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Inbound patterns Constraint Replace patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "notifyServiceInboundPatterns[index]/constraint"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceInboundPatternConstraintReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = "/constraint";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation) {
+        checkOperationValue(operation.getValue());
+        if (supports(notifyServiceEntity, operation)) {
+            try {
+                int index = notifyServicePatchUtils.extractIndexFromOperation(operation);
+
+                List<NotifyServiceInboundPattern> inboundPatterns = notifyServiceEntity.getInboundPatterns();
+
+                if (index >= inboundPatterns.size()) {
+                    throw new DSpaceBadRequestException("the provided index[" + index + "] is out of the rang");
+                }
+
+                NotifyServiceInboundPattern inboundPattern = inboundPatterns.get(index);
+                Object constraint = operation.getValue();
+                if (constraint == null | !(constraint instanceof String)) {
+                    throw new UnprocessableEntityException("The /constraint value must be a string");
+                }
+
+                checkModelForExistingValue(inboundPattern);
+                inboundPattern.setConstraint((String) constraint);
+                inboundPatternService.update(context, inboundPattern);
+            } catch (SQLException e) {
+                throw new RuntimeException(e.getMessage(), e);
+            }
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceInboundPatternConstraintReplaceOperation does not support this operation");
+        }
+    }
+
+    private void checkModelForExistingValue(NotifyServiceInboundPattern inboundPattern) {
+        if (inboundPattern.getConstraint() == null) {
+            throw new DSpaceBadRequestException("Attempting to replace a non-existent value (constraint).");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        String path = operation.getPath().trim();
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            path.startsWith(NOTIFY_SERVICE_INBOUND_PATTERNS + "[") &&
+            path.endsWith(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternPatternAddOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternPatternAddOperation.java
new file mode 100644
index 0000000000..17f92057f9
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternPatternAddOperation.java
@@ -0,0 +1,95 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static org.dspace.app.rest.repository.patch.operation.ldn.NotifyServicePatchUtils.NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Inbound patterns Pattern Add patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "add",
+ *  "path": "notifyServiceInboundPatterns[index]/pattern"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceInboundPatternPatternAddOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = "/pattern";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation) {
+        checkOperationValue(operation.getValue());
+        if (supports(notifyServiceEntity, operation)) {
+            try {
+                int index = notifyServicePatchUtils.extractIndexFromOperation(operation);
+
+                List<NotifyServiceInboundPattern> inboundPatterns = notifyServiceEntity.getInboundPatterns();
+
+                if (index >= inboundPatterns.size()) {
+                    throw new DSpaceBadRequestException("the provided index[" + index + "] is out of the rang");
+                }
+
+                NotifyServiceInboundPattern inboundPattern = inboundPatterns.get(index);
+                Object pattern = operation.getValue();
+                if (pattern == null | !(pattern instanceof String)) {
+                    throw new UnprocessableEntityException("The /pattern value must be a string");
+                }
+
+                checkNonExistingPatternValue(inboundPattern);
+                inboundPattern.setPattern((String) pattern);
+                inboundPatternService.update(context, inboundPattern);
+            } catch (SQLException e) {
+                throw new RuntimeException(e.getMessage(), e);
+            }
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceInboundPatternPatternAddOperation does not support this operation");
+        }
+    }
+
+    private void checkNonExistingPatternValue(NotifyServiceInboundPattern inboundPattern) {
+        if (inboundPattern.getPattern() != null) {
+            throw new DSpaceBadRequestException("Attempting to add a value to an already existing path.");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        String path = operation.getPath().trim();
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_ADD) &&
+            path.startsWith(NOTIFY_SERVICE_INBOUND_PATTERNS + "[") &&
+            path.endsWith(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternPatternReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternPatternReplaceOperation.java
new file mode 100644
index 0000000000..5c32cec62b
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternPatternReplaceOperation.java
@@ -0,0 +1,95 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static org.dspace.app.rest.repository.patch.operation.ldn.NotifyServicePatchUtils.NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Inbound patterns Pattern Replace patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "notifyServiceInboundPatterns[index]/pattern"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceInboundPatternPatternReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = "/pattern";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation) {
+        checkOperationValue(operation.getValue());
+        if (supports(notifyServiceEntity, operation)) {
+            try {
+                int index = notifyServicePatchUtils.extractIndexFromOperation(operation);
+
+                List<NotifyServiceInboundPattern> inboundPatterns = notifyServiceEntity.getInboundPatterns();
+
+                if (index >= inboundPatterns.size()) {
+                    throw new DSpaceBadRequestException("the provided index[" + index + "] is out of the rang");
+                }
+
+                NotifyServiceInboundPattern inboundPattern = inboundPatterns.get(index);
+                Object pattern = operation.getValue();
+                if (pattern == null | !(pattern instanceof String)) {
+                    throw new UnprocessableEntityException("The /pattern value must be a string");
+                }
+
+                checkModelForExistingValue(inboundPattern);
+                inboundPattern.setPattern((String) pattern);
+                inboundPatternService.update(context, inboundPattern);
+            } catch (SQLException e) {
+                throw new RuntimeException(e.getMessage(), e);
+            }
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceInboundPatternPatternReplaceOperation does not support this operation");
+        }
+    }
+
+    private void checkModelForExistingValue(NotifyServiceInboundPattern inboundPattern) {
+        if (inboundPattern.getPattern() == null) {
+            throw new DSpaceBadRequestException("Attempting to replace a non-existent value (pattern).");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        String path = operation.getPath().trim();
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            path.startsWith(NOTIFY_SERVICE_INBOUND_PATTERNS + "[") &&
+            path.endsWith(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternRemoveOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternRemoveOperation.java
new file mode 100644
index 0000000000..45b9dff74d
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternRemoveOperation.java
@@ -0,0 +1,79 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static org.dspace.app.rest.repository.patch.operation.ldn.NotifyServicePatchUtils.NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Inbound pattern Remove patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "remove",
+ *  "path": "notifyServiceInboundPatterns[index]"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceInboundPatternRemoveOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = NOTIFY_SERVICE_INBOUND_PATTERNS + "[";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation) {
+        if (supports(notifyServiceEntity, operation)) {
+            try {
+                int index = notifyServicePatchUtils.extractIndexFromOperation(operation);
+
+                List<NotifyServiceInboundPattern> inboundPatterns = notifyServiceEntity.getInboundPatterns();
+
+                if (index >= inboundPatterns.size()) {
+                    throw new DSpaceBadRequestException("the provided index[" + index + "] is out of the rang");
+                }
+
+                inboundPatternService.delete(context, inboundPatterns.get(index));
+            } catch (SQLException e) {
+                throw new RuntimeException(e.getMessage(), e);
+            }
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceInboundPatternRemoveOperation does not support this operation");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        String path = operation.getPath().trim();
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REMOVE) &&
+            path.startsWith(OPERATION_PATH) &&
+            path.endsWith("]"));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternReplaceOperation.java
new file mode 100644
index 0000000000..65e4bd2eed
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternReplaceOperation.java
@@ -0,0 +1,89 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static org.dspace.app.rest.repository.patch.operation.ldn.NotifyServicePatchUtils.NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Inbound patterns Replace One patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "notifyServiceInboundPatterns[index]",
+ *  "value": {"pattern":"patternA","constraint":"itemFilterA","automatic":"false"}
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceInboundPatternReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = NOTIFY_SERVICE_INBOUND_PATTERNS + "[";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation) {
+        checkOperationValue(operation.getValue());
+        if (supports(notifyServiceEntity, operation)) {
+            try {
+                int index = notifyServicePatchUtils.extractIndexFromOperation(operation);
+
+                List<NotifyServiceInboundPattern> inboundPatterns = notifyServiceEntity.getInboundPatterns();
+
+                if (index >= inboundPatterns.size()) {
+                    throw new DSpaceBadRequestException("the provided index[" + index + "] is out of the rang");
+                }
+
+                NotifyServiceInboundPattern patchInboundPattern =
+                    notifyServicePatchUtils.extractNotifyServiceInboundPatternFromOperation(operation);
+
+                NotifyServiceInboundPattern existedInboundPattern = inboundPatterns.get(index);
+
+                existedInboundPattern.setPattern(patchInboundPattern.getPattern());
+                existedInboundPattern.setConstraint(patchInboundPattern.getConstraint());
+                existedInboundPattern.setAutomatic(patchInboundPattern.isAutomatic());
+                inboundPatternService.update(context, existedInboundPattern);
+            } catch (SQLException e) {
+                throw new RuntimeException(e.getMessage(), e);
+            }
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceInboundPatternReplaceOperation does not support this operation");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        String path = operation.getPath().trim();
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            path.startsWith(OPERATION_PATH) &&
+            path.endsWith("]"));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternsAddOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternsAddOperation.java
new file mode 100644
index 0000000000..a734bb5a55
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternsAddOperation.java
@@ -0,0 +1,87 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static org.dspace.app.rest.repository.patch.operation.ldn.NotifyServicePatchUtils.NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+import java.sql.SQLException;
+
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Inbound patterns Add patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "add",
+ *  "path": "notifyServiceInboundPatterns/-",
+ *  "value": {"pattern":"patternA","constraint":"itemFilterA","automatic":"false"}
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceInboundPatternsAddOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = NOTIFY_SERVICE_INBOUND_PATTERNS + "/-";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation) {
+        checkOperationValue(operation.getValue());
+        if (supports(notifyServiceEntity, operation)) {
+            try {
+                NotifyServiceInboundPattern patchInboundPattern =
+                    notifyServicePatchUtils.extractNotifyServiceInboundPatternFromOperation(operation);
+
+                NotifyServiceInboundPattern persistInboundPattern = inboundPatternService.findByServiceAndPattern(
+                    context, notifyServiceEntity, patchInboundPattern.getPattern());
+
+                if (persistInboundPattern != null && (StringUtils.isNotBlank(persistInboundPattern.getConstraint())
+                    && persistInboundPattern.getConstraint().equals(patchInboundPattern
+                        .getConstraint()))) {
+                    throw new DSpaceBadRequestException("the provided InboundPattern is already existed");
+                }
+
+                NotifyServiceInboundPattern inboundPattern =
+                    inboundPatternService.create(context, notifyServiceEntity);
+                inboundPattern.setPattern(patchInboundPattern.getPattern());
+                inboundPattern.setConstraint(patchInboundPattern.getConstraint());
+                inboundPattern.setAutomatic(patchInboundPattern.isAutomatic());
+            } catch (SQLException e) {
+                throw new RuntimeException(e.getMessage(), e);
+            }
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceInboundPatternsAddOperation does not support this operation");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_ADD) &&
+            operation.getPath().trim().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternsRemoveOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternsRemoveOperation.java
new file mode 100644
index 0000000000..76890f792e
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternsRemoveOperation.java
@@ -0,0 +1,71 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static org.dspace.app.rest.repository.patch.operation.ldn.NotifyServicePatchUtils.NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Inbound patterns Remove All patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "remove",
+ *  "path": "notifyServiceInboundPatterns"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceInboundPatternsRemoveOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation) {
+        if (supports(notifyServiceEntity, operation)) {
+            try {
+                for (NotifyServiceInboundPattern inboundPattern : notifyServiceEntity.getInboundPatterns()) {
+                    inboundPatternService.delete(context, inboundPattern);
+                }
+            } catch (SQLException e) {
+                throw new RuntimeException(e.getMessage(), e);
+            }
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceInboundPatternsRemoveOperation does not support this operation");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        String path = operation.getPath().trim();
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REMOVE) &&
+            path.startsWith(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternsReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternsReplaceOperation.java
new file mode 100644
index 0000000000..2dd98e7d17
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceInboundPatternsReplaceOperation.java
@@ -0,0 +1,88 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static org.dspace.app.rest.repository.patch.operation.ldn.NotifyServicePatchUtils.NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+import java.sql.SQLException;
+import java.util.List;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.ldn.service.NotifyServiceInboundPatternService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Inbound patterns Replace All patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "notifyServiceInboundPatterns",
+ *  "value": [{"pattern":"patternA","constraint":"itemFilterA","automatic":"false"}]
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceInboundPatternsReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyServiceInboundPatternService inboundPatternService;
+
+    @Autowired
+    private NotifyServicePatchUtils notifyServicePatchUtils;
+
+    private static final String OPERATION_PATH = NOTIFY_SERVICE_INBOUND_PATTERNS;
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation) {
+        checkOperationValue(operation.getValue());
+        if (supports(notifyServiceEntity, operation)) {
+            try {
+                List<NotifyServiceInboundPattern> patchInboundPatterns =
+                    notifyServicePatchUtils.extractNotifyServiceInboundPatternsFromOperation(operation);
+
+                notifyServiceEntity.getInboundPatterns().forEach(inboundPattern -> {
+                    try {
+                        inboundPatternService.delete(context, inboundPattern);
+                    } catch (SQLException e) {
+                        throw new RuntimeException(e);
+                    }
+                });
+
+                for (NotifyServiceInboundPattern patchInboundPattern : patchInboundPatterns) {
+                    NotifyServiceInboundPattern inboundPattern =
+                        inboundPatternService.create(context, notifyServiceEntity);
+                    inboundPattern.setPattern(patchInboundPattern.getPattern());
+                    inboundPattern.setConstraint(patchInboundPattern.getConstraint());
+                    inboundPattern.setAutomatic(patchInboundPattern.isAutomatic());
+                }
+            } catch (SQLException e) {
+                throw new RuntimeException(e.getMessage(), e);
+            }
+            return notifyServiceEntity;
+        } else {
+            throw new DSpaceBadRequestException(
+                "NotifyServiceInboundPatternsReplaceOperation does not support this operation");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            operation.getPath().trim().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceLdnUrlReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceLdnUrlReplaceOperation.java
new file mode 100644
index 0000000000..bad2f280e0
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceLdnUrlReplaceOperation.java
@@ -0,0 +1,82 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static java.lang.String.format;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService ldnUrl Replace patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "/ldnurl",
+ *  "value": "ldnurl value"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceLdnUrlReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/ldnurl";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        checkOperationValue(operation.getValue());
+
+        Object ldnUrl = operation.getValue();
+        if (ldnUrl == null | !(ldnUrl instanceof String)) {
+            throw new UnprocessableEntityException("The /ldnurl value must be a string");
+        }
+
+        if (notifyService.findByLdnUrl(context,(String) ldnUrl) != null) {
+            throw new UnprocessableEntityException(format("LDN url already in use %s",
+                (String) ldnUrl));
+        }
+
+        checkModelForExistingValue(notifyServiceEntity);
+        notifyServiceEntity.setLdnUrl((String) ldnUrl);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    /**
+     * Checks whether the ldnurl of notifyServiceEntity has an existing value to replace
+     * @param notifyServiceEntity Object on which patch is being done
+     */
+    private void checkModelForExistingValue(NotifyServiceEntity notifyServiceEntity) {
+        if (notifyServiceEntity.getLdnUrl() == null) {
+            throw new DSpaceBadRequestException("Attempting to replace a non-existent value (ldnurl).");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceLowerIpReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceLowerIpReplaceOperation.java
new file mode 100644
index 0000000000..be605f94d8
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceLowerIpReplaceOperation.java
@@ -0,0 +1,75 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService lowerIp Replace patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "/lowerIp",
+ *  "value": "lowerIp value"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceLowerIpReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/lowerip";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        checkOperationValue(operation.getValue());
+
+        Object lowerIp = operation.getValue();
+        if (lowerIp == null | !(lowerIp instanceof String)) {
+            throw new UnprocessableEntityException("The /lowerIp value must be a string");
+        }
+
+        checkModelForExistingValue(notifyServiceEntity);
+        notifyServiceEntity.setLowerIp((String) lowerIp);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    /**
+     * Checks whether the lowerIp of notifyServiceEntity has an existing value to replace
+     * @param notifyServiceEntity Object on which patch is being done
+     */
+    private void checkModelForExistingValue(NotifyServiceEntity notifyServiceEntity) {
+        if (notifyServiceEntity.getLowerIp() == null) {
+            throw new DSpaceBadRequestException("Attempting to replace a non-existent value (lowerIp).");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceLowerOrUpperRemoveOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceLowerOrUpperRemoveOperation.java
new file mode 100644
index 0000000000..a7425a0027
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceLowerOrUpperRemoveOperation.java
@@ -0,0 +1,47 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService LowerIp Or UpperIp Remove patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "remove",
+ *  "path": "/lowerIp"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceLowerOrUpperRemoveOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        throw new UnprocessableEntityException("/lowerIp or /upperIp are mandatory and can't be removed");
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REMOVE) &&
+            (operation.getPath().trim().toLowerCase().equalsIgnoreCase("/lowerip") ||
+                operation.getPath().trim().toLowerCase().equalsIgnoreCase("/upperip")));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceNameOrLdnUrlRemoveOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceNameOrLdnUrlRemoveOperation.java
new file mode 100644
index 0000000000..e1ff7b83ef
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceNameOrLdnUrlRemoveOperation.java
@@ -0,0 +1,47 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Name Or LdnUrl Remove patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "remove",
+ *  "path": "/name"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceNameOrLdnUrlRemoveOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        throw new UnprocessableEntityException("/name or /ldnurl are mandatory and can't be removed");
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REMOVE) &&
+            (operation.getPath().trim().toLowerCase().equalsIgnoreCase("/name") ||
+                operation.getPath().trim().toLowerCase().equalsIgnoreCase("/ldnurl")));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceNameReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceNameReplaceOperation.java
new file mode 100644
index 0000000000..48db23544f
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceNameReplaceOperation.java
@@ -0,0 +1,75 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Name Replace patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "/name",
+ *  "value": "name value"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceNameReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/name";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        checkOperationValue(operation.getValue());
+
+        Object name = operation.getValue();
+        if (name == null | !(name instanceof String)) {
+            throw new UnprocessableEntityException("The /name value must be a string");
+        }
+
+        checkModelForExistingValue(notifyServiceEntity);
+        notifyServiceEntity.setName((String) name);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    /**
+     * Checks whether the name of notifyServiceEntity has an existing value to replace
+     * @param notifyServiceEntity Object on which patch is being done
+     */
+    private void checkModelForExistingValue(NotifyServiceEntity notifyServiceEntity) {
+        if (notifyServiceEntity.getName() == null) {
+            throw new DSpaceBadRequestException("Attempting to replace a non-existent value (name).");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServicePatchUtils.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServicePatchUtils.java
new file mode 100644
index 0000000000..5735a7bd5f
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServicePatchUtils.java
@@ -0,0 +1,109 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.app.ldn.NotifyServiceInboundPattern;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.model.patch.JsonValueEvaluator;
+import org.dspace.app.rest.model.patch.Operation;
+import org.springframework.stereotype.Component;
+
+/**
+ * Util class for shared methods between the NotifyServiceEntity Operations
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+@Component
+public final class NotifyServicePatchUtils {
+
+    public static final String NOTIFY_SERVICE_INBOUND_PATTERNS = "notifyServiceInboundPatterns";
+
+    private ObjectMapper objectMapper = new ObjectMapper();
+
+    private NotifyServicePatchUtils() {
+    }
+
+    /**
+     * Extract NotifyServiceInboundPattern from Operation by parsing the json
+     * and mapping it to a NotifyServiceInboundPattern
+     *
+     * @param operation     Operation whose value is being parsed
+     * @return NotifyServiceInboundPattern extracted from json in operation value
+     */
+    protected NotifyServiceInboundPattern extractNotifyServiceInboundPatternFromOperation(Operation operation) {
+        NotifyServiceInboundPattern inboundPattern = null;
+        try {
+            if (operation.getValue() != null) {
+                if (operation.getValue() instanceof JsonValueEvaluator) {
+                    inboundPattern = objectMapper.readValue(((JsonValueEvaluator) operation.getValue())
+                            .getValueNode().toString(), NotifyServiceInboundPattern.class);
+                } else if (operation.getValue() instanceof String) {
+                    inboundPattern = objectMapper.readValue((String) operation.getValue(),
+                        NotifyServiceInboundPattern.class);
+                }
+            }
+        } catch (IOException e) {
+            throw new DSpaceBadRequestException("IOException: trying to map json from operation.value" +
+                " to NotifyServiceInboundPattern class.", e);
+        }
+        if (inboundPattern == null) {
+            throw new DSpaceBadRequestException("Could not extract NotifyServiceInboundPattern Object from Operation");
+        }
+        return inboundPattern;
+    }
+
+    /**
+     * Extract list of NotifyServiceInboundPattern from Operation by parsing the json
+     * and mapping it to a list of NotifyServiceInboundPattern
+     *
+     * @param operation     Operation whose value is being parsed
+     * @return list of NotifyServiceInboundPattern extracted from json in operation value
+     */
+    protected List<NotifyServiceInboundPattern> extractNotifyServiceInboundPatternsFromOperation(Operation operation) {
+        List<NotifyServiceInboundPattern> inboundPatterns = null;
+        try {
+            if (operation.getValue() != null) {
+                if (operation.getValue() instanceof String) {
+                    inboundPatterns = objectMapper.readValue((String) operation.getValue(),
+                        objectMapper.getTypeFactory().constructCollectionType(ArrayList.class,
+                            NotifyServiceInboundPattern.class));
+                }
+            }
+        } catch (IOException e) {
+            throw new DSpaceBadRequestException("IOException: trying to map json from operation.value" +
+                " to List of NotifyServiceInboundPattern class.", e);
+        }
+        if (inboundPatterns == null) {
+            throw new DSpaceBadRequestException("Could not extract list of NotifyServiceInboundPattern " +
+                "Objects from Operation");
+        }
+        return inboundPatterns;
+    }
+
+    protected int extractIndexFromOperation(Operation operation) {
+        String number = "";
+        Pattern pattern = Pattern.compile("\\[(\\d+)\\]"); // Pattern to match [i]
+        Matcher matcher = pattern.matcher(operation.getPath());
+        if (matcher.find()) {
+            number = matcher.group(1);
+        }
+
+        if (StringUtils.isEmpty(number)) {
+            throw new DSpaceBadRequestException("path doesn't contain index");
+        }
+
+        return Integer.parseInt(number);
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceScoreAddOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceScoreAddOperation.java
new file mode 100644
index 0000000000..01c5dd3a66
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceScoreAddOperation.java
@@ -0,0 +1,90 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static java.lang.String.format;
+
+import java.math.BigDecimal;
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Score Add patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "add",
+ *  "path": "/score",
+ *  "value": "score value"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceScoreAddOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/score";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        checkNonExistingScoreValue(notifyServiceEntity);
+        checkOperationValue(operation.getValue());
+        Object score = operation.getValue();
+        if (score == null) {
+            throw new DSpaceBadRequestException("The /score value must be a decimal number");
+        }
+
+        BigDecimal scoreBigDecimal = null;
+        try {
+            scoreBigDecimal = new BigDecimal(score.toString());
+        } catch (Exception e) {
+            throw new DSpaceBadRequestException(format("Score out of range [0, 1] %s", score.toString()));
+        }
+        if (scoreBigDecimal.compareTo(java.math.BigDecimal.ZERO) == -1 ||
+            scoreBigDecimal.compareTo(java.math.BigDecimal.ONE) == 1) {
+            throw new UnprocessableEntityException(format("Score out of range [0, 1] %s",
+                scoreBigDecimal.setScale(4).toPlainString()));
+        }
+        notifyServiceEntity.setScore(scoreBigDecimal);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    /**
+     * Throws PatchBadRequestException if a value is already set in the /score path.
+     *
+     * @param notifyServiceEntity the notifyServiceEntity to update
+
+     */
+    void checkNonExistingScoreValue(NotifyServiceEntity notifyServiceEntity) {
+        if (notifyServiceEntity.getScore() != null) {
+            throw new DSpaceBadRequestException("Attempting to add a value to an already existing path.");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_ADD) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceScoreRemoveOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceScoreRemoveOperation.java
new file mode 100644
index 0000000000..e26d888e9f
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceScoreRemoveOperation.java
@@ -0,0 +1,54 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Score Remove patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "remove",
+ *  "path": "/score"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceScoreRemoveOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/score";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        notifyServiceEntity.setScore(null);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REMOVE) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceScoreReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceScoreReplaceOperation.java
new file mode 100644
index 0000000000..95824c7063
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceScoreReplaceOperation.java
@@ -0,0 +1,88 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import static java.lang.String.format;
+
+import java.math.BigDecimal;
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService Score Replace patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "/score",
+ *  "value": "score value"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceScoreReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/score";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        checkOperationValue(operation.getValue());
+
+        Object score = operation.getValue();
+        if (score == null) {
+            throw new DSpaceBadRequestException("The /score value must be a decimal number");
+        }
+        BigDecimal scoreBigDecimal = null;
+        try {
+            scoreBigDecimal = new BigDecimal(score.toString());
+        } catch (Exception e) {
+            throw new DSpaceBadRequestException(format("Score out of range [0, 1] %s", score));
+        }
+        if (scoreBigDecimal.compareTo(java.math.BigDecimal.ZERO) == -1 ||
+            scoreBigDecimal.compareTo(java.math.BigDecimal.ONE) == 1) {
+            throw new UnprocessableEntityException(format("Score out of range [0, 1] %s", score));
+        }
+
+        checkModelForExistingValue(notifyServiceEntity);
+        notifyServiceEntity.setScore(new BigDecimal((String)score));
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    /**
+     * Checks whether the description of notifyServiceEntity has an existing value to replace
+     * @param notifyServiceEntity Object on which patch is being done
+     */
+    private void checkModelForExistingValue(NotifyServiceEntity notifyServiceEntity) {
+        if (notifyServiceEntity.getDescription() == null) {
+            throw new DSpaceBadRequestException("Attempting to replace a non-existent value (description).");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUpperIpReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUpperIpReplaceOperation.java
new file mode 100644
index 0000000000..7ee362cf97
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUpperIpReplaceOperation.java
@@ -0,0 +1,75 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService upperIp Replace patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "/upperIp",
+ *  "value": "upperIp value"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceUpperIpReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/upperip";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        checkOperationValue(operation.getValue());
+
+        Object upperIp = operation.getValue();
+        if (upperIp == null | !(upperIp instanceof String)) {
+            throw new UnprocessableEntityException("The /upperIp value must be a string");
+        }
+
+        checkModelForExistingValue(notifyServiceEntity);
+        notifyServiceEntity.setUpperIp((String) upperIp);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    /**
+     * Checks whether the upperIp of notifyServiceEntity has an existing value to replace
+     * @param notifyServiceEntity Object on which patch is being done
+     */
+    private void checkModelForExistingValue(NotifyServiceEntity notifyServiceEntity) {
+        if (notifyServiceEntity.getUpperIp() == null) {
+            throw new DSpaceBadRequestException("Attempting to replace a non-existent value (upperIp).");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUrlAddOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUrlAddOperation.java
new file mode 100644
index 0000000000..f097407343
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUrlAddOperation.java
@@ -0,0 +1,77 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService URL Add patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "add",
+ *  "path": "/url",
+ *  "value": "url value"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceUrlAddOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/url";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        checkOperationValue(operation.getValue());
+
+        Object url = operation.getValue();
+        if (url == null | !(url instanceof String)) {
+            throw new UnprocessableEntityException("The /url value must be a string");
+        }
+
+        checkNonExistingUrlValue(notifyServiceEntity);
+        notifyServiceEntity.setUrl((String) url);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    /**
+     * Throws PatchBadRequestException if a value is already set in the /url path.
+     *
+     * @param notifyServiceEntity the notifyServiceEntity to update
+
+     */
+    void checkNonExistingUrlValue(NotifyServiceEntity notifyServiceEntity) {
+        if (notifyServiceEntity.getUrl() != null) {
+            throw new DSpaceBadRequestException("Attempting to add a value to an already existing path.");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_ADD) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUrlRemoveOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUrlRemoveOperation.java
new file mode 100644
index 0000000000..c2e6fa05be
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUrlRemoveOperation.java
@@ -0,0 +1,54 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService URL Remove patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "remove",
+ *  "path": "/url"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceUrlRemoveOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/url";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        notifyServiceEntity.setUrl(null);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REMOVE) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUrlReplaceOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUrlReplaceOperation.java
new file mode 100644
index 0000000000..53a315d079
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/repository/patch/operation/ldn/NotifyServiceUrlReplaceOperation.java
@@ -0,0 +1,75 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.repository.patch.operation.ldn;
+
+import java.sql.SQLException;
+
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.repository.patch.operation.PatchOperation;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Implementation for NotifyService URL Replace patches.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/ldn/ldnservices/<:id-notifyService> -H "
+ * Content-Type: application/json" -d '
+ * [{
+ *  "op": "replace",
+ *  "path": "/url",
+ *  "value": "url value"
+ *  }]'
+ * </code>
+ */
+@Component
+public class NotifyServiceUrlReplaceOperation extends PatchOperation<NotifyServiceEntity> {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private static final String OPERATION_PATH = "/url";
+
+    @Override
+    public NotifyServiceEntity perform(Context context, NotifyServiceEntity notifyServiceEntity, Operation operation)
+        throws SQLException {
+        checkOperationValue(operation.getValue());
+
+        Object url = operation.getValue();
+        if (url == null | !(url instanceof String)) {
+            throw new UnprocessableEntityException("The /url value must be a string");
+        }
+
+        checkModelForExistingValue(notifyServiceEntity);
+        notifyServiceEntity.setUrl((String) url);
+        notifyService.update(context, notifyServiceEntity);
+        return notifyServiceEntity;
+    }
+
+    /**
+     * Checks whether the url of notifyServiceEntity has an existing value to replace
+     * @param notifyServiceEntity Object on which patch is being done
+     */
+    private void checkModelForExistingValue(NotifyServiceEntity notifyServiceEntity) {
+        if (notifyServiceEntity.getUrl() == null) {
+            throw new DSpaceBadRequestException("Attempting to replace a non-existent value (url).");
+        }
+    }
+
+    @Override
+    public boolean supports(Object objectToMatch, Operation operation) {
+        return (objectToMatch instanceof NotifyServiceEntity &&
+            operation.getOp().trim().equalsIgnoreCase(OPERATION_REPLACE) &&
+            operation.getPath().trim().toLowerCase().equalsIgnoreCase(OPERATION_PATH));
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/QAEventRestPermissionEvaluatorPlugin.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/QAEventRestPermissionEvaluatorPlugin.java
new file mode 100644
index 0000000000..6e0c0482db
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/QAEventRestPermissionEvaluatorPlugin.java
@@ -0,0 +1,74 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.security;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.rest.model.QAEventRest;
+import org.dspace.app.rest.utils.ContextUtil;
+import org.dspace.content.QAEvent;
+import org.dspace.core.Context;
+import org.dspace.qaevent.service.QAEventSecurityService;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.services.RequestService;
+import org.dspace.services.model.Request;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.security.core.Authentication;
+import org.springframework.stereotype.Component;
+
+/**
+ * This class will handle Permissions for the {@link QAEventRest} object and its calls
+ *
+ * @author Andrea Bollini (4Science)
+ */
+@Component
+public class QAEventRestPermissionEvaluatorPlugin extends RestObjectPermissionEvaluatorPlugin {
+
+    private static final Logger log = LogManager.getLogger();
+
+    @Autowired
+    private QAEventService qaEventService;
+
+    @Autowired
+    private QAEventSecurityService qaEventSecurityService;
+
+    @Autowired
+    private RequestService requestService;
+
+    /**
+     * Responsible for checking whether or not the user has access to the requested QASource
+     *
+     * @param targetType the type of Rest Object that should be checked for permission. This class would deal only with
+     * qaevent
+     * @param targetId string to extract the sourcename from
+     */
+    @Override
+    public boolean hasDSpacePermission(Authentication authentication, Serializable targetId, String targetType,
+            DSpaceRestPermission restPermission) {
+        if (StringUtils.equalsIgnoreCase(QAEventRest.NAME, targetType)) {
+            log.debug("Checking permission for targetId {}", targetId);
+            Request request = requestService.getCurrentRequest();
+            Context context = ContextUtil.obtainContext(request.getHttpServletRequest());
+            if (Objects.isNull(targetId)) {
+                return true;
+            }
+            QAEvent qaEvent = qaEventService.findEventByEventId(targetId.toString());
+            // everyone is expected to be able to see a not existing event (so we can return not found)
+            if ((qaEvent == null
+                    || qaEventSecurityService.canSeeEvent(context, context.getCurrentUser(), qaEvent))) {
+                return true;
+            }
+        }
+        return false;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/QASourceRestPermissionEvaluatorPlugin.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/QASourceRestPermissionEvaluatorPlugin.java
new file mode 100644
index 0000000000..8aca72326e
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/QASourceRestPermissionEvaluatorPlugin.java
@@ -0,0 +1,71 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.security;
+
+import java.io.Serializable;
+import java.util.Objects;
+
+import org.apache.commons.lang3.StringUtils;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+import org.dspace.app.rest.model.QASourceRest;
+import org.dspace.app.rest.model.QATopicRest;
+import org.dspace.app.rest.utils.ContextUtil;
+import org.dspace.core.Context;
+import org.dspace.qaevent.QATopic;
+import org.dspace.qaevent.service.QAEventSecurityService;
+import org.dspace.services.RequestService;
+import org.dspace.services.model.Request;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.security.core.Authentication;
+import org.springframework.stereotype.Component;
+
+/**
+ * This class will handle Permissions for the {@link QASourceRest} object and {@link QATopic}
+ *
+ * @author Andrea Bollini (4Science)
+ */
+@Component
+public class QASourceRestPermissionEvaluatorPlugin extends RestObjectPermissionEvaluatorPlugin {
+
+    private static final Logger log = LogManager.getLogger();
+
+    @Autowired
+    private QAEventSecurityService qaEventSecurityService;
+
+    @Autowired
+    private RequestService requestService;
+
+    /**
+     * Responsible for checking whether or not the user has access to the requested QASource
+     *
+     * @param targetType the type of Rest Object that should be checked for permission. This class would deal only with
+     * qasource and qatopic
+     * @param targetId string to extract the sourcename from
+     */
+    @Override
+    public boolean hasDSpacePermission(Authentication authentication, Serializable targetId, String targetType,
+                                       DSpaceRestPermission restPermission) {
+        if (StringUtils.equalsIgnoreCase(QASourceRest.NAME, targetType)
+                || StringUtils.equalsIgnoreCase(QATopicRest.NAME, targetType)) {
+            log.debug("Checking permission for targetId {}", targetId);
+            Request request = requestService.getCurrentRequest();
+            Context context = ContextUtil.obtainContext(request.getHttpServletRequest());
+            if (Objects.isNull(targetId)) {
+                return true;
+            }
+            // the source name is always the first part of the id both for a source than a topic
+            // users can see all the topic in source that they can access, eventually they will have no
+            // events visible to them
+            String sourceName = targetId.toString().split(":")[0];
+            return qaEventSecurityService.canSeeSource(context, context.getCurrentUser(), sourceName);
+        }
+        return false;
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/SuggestionRestPermissionEvaluatorPlugin.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/SuggestionRestPermissionEvaluatorPlugin.java
new file mode 100644
index 0000000000..b56c0cf896
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/SuggestionRestPermissionEvaluatorPlugin.java
@@ -0,0 +1,95 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.security;
+
+import static org.dspace.app.rest.security.DSpaceRestPermission.DELETE;
+import static org.dspace.app.rest.security.DSpaceRestPermission.READ;
+import static org.dspace.app.rest.security.DSpaceRestPermission.WRITE;
+
+import java.io.Serializable;
+import java.util.List;
+import java.util.UUID;
+
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.app.rest.model.SuggestionRest;
+import org.dspace.app.rest.utils.ContextUtil;
+import org.dspace.content.Item;
+import org.dspace.content.MetadataValue;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+import org.dspace.util.UUIDUtils;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.security.core.Authentication;
+import org.springframework.stereotype.Component;
+
+/**
+ *
+ * An authenticated user is allowed to view a suggestion
+ * related to a Target object that he owns (as defined by "dspace.object.owner" metadata field)
+ * See {@link RestPermissionEvaluatorPlugin} for the inherited contract.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@Component
+public class SuggestionRestPermissionEvaluatorPlugin extends RestObjectPermissionEvaluatorPlugin {
+
+    @Autowired
+    private ItemService itemService;
+
+    @Override
+    public boolean hasDSpacePermission(Authentication authentication, Serializable targetId, String targetType,
+            DSpaceRestPermission restPermission) {
+
+        if (!READ.equals(restPermission) && !WRITE.equals(restPermission) && !DELETE.equals(restPermission)) {
+            return false;
+        }
+
+        if (!StringUtils.equalsIgnoreCase(targetType, SuggestionRest.NAME)
+                && !StringUtils.startsWithIgnoreCase(targetType, SuggestionRest.NAME)) {
+            return false;
+        }
+
+        Context context = ContextUtil.obtainCurrentRequestContext();
+
+        EPerson currentUser = context.getCurrentUser();
+        if (currentUser == null) {
+            return false;
+        }
+
+        try {
+            String id = targetId.toString();
+            UUID uuid = null;
+            if (id.contains(":")) {
+                uuid = UUIDUtils.fromString(id.split(":", 3)[1]);
+            } else {
+                uuid = UUIDUtils.fromString(id);
+            }
+            if (uuid == null) {
+                return false;
+            }
+            Item item = itemService.find(context, uuid);
+            if (item != null) {
+                List<MetadataValue> mvalues = itemService.getMetadataByMetadataString(item, "dspace.object.owner");
+                if (mvalues != null) {
+                    for (MetadataValue mv : mvalues) {
+                        if (StringUtils.equals(mv.getAuthority(), currentUser.getID().toString())) {
+                            return true;
+                        }
+                    }
+                }
+            }
+        } catch (Exception ex) {
+            return false;
+        }
+
+        return false;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/SuggestionTargetRestPermissionEvaluatorPlugin.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/SuggestionTargetRestPermissionEvaluatorPlugin.java
new file mode 100644
index 0000000000..3aa4a9fcf4
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/security/SuggestionTargetRestPermissionEvaluatorPlugin.java
@@ -0,0 +1,96 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.security;
+
+import static org.dspace.app.rest.security.DSpaceRestPermission.DELETE;
+import static org.dspace.app.rest.security.DSpaceRestPermission.READ;
+import static org.dspace.app.rest.security.DSpaceRestPermission.WRITE;
+
+import java.io.Serializable;
+import java.util.List;
+import java.util.UUID;
+
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.app.rest.model.SuggestionTargetRest;
+import org.dspace.app.rest.utils.ContextUtil;
+import org.dspace.content.Item;
+import org.dspace.content.MetadataValue;
+import org.dspace.content.service.ItemService;
+import org.dspace.core.Context;
+import org.dspace.eperson.EPerson;
+import org.dspace.util.UUIDUtils;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.security.core.Authentication;
+import org.springframework.stereotype.Component;
+
+/**
+ *
+ * An authenticated user is allowed to view a suggestion summary
+ * (SuggestionTarget) related to a Target object that they own
+ * (as defined by "dspace.object.owner" metadata field)
+ * See {@link RestPermissionEvaluatorPlugin} for the inherited contract.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+@Component
+public class SuggestionTargetRestPermissionEvaluatorPlugin extends RestObjectPermissionEvaluatorPlugin {
+
+    @Autowired
+    private ItemService itemService;
+
+    @Override
+    public boolean hasDSpacePermission(Authentication authentication, Serializable targetId, String targetType,
+            DSpaceRestPermission restPermission) {
+
+        if (!READ.equals(restPermission) && !WRITE.equals(restPermission) && !DELETE.equals(restPermission)) {
+            return false;
+        }
+
+        if (!StringUtils.equalsIgnoreCase(targetType, SuggestionTargetRest.NAME)
+                && !StringUtils.startsWithIgnoreCase(targetType, SuggestionTargetRest.NAME)) {
+            return false;
+        }
+
+        Context context = ContextUtil.obtainCurrentRequestContext();
+
+        EPerson currentUser = context.getCurrentUser();
+        if (currentUser == null) {
+            return false;
+        }
+
+        try {
+            String id = targetId.toString();
+            UUID uuid = null;
+            if (id.contains(":")) {
+                uuid = UUIDUtils.fromString(id.split(":", 2)[1]);
+            } else {
+                uuid = UUIDUtils.fromString(id);
+            }
+            if (uuid == null) {
+                return false;
+            }
+            Item item = itemService.find(context, uuid);
+            if (item != null) {
+                List<MetadataValue> mvalues = itemService.getMetadataByMetadataString(item, "dspace.object.owner");
+                if (mvalues != null) {
+                    for (MetadataValue mv : mvalues) {
+                        if (StringUtils.equals(mv.getAuthority(), currentUser.getID().toString())) {
+                            return true;
+                        }
+                    }
+                }
+            }
+        } catch (Exception ex) {
+            return false;
+        }
+
+        return false;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/AbstractProcessingStep.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/AbstractProcessingStep.java
index 8c03f4ef82..bb8c7825e2 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/AbstractProcessingStep.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/AbstractProcessingStep.java
@@ -7,6 +7,7 @@
  */
 package org.dspace.app.rest.submit;
 
+import org.dspace.app.rest.submit.factory.impl.NotifySubmissionService;
 import org.dspace.authorize.factory.AuthorizeServiceFactory;
 import org.dspace.authorize.service.AuthorizeService;
 import org.dspace.content.factory.ContentServiceFactory;
@@ -19,6 +20,7 @@ import org.dspace.content.service.MetadataFieldService;
 import org.dspace.content.service.WorkspaceItemService;
 import org.dspace.services.ConfigurationService;
 import org.dspace.services.factory.DSpaceServicesFactory;
+import org.dspace.utils.DSpace;
 
 /**
  * Abstract processing class for DSpace Submission Steps. This retrieve several
@@ -35,4 +37,6 @@ public abstract class AbstractProcessingStep implements DataProcessingStep {
     protected MetadataFieldService metadataFieldService = ContentServiceFactory.getInstance().getMetadataFieldService();
     protected ConfigurationService configurationService = DSpaceServicesFactory.getInstance().getConfigurationService();
     protected WorkspaceItemService workspaceItemService = ContentServiceFactory.getInstance().getWorkspaceItemService();
+    protected NotifySubmissionService coarNotifySubmissionService = new DSpace().getServiceManager()
+        .getServiceByName("coarNotifySubmissionService", NotifySubmissionService.class);
 }
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/DataProcessingStep.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/DataProcessingStep.java
index 99af309cdb..fc2a8ea0ad 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/DataProcessingStep.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/DataProcessingStep.java
@@ -41,6 +41,7 @@ public interface DataProcessingStep extends RestProcessingStep {
     public static final String SHOW_IDENTIFIERS_ENTRY = "identifiers";
 
     public static final String UPLOAD_STEP_METADATA_PATH = "metadata";
+    public static final String COARNOTIFY_STEP_PATH = "coarnotify";
 
     /**
      * Method to expose data in the a dedicated section of the in progress submission. The step needs to return a
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifyServiceAddPatchOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifyServiceAddPatchOperation.java
new file mode 100644
index 0000000000..94f5e94d9b
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifyServiceAddPatchOperation.java
@@ -0,0 +1,107 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.submit.factory.impl;
+
+import java.sql.SQLException;
+import java.util.LinkedHashSet;
+import java.util.List;
+import java.util.Set;
+import java.util.stream.Collectors;
+import javax.servlet.http.HttpServletRequest;
+
+import org.dspace.app.ldn.NotifyPatternToTrigger;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyPatternToTriggerService;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.patch.LateObjectEvaluator;
+import org.dspace.content.InProgressSubmission;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+import org.dspace.utils.DSpace;
+import org.springframework.beans.factory.annotation.Autowired;
+
+
+/**
+ * Submission "add" PATCH operation
+ *
+ * To add the COAR Notify Service of workspace item.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/submission/workspaceitems/31599 -H "Content-Type:
+ * application/json" -d '[{ "op": "add", "path": "/sections/coarnotify/review/-"}, "value": ["1","2"]'
+ * </code>
+ */
+public class NotifyServiceAddPatchOperation extends AddPatchOperation<Integer> {
+
+    @Autowired
+    private NotifyPatternToTriggerService notifyPatternToTriggerService;
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private NotifySubmissionService coarNotifySubmissionService = new DSpace().getServiceManager()
+        .getServiceByName("coarNotifySubmissionService", NotifySubmissionService.class);
+
+    @Override
+    protected Class<Integer[]> getArrayClassForEvaluation() {
+        return Integer[].class;
+    }
+
+    @Override
+    protected Class<Integer> getClassForEvaluation() {
+        return Integer.class;
+    }
+
+    @Override
+    void add(Context context, HttpServletRequest currentRequest, InProgressSubmission source, String path,
+            Object value) throws Exception {
+
+        String pattern = coarNotifySubmissionService.extractPattern(path);
+        Set<Integer> servicesIds = new LinkedHashSet<>(evaluateArrayObject((LateObjectEvaluator) value));
+
+        coarNotifySubmissionService.checkCompatibilityWithPattern(context, pattern, servicesIds);
+
+        List<NotifyServiceEntity> services =
+            servicesIds.stream()
+                       .map(id ->
+                           findService(context, id))
+                       .collect(Collectors.toList());
+        if (services.isEmpty()) {
+            createNotifyPattern(context, source.getItem(), null, pattern);
+        } else {
+            services.forEach(service ->
+                createNotifyPattern(context, source.getItem(), service, pattern));
+        }
+    }
+
+    private NotifyServiceEntity findService(Context context, int serviceId) {
+        try {
+            NotifyServiceEntity service = notifyService.find(context, serviceId);
+            if (service == null) {
+                throw new UnprocessableEntityException("no service found for the provided value: " + serviceId + "");
+            }
+            return service;
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    private void createNotifyPattern(Context context, Item item, NotifyServiceEntity service, String pattern) {
+        try {
+            NotifyPatternToTrigger notifyPatternToTrigger = notifyPatternToTriggerService.create(context);
+            notifyPatternToTrigger.setItem(item);
+            notifyPatternToTrigger.setNotifyService(service);
+            notifyPatternToTrigger.setPattern(pattern);
+            notifyPatternToTriggerService.update(context, notifyPatternToTrigger);
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifyServiceRemovePatchOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifyServiceRemovePatchOperation.java
new file mode 100644
index 0000000000..c1304f0b91
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifyServiceRemovePatchOperation.java
@@ -0,0 +1,70 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.submit.factory.impl;
+
+import java.util.List;
+import javax.servlet.http.HttpServletRequest;
+
+import org.dspace.app.ldn.NotifyPatternToTrigger;
+import org.dspace.app.ldn.service.NotifyPatternToTriggerService;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.content.InProgressSubmission;
+import org.dspace.content.Item;
+import org.dspace.core.Context;
+import org.dspace.utils.DSpace;
+import org.springframework.beans.factory.annotation.Autowired;
+
+
+/**
+ * Submission "remove" PATCH operation
+ *
+ * To remove the COAR Notify Service of workspace item.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/submission/workspaceitems/31599 -H "Content-Type:
+ * application/json" -d '[{ "op": "remove", "path": "/sections/coarnotify/review/0"}]'
+ * </code>
+ */
+public class NotifyServiceRemovePatchOperation extends RemovePatchOperation<Integer> {
+
+    @Autowired
+    private NotifyPatternToTriggerService notifyPatternToTriggerService;
+
+    private NotifySubmissionService coarNotifySubmissionService = new DSpace().getServiceManager()
+        .getServiceByName("coarNotifySubmissionService", NotifySubmissionService.class);
+
+    @Override
+    protected Class<Integer[]> getArrayClassForEvaluation() {
+        return Integer[].class;
+    }
+
+    @Override
+    protected Class<Integer> getClassForEvaluation() {
+        return Integer.class;
+    }
+
+    @Override
+    void remove(Context context, HttpServletRequest currentRequest, InProgressSubmission source, String path,
+            Object value) throws Exception {
+
+        Item item = source.getItem();
+
+        String pattern = coarNotifySubmissionService.extractPattern(path);
+        int index = coarNotifySubmissionService.extractIndex(path);
+
+        List<NotifyPatternToTrigger> notifyPatterns =
+            notifyPatternToTriggerService.findByItemAndPattern(context, item, pattern);
+
+        if (index >= notifyPatterns.size()) {
+            throw new UnprocessableEntityException("the provided index[" + index + "] is out of the rang");
+        }
+
+        notifyPatternToTriggerService.delete(context, notifyPatterns.get(index));
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifyServiceReplacePatchOperation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifyServiceReplacePatchOperation.java
new file mode 100644
index 0000000000..d7988da002
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifyServiceReplacePatchOperation.java
@@ -0,0 +1,84 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.submit.factory.impl;
+
+import java.util.List;
+import java.util.Set;
+import javax.servlet.http.HttpServletRequest;
+
+import org.dspace.app.ldn.NotifyPatternToTrigger;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyPatternToTriggerService;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.DSpaceBadRequestException;
+import org.dspace.content.InProgressSubmission;
+import org.dspace.core.Context;
+import org.dspace.utils.DSpace;
+import org.springframework.beans.factory.annotation.Autowired;
+
+
+/**
+ * Submission "replace" PATCH operation
+ *
+ * To replace the COAR Notify Service of workspace item.
+ *
+ * Example: <code>
+ * curl -X PATCH http://${dspace.server.url}/api/submission/workspaceitems/31599 -H "Content-Type:
+ * application/json" -d '[{ "op": "replace", "path": "/sections/coarnotify/review/0"}, "value": "10"]'
+ * </code>
+ */
+public class NotifyServiceReplacePatchOperation extends ReplacePatchOperation<Integer> {
+
+    @Autowired
+    private NotifyPatternToTriggerService notifyPatternToTriggerService;
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private NotifySubmissionService coarNotifySubmissionService = new DSpace().getServiceManager()
+        .getServiceByName("coarNotifySubmissionService", NotifySubmissionService.class);
+
+    @Override
+    protected Class<Integer[]> getArrayClassForEvaluation() {
+        return Integer[].class;
+    }
+
+    @Override
+    protected Class<Integer> getClassForEvaluation() {
+        return Integer.class;
+    }
+
+    @Override
+    void replace(Context context, HttpServletRequest currentRequest, InProgressSubmission source, String path,
+            Object value) throws Exception {
+
+        int index = coarNotifySubmissionService.extractIndex(path);
+        String pattern = coarNotifySubmissionService.extractPattern(path);
+
+        List<NotifyPatternToTrigger> notifyPatterns =
+            notifyPatternToTriggerService.findByItemAndPattern(context, source.getItem(), pattern);
+
+        if (index >= notifyPatterns.size()) {
+            throw new DSpaceBadRequestException("the provided index[" + index + "] is out of the rang");
+        }
+
+        NotifyServiceEntity notifyServiceEntity = notifyService.find(context, Integer.parseInt(value.toString()));
+        if (notifyServiceEntity == null) {
+            throw new DSpaceBadRequestException("no service found for the provided value: " + value + "");
+        }
+
+        coarNotifySubmissionService.checkCompatibilityWithPattern(context,
+            pattern, Set.of(notifyServiceEntity.getID()));
+
+        NotifyPatternToTrigger notifyPatternToTriggerOld = notifyPatterns.get(index);
+        notifyPatternToTriggerOld.setNotifyService(notifyServiceEntity);
+
+        notifyPatternToTriggerService.update(context, notifyPatternToTriggerOld);
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifySubmissionService.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifySubmissionService.java
new file mode 100644
index 0000000000..7cebc33416
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/factory/impl/NotifySubmissionService.java
@@ -0,0 +1,152 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.submit.factory.impl;
+
+import java.io.IOException;
+import java.sql.SQLException;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+import java.util.stream.Collectors;
+
+import org.apache.commons.collections4.CollectionUtils;
+import org.dspace.app.ldn.NotifyPatternToTrigger;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyPatternToTriggerService;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.exception.UnprocessableEntityException;
+import org.dspace.app.rest.model.step.DataNotify;
+import org.dspace.authorize.AuthorizeException;
+import org.dspace.coarnotify.NotifyConfigurationService;
+import org.dspace.coarnotify.NotifyPattern;
+import org.dspace.content.InProgressSubmission;
+import org.dspace.core.Context;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.stereotype.Component;
+
+/**
+ * Service to manipulate COAR Notify section of in-progress submissions.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com
+ */
+@Component
+public class NotifySubmissionService {
+
+    @Autowired
+    private NotifyPatternToTriggerService notifyPatternToTriggerService;
+
+    @Autowired
+    private NotifyConfigurationService coarNotifyConfigurationService;
+
+    @Autowired
+    private NotifyService notifyService;
+
+    private NotifySubmissionService() { }
+
+
+    /**
+     * Builds the COAR Notify data of an in-progress submission
+     *
+     * @param obj   - the in progress submission
+     * @return an object representing the CC License data
+     * @throws SQLException
+     * @throws IOException
+     * @throws AuthorizeException
+     */
+    public DataNotify getDataCOARNotify(InProgressSubmission obj) throws SQLException {
+        Context context = new Context();
+
+        List<NotifyPatternToTrigger> patternsToTrigger =
+            notifyPatternToTriggerService.findByItem(context, obj.getItem());
+
+        Map<String, List<Integer>> data =
+            patternsToTrigger.stream()
+                             .collect(Collectors.groupingBy(
+                                 NotifyPatternToTrigger::getPattern,
+                                 Collectors.mapping(patternToTrigger ->
+                                         patternToTrigger.getNotifyService().getID(),
+                                     Collectors.toList())
+                             ));
+
+        return new DataNotify(data);
+    }
+
+
+    public int extractIndex(String path) {
+        Pattern pattern = Pattern.compile("/(\\d+)$");
+        Matcher matcher = pattern.matcher(path);
+
+        if (matcher.find()) {
+            return Integer.parseInt(matcher.group(1));
+        } else {
+            throw new UnprocessableEntityException("Index not found in the path");
+        }
+    }
+
+    /**
+     * extract pattern from path. see COARNotifyConfigurationService bean
+     * @param path
+     * @return the extracted pattern
+     */
+    public String extractPattern(String path) {
+        Pattern pattern = Pattern.compile("/([^/]+)/([^/]+)/([^/]+)");
+        Matcher matcher = pattern.matcher(path);
+        if (matcher.find()) {
+            String patternValue = matcher.group(3);
+            String config = matcher.group(2);
+            if (!isContainPattern(config, patternValue)) {
+                throw new UnprocessableEntityException(
+                    "Invalid Pattern (" + patternValue + ") of " + config);
+            }
+            return patternValue;
+        } else {
+            throw new UnprocessableEntityException("Pattern not found in the path");
+        }
+    }
+
+    private boolean isContainPattern(String config, String pattern) {
+        List<NotifyPattern> patterns = coarNotifyConfigurationService.getPatterns().get(config);
+        if (CollectionUtils.isEmpty(patterns)) {
+            return false;
+        }
+
+        return patterns.stream()
+                       .map(NotifyPattern::getPattern)
+                       .anyMatch(v ->
+                           v.equals(pattern));
+    }
+
+    /**
+     * check that the provided services ids are compatible
+     * with the provided inbound pattern
+     *
+     * @param context the context
+     * @param pattern the inbound pattern
+     * @param servicesIds notify services ids
+     * @throws SQLException if something goes wrong
+     */
+    public void checkCompatibilityWithPattern(Context context, String pattern, Set<Integer> servicesIds)
+        throws SQLException {
+
+        List<Integer> manualServicesIds =
+            notifyService.findManualServicesByInboundPattern(context, pattern)
+                         .stream()
+                         .map(NotifyServiceEntity::getID)
+                         .collect(Collectors.toList());
+
+        for (Integer servicesId : servicesIds) {
+            if (!manualServicesIds.contains(servicesId)) {
+                throw new UnprocessableEntityException("notify service with id (" + servicesId +
+                    ") is not compatible with pattern " + pattern);
+            }
+        }
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/step/NotifyStep.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/step/NotifyStep.java
new file mode 100644
index 0000000000..b3e3d06c47
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/step/NotifyStep.java
@@ -0,0 +1,62 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.submit.step;
+
+import javax.servlet.http.HttpServletRequest;
+
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.model.step.DataNotify;
+import org.dspace.app.rest.submit.AbstractProcessingStep;
+import org.dspace.app.rest.submit.SubmissionService;
+import org.dspace.app.rest.submit.factory.PatchOperationFactory;
+import org.dspace.app.rest.submit.factory.impl.PatchOperation;
+import org.dspace.app.util.SubmissionStepConfig;
+import org.dspace.content.InProgressSubmission;
+import org.dspace.core.Context;
+
+/**
+ * COARNotify Step for DSpace Spring Rest. Expose information about
+ * the COAR Notify services for the in progress submission.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyStep extends AbstractProcessingStep {
+
+    /**
+     * Retrieves the COAR Notify services data of the in progress submission
+     *
+     * @param submissionService the submission service
+     * @param obj               the in progress submission
+     * @param config            the submission step configuration
+     * @return the COAR Notify data of the in progress submission
+     * @throws Exception
+     */
+    @Override
+    public DataNotify getData(SubmissionService submissionService, InProgressSubmission obj,
+                                             SubmissionStepConfig config) throws Exception {
+        return coarNotifySubmissionService.getDataCOARNotify(obj);
+    }
+
+    /**
+     * Processes a patch for the COAR Notify data
+     *
+     * @param context        the DSpace context
+     * @param currentRequest the http request
+     * @param source         the in progress submission
+     * @param op             the json patch operation
+     * @throws Exception
+     */
+    @Override
+    public void doPatchProcessing(Context context, HttpServletRequest currentRequest, InProgressSubmission source,
+            Operation op, SubmissionStepConfig stepConf) throws Exception {
+
+        PatchOperation<?> patchOperation = new PatchOperationFactory().instanceOf(
+            COARNOTIFY_STEP_PATH, op.getOp());
+        patchOperation.perform(context, currentRequest, source, op);
+    }
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/step/validation/NotifyValidation.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/step/validation/NotifyValidation.java
new file mode 100644
index 0000000000..04a1567fda
--- /dev/null
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/submit/step/validation/NotifyValidation.java
@@ -0,0 +1,117 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.submit.step.validation;
+
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.IntStream;
+
+import org.dspace.app.ldn.NotifyPatternToTrigger;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyPatternToTriggerService;
+import org.dspace.app.rest.model.ErrorRest;
+import org.dspace.app.rest.repository.WorkspaceItemRestRepository;
+import org.dspace.app.rest.submit.SubmissionService;
+import org.dspace.app.rest.utils.ContextUtil;
+import org.dspace.app.util.DCInputsReaderException;
+import org.dspace.app.util.SubmissionStepConfig;
+import org.dspace.coarnotify.NotifyConfigurationService;
+import org.dspace.coarnotify.NotifyPattern;
+import org.dspace.content.InProgressSubmission;
+import org.dspace.content.Item;
+import org.dspace.content.logic.LogicalStatement;
+import org.dspace.core.Context;
+import org.dspace.utils.DSpace;
+
+/**
+ * Execute check validation of Coar notify services filters
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyValidation extends AbstractValidation {
+
+    private static final String ERROR_VALIDATION_INVALID_FILTER = "error.validation.coarnotify.invalidfilter";
+
+    private NotifyConfigurationService coarNotifyConfigurationService;
+
+    private NotifyPatternToTriggerService notifyPatternToTriggerService;
+
+    @Override
+    public List<ErrorRest> validate(SubmissionService submissionService, InProgressSubmission obj,
+                                    SubmissionStepConfig config) throws DCInputsReaderException, SQLException {
+
+        List<ErrorRest> errors = new ArrayList<>();
+        Context context = ContextUtil.obtainCurrentRequestContext();
+        Item item = obj.getItem();
+
+        List<String> patterns =
+            coarNotifyConfigurationService.getPatterns().getOrDefault(config.getId(), List.of())
+                                          .stream()
+                                          .map(NotifyPattern::getPattern)
+                                          .collect(Collectors.toList());
+
+        patterns.forEach(pattern -> {
+            List<NotifyServiceEntity> services = findByItemAndPattern(context, item, pattern);
+            IntStream.range(0, services.size()).forEach(i ->
+                services.get(i)
+                        .getInboundPatterns()
+                        .stream()
+                        .filter(inboundPattern -> inboundPattern.getPattern().equals(pattern))
+                        .filter(inboundPattern -> !inboundPattern.isAutomatic() &&
+                            !inboundPattern.getConstraint().isEmpty())
+                        .forEach(inboundPattern -> {
+                            LogicalStatement filter =
+                                new DSpace().getServiceManager()
+                                            .getServiceByName(inboundPattern.getConstraint(), LogicalStatement.class);
+
+                            if (filter == null || !filter.getResult(context, item)) {
+                                addError(errors, ERROR_VALIDATION_INVALID_FILTER,
+                                    "/" + WorkspaceItemRestRepository.OPERATION_PATH_SECTIONS +
+                                        "/" + config.getId() +
+                                        "/" + inboundPattern.getPattern() +
+                                        "/" + i
+                                );
+                            }
+                        }));
+        });
+
+        return errors;
+    }
+
+    private List<NotifyServiceEntity> findByItemAndPattern(Context context, Item item, String pattern) {
+        try {
+            return notifyPatternToTriggerService.findByItemAndPattern(context, item, pattern)
+                                                .stream()
+                                                .map(NotifyPatternToTrigger::getNotifyService)
+                                                .collect(Collectors.toList());
+        } catch (SQLException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    public NotifyConfigurationService getCoarNotifyConfigurationService() {
+        return coarNotifyConfigurationService;
+    }
+
+    public void setCoarNotifyConfigurationService(
+        NotifyConfigurationService coarNotifyConfigurationService) {
+        this.coarNotifyConfigurationService = coarNotifyConfigurationService;
+    }
+
+    public NotifyPatternToTriggerService getNotifyPatternToTriggerService() {
+        return notifyPatternToTriggerService;
+    }
+
+    public void setNotifyPatternToTriggerService(
+        NotifyPatternToTriggerService notifyPatternToTriggerService) {
+        this.notifyPatternToTriggerService = notifyPatternToTriggerService;
+    }
+
+}
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/utils/ApplicationConfig.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/utils/ApplicationConfig.java
index 48538deb13..ba43fdf956 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/utils/ApplicationConfig.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/utils/ApplicationConfig.java
@@ -34,7 +34,8 @@ import org.springframework.context.annotation.Configuration;
     "org.dspace.app.rest.utils",
     "org.dspace.app.configuration",
     "org.dspace.iiif",
-    "org.dspace.app.iiif"
+    "org.dspace.app.iiif",
+    "org.dspace.app.ldn"
 })
 public class ApplicationConfig {
     // Allowed CORS origins ("Access-Control-Allow-Origin" header)
@@ -71,6 +72,10 @@ public class ApplicationConfig {
     @Value("${dspace.ui.url:http://localhost:4000}")
     private String uiURL;
 
+    // LDN enable status
+    @Value("${ldn.enabled}")
+    private boolean ldnEnabled;
+
     /**
      * Return the array of allowed origins (client URLs) for the CORS "Access-Control-Allow-Origin" header
      * Used by Application class
@@ -129,6 +134,14 @@ public class ApplicationConfig {
         return corsAllowCredentials;
     }
 
+    /**
+     * Return the ldn.enabled value
+     * @return true or false
+     */
+    public boolean getLdnEnabled() {
+        return this.ldnEnabled;
+    }
+
     /**
      * Return whether to allow credentials (cookies) on IIIF requests. This is used to set the
      * CORS "Access-Control-Allow-Credentials" header in Application class. Defaults to false.
diff --git a/dspace-server-webapp/src/main/java/org/dspace/app/rest/utils/RegexUtils.java b/dspace-server-webapp/src/main/java/org/dspace/app/rest/utils/RegexUtils.java
index 8739f6b8d5..7b6e55ec01 100644
--- a/dspace-server-webapp/src/main/java/org/dspace/app/rest/utils/RegexUtils.java
+++ b/dspace-server-webapp/src/main/java/org/dspace/app/rest/utils/RegexUtils.java
@@ -19,21 +19,27 @@ public class RegexUtils {
      * Regular expression in the request mapping to accept UUID as identifier
      */
     public static final String REGEX_UUID =
-        "[0-9a-fxA-FX]{8}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{12}";
+            "[0-9a-fxA-FX]{8}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{12}";
 
     /**
      * Regular expression in the request mapping to accept UUID as identifier
      */
     public static final String REGEX_REQUESTMAPPING_IDENTIFIER_AS_UUID =
-        "/{uuid:" + REGEX_UUID + "}";
+            "/{uuid:" + REGEX_UUID + "}";
+
+    /**
+     * Regular expression in the request mapping to accept LDN identifiers
+     */
+    public static final String REGEX_REQUESTMAPPING_IDENTIFIER_AS_URN_UUID =
+            "/{id:^urn:uuid:" + REGEX_UUID + "}";
 
     /**
      * Regular expression in the request mapping to accept a string as identifier but not the other kind of
      * identifier (digits or uuid)
      */
     public static final String REGEX_REQUESTMAPPING_IDENTIFIER_AS_STRING_VERSION_STRONG = "/{id:^(?!^\\d+$)" +
-        "(?!^[0-9a-fxA-FX]{8}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{12}$)"
-        + "[\\w+\\-\\.:]+$+}";
+            "(?!^[0-9a-fxA-FX]{8}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{4}-[0-9a-fxA-FX]{12}$)"
+            + "[\\w+\\-\\.:!]+$+}";
 
     /**
      * Regular expression in the request mapping to accept number as identifier
diff --git a/dspace-server-webapp/src/main/resources/spring/spring-dspace-addon-validation-services.xml b/dspace-server-webapp/src/main/resources/spring/spring-dspace-addon-validation-services.xml
index f39d553c96..013b406c1a 100644
--- a/dspace-server-webapp/src/main/resources/spring/spring-dspace-addon-validation-services.xml
+++ b/dspace-server-webapp/src/main/resources/spring/spring-dspace-addon-validation-services.xml
@@ -30,4 +30,11 @@
     <bean name="licenseValidation" class="org.dspace.app.rest.submit.step.validation.LicenseValidation">
         <property name="name" value="license"/>
     </bean>
+
+    <bean name="COARNotifyValidation" class="org.dspace.app.rest.submit.step.validation.NotifyValidation" scope="prototype">
+        <property name="name" value="coarnotify"/>
+        <property name="coarNotifyConfigurationService" ref="org.dspace.coarnotify.NotifyConfigurationService"/>
+        <property name="notifyPatternToTriggerService" ref="org.dspace.app.ldn.service.impl.NotifyPatternToTriggerImpl"/>
+    </bean>
+
 </beans>
diff --git a/dspace-server-webapp/src/main/resources/spring/spring-dspace-core-services.xml b/dspace-server-webapp/src/main/resources/spring/spring-dspace-core-services.xml
index bb56393d0b..80c9942b06 100644
--- a/dspace-server-webapp/src/main/resources/spring/spring-dspace-core-services.xml
+++ b/dspace-server-webapp/src/main/resources/spring/spring-dspace-core-services.xml
@@ -63,6 +63,9 @@
                         <entry key="accessConditions">
                             <bean class="org.dspace.app.rest.submit.factory.impl.AccessConditionAddPatchOperation"/>
                         </entry>
+                        <entry key="coarnotify">
+                            <bean class="org.dspace.app.rest.submit.factory.impl.NotifyServiceAddPatchOperation"/>
+                        </entry>
                     </map>
                 </entry>
                 <entry key="remove">
@@ -97,6 +100,9 @@
                         <entry key="accessConditions">
                             <bean class="org.dspace.app.rest.submit.factory.impl.AccessConditionRemovePatchOperation"/>
                         </entry>
+                        <entry key="coarnotify">
+                            <bean class="org.dspace.app.rest.submit.factory.impl.NotifyServiceRemovePatchOperation"/>
+                        </entry>
                     </map>
                 </entry>
                 <entry key="replace">
@@ -130,6 +136,9 @@
                         <entry key="accessConditions">
                             <bean class="org.dspace.app.rest.submit.factory.impl.AccessConditionReplacePatchOperation"/>
                         </entry>
+                        <entry key="coarnotify">
+                            <bean class="org.dspace.app.rest.submit.factory.impl.NotifyServiceReplacePatchOperation"/>
+                        </entry>
                     </map>
                 </entry>
             </map>
@@ -137,4 +146,7 @@
     </bean>
 
     <bean id="org.dspace.app.rest.utils.BitstreamMetadataValuePathUtils" class="org.dspace.app.rest.utils.BitstreamMetadataValuePathUtils"/>
+
+    <bean id="coarNotifySubmissionService" class="org.dspace.app.rest.submit.factory.impl.NotifySubmissionService"/>
+
 </beans>
diff --git a/dspace-server-webapp/src/test/data/dspaceFolder/config/item-submission.xml b/dspace-server-webapp/src/test/data/dspaceFolder/config/item-submission.xml
index eca9acf79f..e42b7386ab 100644
--- a/dspace-server-webapp/src/test/data/dspaceFolder/config/item-submission.xml
+++ b/dspace-server-webapp/src/test/data/dspaceFolder/config/item-submission.xml
@@ -135,28 +135,28 @@
             <heading>fake.workflow.readonly</heading> <processing-class>org.dspace.submit.step.SampleStep</processing-class> 
             <type>sample</type> <scope visibility="read-only">workflow</scope> </step-definition> -->
 
-        <!-- OpenAIRE submission steps/forms -->
-        <step-definition id="openAIREProjectForm" mandatory="true">
+        <!-- Openaire submission steps/forms -->
+        <step-definition id="openaireProjectForm" mandatory="true">
             <heading>submit.progressbar.describe.stepone</heading>
             <processing-class>org.dspace.app.rest.submit.step.DescribeStep</processing-class>
             <type>submission-form</type>
         </step-definition>
-        <step-definition id="openAIREPersonForm" mandatory="true">
+        <step-definition id="openairePersonForm" mandatory="true">
             <heading>submit.progressbar.describe.stepone</heading>
             <processing-class>org.dspace.app.rest.submit.step.DescribeStep</processing-class>
             <type>submission-form</type>
         </step-definition>
-        <step-definition id="openAIREOrganizationForm" mandatory="true">
+        <step-definition id="openaireOrganizationForm" mandatory="true">
             <heading>submit.progressbar.describe.stepone</heading>
             <processing-class>org.dspace.app.rest.submit.step.DescribeStep</processing-class>
             <type>submission-form</type>
         </step-definition>
-        <step-definition id="openAIREPublicationPageoneForm" mandatory="true">
+        <step-definition id="openairePublicationPageoneForm" mandatory="true">
             <heading>submit.progressbar.describe.stepone</heading>
             <processing-class>org.dspace.app.rest.submit.step.DescribeStep</processing-class>
             <type>submission-form</type>
         </step-definition>
-        <step-definition id="openAIREPublicationPagetwoForm" mandatory="true">
+        <step-definition id="openairePublicationPagetwoForm" mandatory="true">
             <heading>submit.progressbar.describe.stepone</heading>
             <processing-class>org.dspace.app.rest.submit.step.DescribeStep</processing-class>
             <type>submission-form</type>
@@ -259,13 +259,13 @@
             <step id="license"/>
         </submission-process>
 
-        <!-- OpenAIRE submission processes -->
-        <submission-process name="openAIREPublicationSubmission">
+        <!-- Openaire submission processes -->
+        <submission-process name="openairePublicationSubmission">
             <step id="collection"/>
 
             <!--Step will be to Describe the item. -->
-            <step id="openAIREPublicationPageoneForm"/>
-            <step id="openAIREPublicationPagetwoForm"/>
+            <step id="openairePublicationPageoneForm"/>
+            <step id="openairePublicationPagetwoForm"/>
 
             <!--Step will be to Upload the item -->
             <!-- step id="upload-with-embargo"/-->
@@ -274,17 +274,17 @@
             <!--Step will be to Sign off on the License -->
             <step id="license"/>
         </submission-process>
-        <submission-process name="openAIREPersonSubmission">
+        <submission-process name="openairePersonSubmission">
             <step id="collection"/>
-            <step id="openAIREPersonForm"/>
+            <step id="openairePersonForm"/>
         </submission-process>
-        <submission-process name="openAIREProjectSubmission">
+        <submission-process name="openaireProjectSubmission">
             <step id="collection"/>
-            <step id="openAIREProjectForm"/>
+            <step id="openaireProjectForm"/>
         </submission-process>
-        <submission-process name="openAIREOrganizationSubmission">
+        <submission-process name="openaireOrganizationSubmission">
             <step id="collection"/>
-            <step id="openAIREOrganizationForm"/>
+            <step id="openaireOrganizationForm"/>
         </submission-process>
     </submission-definitions>
 
diff --git a/dspace-server-webapp/src/test/data/dspaceFolder/config/spring/api/external-openaire.xml b/dspace-server-webapp/src/test/data/dspaceFolder/config/spring/api/external-openaire.xml
index 9db02440e4..b045865fe0 100644
--- a/dspace-server-webapp/src/test/data/dspaceFolder/config/spring/api/external-openaire.xml
+++ b/dspace-server-webapp/src/test/data/dspaceFolder/config/spring/api/external-openaire.xml
@@ -4,8 +4,8 @@
 	xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd"
 	default-lazy-init="true">
 
-	<bean id="openAIRERestConnector"
-		class="org.dspace.external.OpenAIRERestConnector">
+	<bean id="openaireRestConnector"
+		class="org.dspace.external.OpenaireRestConnector">
 		<constructor-arg
 			value="${openaire.api.url:https://api.openaire.eu}" />
 		<property name="tokenEnabled"
@@ -18,10 +18,10 @@
 			value="${openaire.token.clientSecret}" />
 	</bean>
 	<bean
-		class="org.dspace.external.provider.impl.MockOpenAIREFundingDataProvider"
+		class="org.dspace.external.provider.impl.MockOpenaireFundingDataProvider"
 		init-method="init">
-		<property name="sourceIdentifier" value="openAIREFunding" />
-		<property name="connector" ref="openAIRERestConnector" />
+		<property name="sourceIdentifier" value="openaireFunding" />
+		<property name="connector" ref="openaireRestConnector" />
 		<property name="supportedEntityTypes">
 			<list>
 				<value>Project</value>
diff --git a/dspace-server-webapp/src/test/data/dspaceFolder/config/spring/api/test-discovery.xml b/dspace-server-webapp/src/test/data/dspaceFolder/config/spring/api/test-discovery.xml
index 4a91ef051e..dd78bffda3 100644
--- a/dspace-server-webapp/src/test/data/dspaceFolder/config/spring/api/test-discovery.xml
+++ b/dspace-server-webapp/src/test/data/dspaceFolder/config/spring/api/test-discovery.xml
@@ -86,10 +86,12 @@
 
                 <!-- search for an entity that can be a Person or an OrgUnit -->
                 <entry key="personOrOrgunit" value-ref="personOrOrgunit"/>
-                <!-- OpenAIRE4 guidelines - search for an OrgUnit that have a specific dc.type=FundingOrganization -->
-                <entry key="openAIREFundingAgency" value-ref="openAIREFundingAgency"/>
+                <!-- Openaire4 guidelines - search for an OrgUnit that have a specific dc.type=FundingOrganization -->
+                <entry key="openaireFundingAgency" value-ref="openaireFundingAgency"/>
                 <entry key="eperson_claims" value-ref="eperson_claims"/>
-
+                <!-- COAR NOTIFY LDN MESSAGES configuration -->
+                <entry key="NOTIFY.incoming" value-ref="NOTIFY.incoming"/>
+                <entry key="NOTIFY.outgoing" value-ref="NOTIFY.outgoing"/>
 
                 <!-- Configuration for scope based tests -->
                 <!-- See org.dspace.app.rest.DiscoveryScopeBasedRestControllerIT for more information -->
@@ -1115,4 +1117,180 @@
         <property name="exposeMinAndMaxValue" value="true"/>
     </bean>
 
+    <bean id="ldnMessageEntityBaseConfig"
+          class="org.dspace.discovery.configuration.DiscoveryConfiguration"
+          scope="prototype">
+        <property name="id" value="ldnMessages" />
+        <!--Which sidebar facets are to be displayed -->
+        <property name="sidebarFacets">
+            <list>
+                <ref bean="searchFilterNotifyRelatedItem" />
+                <ref bean="searchFilterNotifyOrigin" />
+                <ref bean="searchFilterNotifyTarget" />
+                <ref bean="searchFilterNotifyQueueStatus" />
+                <ref bean="searchFilterNotifyActivityStreamType" />
+                <ref bean="searchFilterNotifyCoarNotifyType" />
+                <ref bean="searchFilterNotifyNotificationType" />
+            </list>
+        </property>
+        <!--The search filters which can be used on the discovery search page -->
+        <property name="searchFilters">
+            <list>
+                <ref bean="searchFilterNotifyRelatedItem" />
+                <ref bean="searchFilterNotifyOrigin" />
+                <ref bean="searchFilterNotifyTarget" />
+                <ref bean="searchFilterNotifyQueueStatus" />
+                <ref bean="searchFilterNotifyActivityStreamType" />
+                <ref bean="searchFilterNotifyCoarNotifyType" />
+                <ref bean="searchFilterNotifyNotificationType" />
+            </list>
+        </property>
+        <!--The sort filters for the discovery search-->
+        <property name="searchSortConfiguration">
+            <bean class="org.dspace.discovery.configuration.DiscoverySortConfiguration">
+                <property name="sortFields">
+                    <list>
+                        <ref bean="sortLastModified"/>
+                        <ref bean="sortLastModifiedAsc"/>
+                        <ref bean="sortQueueLastStartTimeDesc"/>
+                        <ref bean="sortQueueLastStartTimeAsc"/>
+                        <ref bean="sortQueueAttemptsDesc"/>
+                        <ref bean="sortQueueAttemptsAsc"/>
+                    </list>
+                </property>
+            </bean>
+        </property>
+        <!--Any default filter queries, these filter queries will be used for all
+            queries done by discovery for this configuration -->
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+            </list>
+        </property>
+        <!--Default result per page  -->
+        <property name="defaultRpp" value="10" />
+    </bean>
+
+    <bean id="NOTIFY.incoming" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="ldnMessageEntityBaseConfig">
+        <property name="id" value="NOTIFY.incoming"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_INCOMING}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.outgoing" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="ldnMessageEntityBaseConfig">
+        <property name="id" value="NOTIFY.outgoing"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_OUTGOING}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="searchFilterNotifyRelatedItem" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="relateditem"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyOrigin" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="origin"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyTarget" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="target"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyQueueStatus" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="queue_status"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyActivityStreamType" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="activity_stream_type"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyCoarNotifyType" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="coar_notify_type"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyNotificationType" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="notification_type"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+
 </beans>
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/CorrectionTypeRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/CorrectionTypeRestRepositoryIT.java
new file mode 100644
index 0000000000..f875ada6e4
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/CorrectionTypeRestRepositoryIT.java
@@ -0,0 +1,308 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.containsInAnyOrder;
+import static org.hamcrest.Matchers.equalTo;
+import static org.hamcrest.Matchers.greaterThanOrEqualTo;
+import static org.hamcrest.Matchers.is;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import java.util.UUID;
+
+import org.dspace.app.rest.repository.CorrectionTypeRestRepository;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.authorize.service.AuthorizeService;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Item;
+import org.dspace.content.service.ItemService;
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+/**
+ * Test suite for {@link CorrectionTypeRestRepository}
+ *
+ * @author Mykhaylo Boychuk (mykhaylo.boychuk at 4science.com)
+ */
+public class CorrectionTypeRestRepositoryIT extends AbstractControllerIntegrationTest {
+
+    @Autowired
+    private ItemService itemService;
+    @Autowired
+    private AuthorizeService authorizeService;
+
+    @Test
+    public void findAllAdminTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes"))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.page.totalElements", greaterThanOrEqualTo(2)))
+                             .andExpect(jsonPath("$._embedded.correctiontypes", containsInAnyOrder(
+                                 allOf(
+                                   hasJsonPath("$.id", equalTo("request-withdrawn")),
+                                   hasJsonPath("$.topic", equalTo("REQUEST/WITHDRAWN")),
+                                   hasJsonPath("$.type", equalTo("correctiontype"))
+                                 ),
+                                 allOf(
+                                   hasJsonPath("$.id", equalTo("request-reinstate")),
+                                   hasJsonPath("$.topic", equalTo("REQUEST/REINSTATE")),
+                                   hasJsonPath("$.type", equalTo("correctiontype"))
+                                 )
+                              )));
+    }
+
+    @Test
+    public void findAllEPersonTest() throws Exception {
+        String ePersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(ePersonToken).perform(get("/api/config/correctiontypes"))
+                               .andExpect(status().isOk())
+                               .andExpect(jsonPath("$.page.totalElements", greaterThanOrEqualTo(2)))
+                               .andExpect(jsonPath("$._embedded.correctiontypes", containsInAnyOrder(
+                                    allOf(
+                                       hasJsonPath("$.id", equalTo("request-withdrawn")),
+                                       hasJsonPath("$.topic", equalTo("REQUEST/WITHDRAWN")),
+                                       hasJsonPath("$.type", equalTo("correctiontype"))
+                                    ),
+                                 allOf(
+                                   hasJsonPath("$.id", equalTo("request-reinstate")),
+                                   hasJsonPath("$.topic", equalTo("REQUEST/REINSTATE")),
+                                   hasJsonPath("$.type", equalTo("correctiontype"))
+                                   )
+                                 )));
+    }
+
+    @Test
+    public void findAllUnauthorizedTest() throws Exception {
+        getClient().perform(get("/api/config/correctiontypes"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findOneAdminTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes/request-withdrawn"))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.id", equalTo("request-withdrawn")))
+                             .andExpect(jsonPath("$.topic", equalTo("REQUEST/WITHDRAWN")))
+                             .andExpect(jsonPath("$.type", equalTo("correctiontype")));
+    }
+
+    @Test
+    public void findOneEPersonTest() throws Exception {
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(epersonToken).perform(get("/api/config/correctiontypes/request-withdrawn"))
+                               .andExpect(status().isOk())
+                               .andExpect(jsonPath("$.id", equalTo("request-withdrawn")))
+                               .andExpect(jsonPath("$.topic", equalTo("REQUEST/WITHDRAWN")))
+                               .andExpect(jsonPath("$.type", equalTo("correctiontype")));
+    }
+
+    @Test
+    public void findOneUnauthorizedTest() throws Exception {
+        getClient().perform(get("/api/config/correctiontypes/request-withdrawn"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findOneNotFoundTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes/test"))
+                             .andExpect(status().isNotFound());
+    }
+
+    @Test
+    public void findByItemWithoutUUIDParameterTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes/search/findByItem"))
+                             .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void findByItemNotFoundTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes/search/findByItem")
+                             .param("uuid", UUID.randomUUID().toString()))
+                             .andExpect(status().isUnprocessableEntity());
+    }
+
+    @Test
+    public void findByItemUnAuthorizedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).build();
+        Collection collection = CollectionBuilder.createCollection(context, parentCommunity).build();
+        Item privateItem = ItemBuilder.createItem(context, collection).build();
+        authorizeService.removeAllPolicies(context, privateItem);
+        context.restoreAuthSystemState();
+
+        getClient().perform(get("/api/config/correctiontypes/search/findByItem")
+                   .param("uuid", privateItem.getID().toString()))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findByNotArchivedItemTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).build();
+        Collection collection = CollectionBuilder.createCollection(context, parentCommunity).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        item.setArchived(false);
+        itemService.update(context, item);
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes/search/findByItem")
+                             .param("uuid", item.getID().toString()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.page.totalElements", is(0)));
+    }
+
+    @Test
+    public void findByWithdrawnItemTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .build();
+        Collection collection = CollectionBuilder.createCollection(context, parentCommunity)
+                                                 .build();
+        Item item = ItemBuilder.createItem(context, collection)
+                               .withdrawn()
+                               .build();
+        context.restoreAuthSystemState();
+
+        String tokenAdmin = getAuthToken(admin.getEmail(), password);
+        getClient(tokenAdmin).perform(get("/api/config/correctiontype/search/findByItem")
+                             .param("uuid", item.getID().toString()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.page.totalElements", is(1)))
+                             .andExpect(jsonPath("$._embedded.correctiontypes", containsInAnyOrder(allOf(
+                                 hasJsonPath("$.id", equalTo("request-reinstate")),
+                                 hasJsonPath("$.topic", equalTo("REQUEST/REINSTATE"))
+                              ))));
+    }
+
+    @Test
+    public void findByNotDiscoverableItemTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).build();
+        Collection collection = CollectionBuilder.createCollection(context, parentCommunity).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        item.setDiscoverable(false);
+        itemService.update(context, item);
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes/search/findByItem")
+                             .param("uuid", item.getID().toString()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.page.totalElements", is(1)))
+                             .andExpect(jsonPath("$._embedded.correctiontypes", containsInAnyOrder(
+                                 allOf(
+                                   hasJsonPath("$.id", equalTo("request-withdrawn")),
+                                   hasJsonPath("$.topic", equalTo("REQUEST/WITHDRAWN")),
+                                   hasJsonPath("$.type", equalTo("correctiontype"))
+                                   )
+                              )));
+    }
+
+    @Test
+    public void findByPersonalArchiveItemTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).build();
+        Collection collection = CollectionBuilder.createCollection(context, parentCommunity).build();
+        Item itemOne = ItemBuilder.createItem(context, collection)
+                                  .build();
+
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes/search/findByItem")
+                             .param("uuid", itemOne.getID().toString()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.page.totalElements", is(1)))
+                             .andExpect(jsonPath("$._embedded.correctiontypes", containsInAnyOrder(
+                                 allOf(
+                                   hasJsonPath("$.id", equalTo("request-withdrawn")),
+                                   hasJsonPath("$.topic", equalTo("REQUEST/WITHDRAWN")),
+                                   hasJsonPath("$.type", equalTo("correctiontype"))
+                                   )
+                              )));
+
+    }
+
+    @Test
+    public void findByItemTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).build();
+        Collection collection = CollectionBuilder.createCollection(context, parentCommunity).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes/search/findByItem")
+                             .param("uuid", item.getID().toString()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.page.totalElements", is(1)))
+                             .andExpect(jsonPath("$._embedded.correctiontypes", containsInAnyOrder(
+                                 allOf(
+                                   hasJsonPath("$.id", equalTo("request-withdrawn")),
+                                   hasJsonPath("$.topic", equalTo("REQUEST/WITHDRAWN")),
+                                   hasJsonPath("$.type", equalTo("correctiontype"))
+                                   )
+                              )));
+    }
+
+    @Test
+    public void findByTopicWithoutTopicParameterTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes/search/findByTopic"))
+                             .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void findByWrongTopicTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes/search/findByTopic")
+                             .param("topic", "wrongValue"))
+                             .andExpect(status().isNoContent());
+    }
+
+    @Test
+    public void findByTopicAdminTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/config/correctiontypes/search/findByTopic")
+                             .param("topic", "REQUEST/WITHDRAWN"))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.id", equalTo("request-withdrawn")))
+                             .andExpect(jsonPath("$.topic", equalTo("REQUEST/WITHDRAWN")))
+                             .andExpect(jsonPath("$.type", equalTo("correctiontype")));
+    }
+
+    @Test
+    public void findByTopicEPersonTest() throws Exception {
+        String ePersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(ePersonToken).perform(get("/api/config/correctiontypes/search/findByTopic")
+                               .param("topic", "REQUEST/WITHDRAWN"))
+                               .andExpect(status().isOk())
+                               .andExpect(jsonPath("$.id", equalTo("request-withdrawn")))
+                               .andExpect(jsonPath("$.topic", equalTo("REQUEST/WITHDRAWN")))
+                               .andExpect(jsonPath("$.type", equalTo("correctiontype")));
+    }
+
+    @Test
+    public void findByTopicUnauthorizedTest() throws Exception {
+        getClient().perform(get("/api/config/correctiontypes/search/findByTopic")
+                   .param("topic", "REQUEST/WITHDRAWN"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/DiscoveryRestControllerIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/DiscoveryRestControllerIT.java
index 80d8ab2df4..7336681345 100644
--- a/dspace-server-webapp/src/test/java/org/dspace/app/rest/DiscoveryRestControllerIT.java
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/DiscoveryRestControllerIT.java
@@ -26,13 +26,17 @@ import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.
 import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
 
 import java.io.InputStream;
+import java.nio.charset.Charset;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.UUID;
 
+import com.fasterxml.jackson.databind.ObjectMapper;
 import com.jayway.jsonpath.matchers.JsonPathMatchers;
 import org.apache.commons.codec.CharEncoding;
 import org.apache.commons.io.IOUtils;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.model.Notification;
 import org.dspace.app.rest.matcher.AppliedFilterMatcher;
 import org.dspace.app.rest.matcher.FacetEntryMatcher;
 import org.dspace.app.rest.matcher.FacetValueMatcher;
@@ -51,6 +55,8 @@ import org.dspace.builder.CommunityBuilder;
 import org.dspace.builder.EPersonBuilder;
 import org.dspace.builder.GroupBuilder;
 import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.LDNMessageBuilder;
+import org.dspace.builder.NotifyServiceBuilder;
 import org.dspace.builder.PoolTaskBuilder;
 import org.dspace.builder.SupervisionOrderBuilder;
 import org.dspace.builder.WorkflowItemBuilder;
@@ -6888,4 +6894,133 @@ public class DiscoveryRestControllerIT extends AbstractControllerIntegrationTest
             .andExpect(jsonPath("$._links.self.href", containsString("/api/discover/search/objects")));
     }
 
+    @Test
+    public void discoverSearchObjectsNOTIFYIncomingConfigurationTest() throws Exception {
+        ObjectMapper mapper = new ObjectMapper();
+
+        context.turnOffAuthorisationSystem();
+
+        Community community = CommunityBuilder.createCommunity(context)
+                                              .withName("community")
+                                              .build();
+        Collection collection = CollectionBuilder.createCollection(context, community)
+                                                 .withName("collection")
+                                                 .build();
+
+        Item item = ItemBuilder.createItem(context, collection)
+                               .withTitle("item title")
+                               .build();
+
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("service url")
+                                .withLdnUrl("https://overlay-journal.com/inbox/")
+                                .build();
+
+        InputStream announceEndorsementStream = getClass().getResourceAsStream("ldn_announce_endorsement.json");
+        String announceEndorsement = IOUtils.toString(announceEndorsementStream, Charset.defaultCharset());
+        announceEndorsementStream.close();
+
+        String message = announceEndorsement.replaceAll("<<object>>", object);
+        message = message.replaceAll("<<object_handle>>", object);
+        Notification notification = mapper.readValue(message, Notification.class);
+        LDNMessageBuilder.createNotifyServiceBuilder(context, notification).build();
+
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken)
+            .perform(get("/api/discover/search/objects").param("configuration", "NOTIFY.incoming"))
+            //** THEN **
+            //The status has to be 200 OK
+            .andExpect(status().isOk())
+            //The type has to be 'discover'
+            .andExpect(jsonPath("$.type", is("discover")))
+            //There needs to be a page object that shows the total pages and total elements as well as the
+            // size and the current page (number)
+            .andExpect(jsonPath("$._embedded.searchResult.page", is(
+                PageMatcher.pageEntryWithTotalPagesAndElements(0, 20, 1, 1)
+            )))
+            .andExpect(jsonPath("$._embedded.facets", Matchers.containsInAnyOrder(
+                FacetEntryMatcher.relatedItemFacet(false),
+                FacetEntryMatcher.originFacet(false),
+                FacetEntryMatcher.targetFacet(false),
+                FacetEntryMatcher.queueStatusFacet(false),
+                FacetEntryMatcher.activityStreamTypeFacet(false),
+                FacetEntryMatcher.coarNotifyTypeFacet(false),
+                FacetEntryMatcher.notificationTypeFacet(false)
+            )))
+            //There always needs to be a self link
+            .andExpect(jsonPath("$._links.self.href", containsString("/api/discover/search/objects")));
+    }
+
+    @Test
+    public void discoverSearchObjectsNOTIFYOutgoingConfigurationTest() throws Exception {
+        ObjectMapper mapper = new ObjectMapper();
+
+        context.turnOffAuthorisationSystem();
+
+        Community community = CommunityBuilder.createCommunity(context)
+                                              .withName("community")
+                                              .build();
+        Collection collection = CollectionBuilder.createCollection(context, community)
+                                                 .withName("collection")
+                                                 .build();
+
+        Item item = ItemBuilder.createItem(context, collection)
+                               .withTitle("item title")
+                               .build();
+
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+
+        /*NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("service url")
+                                .withLdnUrl("https://generic-service.com/system/inbox/")
+                                .build();
+        */
+        InputStream announceReviewStream = getClass().getResourceAsStream("ldn_announce_review.json");
+        String announceReview = IOUtils.toString(announceReviewStream, Charset.defaultCharset());
+        announceReviewStream.close();
+
+
+        String message = announceReview.replaceAll("<<object>>", object);
+        message = message.replaceAll("<<object_handle>>", object);
+        Notification notification = mapper.readValue(message, Notification.class);
+        LDNMessageBuilder.createNotifyServiceBuilder(context, notification).build();
+
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken)
+            .perform(get("/api/discover/search/objects").param("configuration", "NOTIFY.outgoing"))
+            //** THEN **
+            //The status has to be 200 OK
+            .andExpect(status().isOk())
+            //The type has to be 'discover'
+            .andExpect(jsonPath("$.type", is("discover")))
+            //There needs to be a page object that shows the total pages and total elements as well as the
+            // size and the current page (number)
+            .andExpect(jsonPath("$._embedded.searchResult.page", is(
+                PageMatcher.pageEntryWithTotalPagesAndElements(0, 20, 1, 1)
+            )))
+            .andExpect(jsonPath("$._embedded.facets", Matchers.containsInAnyOrder(
+                FacetEntryMatcher.relatedItemFacet(false),
+                FacetEntryMatcher.originFacet(false),
+                FacetEntryMatcher.targetFacet(false),
+                FacetEntryMatcher.queueStatusFacet(false),
+                FacetEntryMatcher.activityStreamTypeFacet(false),
+                FacetEntryMatcher.coarNotifyTypeFacet(false),
+                FacetEntryMatcher.notificationTypeFacet(false)
+            )))
+            //There always needs to be a self link
+            .andExpect(jsonPath("$._links.self.href", containsString("/api/discover/search/objects")));
+    }
+
 }
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/DiscoveryVersioningIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/DiscoveryVersioningIT.java
index 083b27d0e5..7b9cad70e9 100644
--- a/dspace-server-webapp/src/test/java/org/dspace/app/rest/DiscoveryVersioningIT.java
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/DiscoveryVersioningIT.java
@@ -1057,8 +1057,8 @@ public class DiscoveryVersioningIT extends AbstractControllerIntegrationTest {
     }
 
     @Test
-    public void test_discoveryXml_openAIREFundingAgency_expectLatestVersionsOnly() throws Exception {
-        final String configuration = "openAIREFundingAgency";
+    public void test_discoveryXml_openaireFundingAgency_expectLatestVersionsOnly() throws Exception {
+        final String configuration = "openaireFundingAgency";
 
 
         Collection collection = createCollection("OrgUnit");
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/EntityTypeRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/EntityTypeRestRepositoryIT.java
index 740a2c0dc3..2de61bb43d 100644
--- a/dspace-server-webapp/src/test/java/org/dspace/app/rest/EntityTypeRestRepositoryIT.java
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/EntityTypeRestRepositoryIT.java
@@ -416,6 +416,8 @@ public class EntityTypeRestRepositoryIT extends AbstractEntityIntegrationTest {
                     .setSupportedEntityTypes(Arrays.asList("Publication"));
             ((AbstractExternalDataProvider) externalDataService.getExternalDataProvider("pubmed"))
                     .setSupportedEntityTypes(Arrays.asList("Publication"));
+            ((AbstractExternalDataProvider) externalDataService.getExternalDataProvider("suggestion"))
+                    .setSupportedEntityTypes(Arrays.asList("Publication"));
 
             // these are similar to the previous checks but now we have restricted the mock and pubmed providers
             // to support only publication, this mean that there are no providers suitable for funding
@@ -439,6 +441,8 @@ public class EntityTypeRestRepositoryIT extends AbstractEntityIntegrationTest {
                     .setSupportedEntityTypes(null);
             ((AbstractExternalDataProvider) externalDataService.getExternalDataProvider("pubmed"))
                     .setSupportedEntityTypes(null);
+            ((AbstractExternalDataProvider) externalDataService.getExternalDataProvider("suggestion"))
+                    .setSupportedEntityTypes(null);
         }
 
     }
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/ExternalSourcesRestControllerIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/ExternalSourcesRestControllerIT.java
index 65492cbbe8..bf71153da2 100644
--- a/dspace-server-webapp/src/test/java/org/dspace/app/rest/ExternalSourcesRestControllerIT.java
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/ExternalSourcesRestControllerIT.java
@@ -51,9 +51,9 @@ public class ExternalSourcesRestControllerIT extends AbstractControllerIntegrati
                                 ExternalSourceMatcher.matchExternalSource(
                                         "pubmed", "pubmed", false),
                                 ExternalSourceMatcher.matchExternalSource(
-                                        "openAIREFunding", "openAIREFunding", false)
+                                        "openaireFunding", "openaireFunding", false)
                             )))
-                            .andExpect(jsonPath("$.page.totalElements", Matchers.is(10)));
+                            .andExpect(jsonPath("$.page.totalElements", Matchers.is(11)));
     }
 
     @Test
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/ItemFilterRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/ItemFilterRestRepositoryIT.java
new file mode 100644
index 0000000000..d6ae2e1aa0
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/ItemFilterRestRepositoryIT.java
@@ -0,0 +1,88 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.is;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import org.dspace.app.rest.repository.ItemFilterRestRepository;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.junit.Test;
+
+/**
+ * Integration test for {@link ItemFilterRestRepository}
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class ItemFilterRestRepositoryIT extends AbstractControllerIntegrationTest {
+
+    @Test
+    public void findOneUnauthorizedTest() throws Exception {
+        getClient().perform(get("/api/config/itemfilters/test"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findOneForbiddenTest() throws Exception {
+        getClient(getAuthToken(eperson.getEmail(), password))
+            .perform(get("/api/config/itemfilters/test"))
+            .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findOneNotFoundTest() throws Exception {
+        getClient(getAuthToken(admin.getEmail(), password))
+            .perform(get("/api/config/itemfilters/test"))
+            .andExpect(status().isNotFound());
+    }
+
+    @Test
+    public void findOneTest() throws Exception {
+        getClient(getAuthToken(admin.getEmail(), password))
+            .perform(get("/api/config/itemfilters/always_true_filter"))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.id", is("always_true_filter")))
+            .andExpect(jsonPath("$._links.self.href",
+                containsString("/api/config/itemfilters/always_true_filter")));
+    }
+
+    @Test
+    public void findAllUnauthorizedTest() throws Exception {
+        getClient().perform(get("/api/config/itemfilters"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findAllForbiddenTest() throws Exception {
+        getClient(getAuthToken(eperson.getEmail(), password))
+            .perform(get("/api/config/itemfilters"))
+            .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findAllPaginatedSortedTest() throws Exception {
+        getClient(getAuthToken(admin.getEmail(), password))
+            .perform(get("/api/config/itemfilters")
+                .param("size", "30"))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.page.totalElements", is(5)))
+            .andExpect(jsonPath("$.page.totalPages", is(1)))
+            .andExpect(jsonPath("$.page.size", is(30)))
+            .andExpect(jsonPath("$._embedded.itemfilters", contains(
+                hasJsonPath("$.id", is("always_true_filter")),
+                hasJsonPath("$.id", is("demo_filter")),
+                hasJsonPath("$.id", is("doi-filter")),
+                hasJsonPath("$.id", is("in-outfit-collection_condition")),
+                hasJsonPath("$.id", is("type_filter")))));
+    }
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/LDNInboxControllerIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/LDNInboxControllerIT.java
new file mode 100644
index 0000000000..d36b17f8ad
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/LDNInboxControllerIT.java
@@ -0,0 +1,418 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static org.dspace.content.QAEvent.COAR_NOTIFY_SOURCE;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.hasItem;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import java.io.InputStream;
+import java.math.BigDecimal;
+import java.nio.charset.Charset;
+import java.sql.SQLException;
+import java.util.List;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.commons.collections4.CollectionUtils;
+import org.apache.commons.io.IOUtils;
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.NotifyServiceBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Community;
+import org.dspace.content.Item;
+import org.dspace.matcher.QASourceMatcher;
+import org.dspace.matcher.QATopicMatcher;
+import org.dspace.qaevent.QANotifyPatterns;
+import org.dspace.qaevent.service.QAEventService;
+import org.dspace.services.ConfigurationService;
+import org.dspace.utils.DSpace;
+import org.junit.After;
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+import org.springframework.test.web.servlet.request.RequestPostProcessor;
+
+
+/**
+ * LDN Controller test class. Simulate receiving external LDN messages
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ *
+ */
+
+public class LDNInboxControllerIT extends AbstractControllerIntegrationTest {
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    @Autowired
+    private LDNMessageService ldnMessageService;
+
+    private QAEventService qaEventService = new DSpace().getSingletonService(QAEventService.class);
+
+    @Test
+    public void ldnInboxAnnounceEndorsementTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context).withName("community").build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("service url")
+                                .withLdnUrl("https://overlay-journal.com/inbox/")
+                                .withLowerIp("127.0.0.1")
+                                .withUpperIp("127.0.0.3")
+                                .build();
+        context.restoreAuthSystemState();
+
+        InputStream announceEndorsementStream = getClass().getResourceAsStream("ldn_announce_endorsement.json");
+        String announceEndorsement = IOUtils.toString(announceEndorsementStream, Charset.defaultCharset());
+        announceEndorsementStream.close();
+        String message = announceEndorsement.replaceAll("<<object>>", object);
+        message = message.replaceAll("<<object_handle>>", object);
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isAccepted());
+
+        LDNMessageEntity ldnMessage = ldnMessageService.find(context, notification.getId());
+        checkStoredLDNMessage(notification, ldnMessage, object);
+    }
+
+    @Test
+    public void ldnInboxAnnounceReviewTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context).withName("community").build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        InputStream announceReviewStream = getClass().getResourceAsStream("ldn_announce_review.json");
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+        NotifyServiceEntity notifyServiceEntity = NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://review-service.com/inbox/about/")
+                                .withLdnUrl("https://review-service.com/inbox/")
+                                .withScore(BigDecimal.valueOf(0.6d))
+                                .withStatus(true)
+                                .withLowerIp("127.0.0.1")
+                                .withUpperIp("127.0.0.3")
+                                .build();
+        String announceReview = IOUtils.toString(announceReviewStream, Charset.defaultCharset());
+        announceReviewStream.close();
+        String message = announceReview.replaceAll("<<object>>", object);
+        message = message.replaceAll("<<object_handle>>", object);
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isAccepted());
+
+        ldnMessageService.extractAndProcessMessageFromQueue(context);
+
+        assertThat(qaEventService.findAllSources(context, 0, 20),
+            hasItem(QASourceMatcher.with(COAR_NOTIFY_SOURCE, 1L)));
+
+        assertThat(qaEventService.findAllTopicsBySource(context, COAR_NOTIFY_SOURCE, 0, 20, "topic", true), hasItem(
+            QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MORE_REVIEW, 1L)));
+
+    }
+
+    @Test
+    public void ldnInboxEndorsementActionBadRequestTest() throws Exception {
+        // id is not an uri
+        InputStream offerEndorsementStream = getClass().getResourceAsStream("ldn_offer_endorsement_badrequest.json");
+        String message = IOUtils.toString(offerEndorsementStream, Charset.defaultCharset());
+        offerEndorsementStream.close();
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isInternalServerError());
+    }
+
+    @Test
+    public void ldnInboxOfferReviewAndACKTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context).withName("community").build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+        NotifyServiceEntity notifyServiceEntity = NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://review-service.com/inbox/about/")
+                                .withLdnUrl("https://review-service.com/inbox/")
+                                .withScore(BigDecimal.valueOf(0.6d))
+                                .withStatus(true)
+                                .withLowerIp("127.0.0.1")
+                                .withUpperIp("127.0.0.3")
+                                .build();
+        InputStream offerReviewStream = getClass().getResourceAsStream("ldn_offer_review.json");
+        String announceReview = IOUtils.toString(offerReviewStream, Charset.defaultCharset());
+        offerReviewStream.close();
+        String message = announceReview.replaceAll("<<object_handle>>", object);
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isAccepted());
+
+        int processed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(processed, 1);
+        processed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(processed, 0);
+
+        InputStream ackReviewStream = getClass().getResourceAsStream("ldn_ack_review_reject.json");
+        String ackReview = IOUtils.toString(ackReviewStream, Charset.defaultCharset());
+        offerReviewStream.close();
+        String ackMessage = ackReview.replaceAll("<<object_handle>>", object);
+        ackMessage = ackMessage.replaceAll("<<ldn_offer_review_uuid>>",
+            "urn:uuid:0370c0fb-bb78-4a9b-87f5-bed307a509de");
+        ObjectMapper ackMapper = new ObjectMapper();
+        Notification ackNotification = mapper.readValue(ackMessage, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(ackMessage))
+            .andExpect(status().isAccepted());
+
+        int ackProcessed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(ackProcessed, 1);
+        ackProcessed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(ackProcessed, 0);
+
+
+    }
+
+    @Test
+    public void ldnInboxAnnounceReleaseTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context).withName("community").build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        InputStream announceRelationshipStream = getClass().getResourceAsStream("ldn_announce_release.json");
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+        NotifyServiceEntity notifyServiceEntity = NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://review-service.com/inbox/about/")
+                                .withLdnUrl("https://review-service.com/inbox/")
+                                .withScore(BigDecimal.valueOf(0.6d))
+                                .withStatus(true)
+                                .withLowerIp("127.0.0.1")
+                                .withUpperIp("127.0.0.3")
+                                .build();
+        String announceRelationship = IOUtils.toString(announceRelationshipStream, Charset.defaultCharset());
+        announceRelationshipStream.close();
+        String message = announceRelationship.replaceAll("<<object>>", object);
+        message = message.replaceAll("<<object_handle>>", object);
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isAccepted());
+
+        ldnMessageService.extractAndProcessMessageFromQueue(context);
+
+        assertThat(qaEventService.findAllSources(context, 0, 20),
+            hasItem(QASourceMatcher.with(COAR_NOTIFY_SOURCE, 1L)));
+
+        assertThat(qaEventService.findAllTopicsBySource(context, COAR_NOTIFY_SOURCE, 0, 20, "topic", true), hasItem(
+            QATopicMatcher.with(QANotifyPatterns.TOPIC_ENRICH_MORE_LINK, 1L)));
+
+    }
+
+    private void checkStoredLDNMessage(Notification notification, LDNMessageEntity ldnMessage, String object)
+        throws Exception {
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification storedMessage = mapper.readValue(ldnMessage.getMessage(), Notification.class);
+
+        assertNotNull(ldnMessage);
+        assertNotNull(ldnMessage.getObject());
+        assertEquals(ldnMessage.getObject()
+                               .getMetadata()
+                               .stream()
+                               .filter(metadataValue ->
+                                   metadataValue.getMetadataField().toString('.').equals("dc.identifier.uri"))
+                               .map(metadataValue -> metadataValue.getValue())
+                               .findFirst().get(), object);
+
+        assertEquals(notification.getId(), storedMessage.getId());
+        assertEquals(notification.getOrigin().getInbox(), storedMessage.getOrigin().getInbox());
+        assertEquals(notification.getTarget().getInbox(), storedMessage.getTarget().getInbox());
+        assertEquals(notification.getObject().getId(), storedMessage.getObject().getId());
+        assertEquals(notification.getType(), storedMessage.getType());
+    }
+
+    @Test
+    public void ldnInboxAnnounceEndorsementInvalidIpTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context).withName("community").build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("service url")
+                                .withLdnUrl("https://overlay-journal.com/inbox/")
+                                .withLowerIp("127.0.0.1")
+                                .withUpperIp("127.0.0.1")
+                                .build();
+        context.restoreAuthSystemState();
+
+        InputStream announceEndorsementStream = getClass().getResourceAsStream("ldn_announce_endorsement.json");
+        String announceEndorsement = IOUtils.toString(announceEndorsementStream, Charset.defaultCharset());
+        announceEndorsementStream.close();
+        String message = announceEndorsement.replaceAll("<<object>>", object);
+        message = message.replaceAll("<<object_handle>>", object);
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox").with(remoteHost("mydocker.url", "172.23.0.1"))
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isBadRequest());
+
+        int processed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(processed, 0);
+        LDNMessageEntity ldnMessage = ldnMessageService.find(context, notification.getId());
+        assertNull(ldnMessage);
+    }
+
+    @Test
+    public void ldnInboxAnnounceEndorsementInvalidInboxTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context).withName("community").build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("service url")
+                                .withLdnUrl("https://overlay-journal.com/inbox/")
+                                .withLowerIp("127.0.0.2")
+                                .withUpperIp("127.0.0.5")
+                                .build();
+        context.restoreAuthSystemState();
+
+        InputStream announceEndorsementStream = getClass().getResourceAsStream("ldn_origin_inbox_unregistered.json");
+        String announceEndorsement = IOUtils.toString(announceEndorsementStream, Charset.defaultCharset());
+        announceEndorsementStream.close();
+        String message = announceEndorsement.replaceAll("<<object>>", object);
+        message = message.replaceAll("<<object_handle>>", object);
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+            .contentType("application/ld+json")
+            .content(message))
+            .andExpect(status().isBadRequest());
+
+        int processed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(processed, 0);
+
+    }
+
+    @Test
+    public void ldnInboxOutOfRangeIPwithDisabledCheckTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context).withName("community").build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        configurationService.setProperty("ldn.notify.inbox.block-untrusted-ip", false);
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("service url")
+                                .withLdnUrl("https://overlay-journal.com/inbox/")
+                                .withLowerIp("127.0.0.1")
+                                .withUpperIp("127.0.0.1")
+                                .build();
+        context.restoreAuthSystemState();
+
+        InputStream announceEndorsementStream = getClass().getResourceAsStream("ldn_announce_endorsement.json");
+        String announceEndorsement = IOUtils.toString(announceEndorsementStream, Charset.defaultCharset());
+        announceEndorsementStream.close();
+        String message = announceEndorsement.replaceAll("<<object>>", object);
+        message = message.replaceAll("<<object_handle>>", object);
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox").with(remoteHost("mydocker.url", "172.23.0.1"))
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isAccepted());
+
+        LDNMessageEntity ldnMessage = ldnMessageService.find(context, notification.getId());
+        checkStoredLDNMessage(notification, ldnMessage, object);
+        assertEquals(ldnMessage.getQueueStatus(), LDNMessageEntity.QUEUE_STATUS_UNTRUSTED_IP);
+    }
+
+    private static RequestPostProcessor remoteHost(final String remoteHost, final String remoteAddr) {
+        return request -> {
+            request.setRemoteHost(remoteHost);
+            request.setRemoteAddr(remoteAddr);
+            return request;
+        };
+    }
+
+    @Override
+    @After
+    public void destroy() throws Exception {
+        List<LDNMessageEntity> ldnMessageEntities = ldnMessageService.findAll(context);
+        if (CollectionUtils.isNotEmpty(ldnMessageEntities)) {
+            ldnMessageEntities.forEach(ldnMessage -> {
+                try {
+                    ldnMessageService.delete(context, ldnMessage);
+                } catch (SQLException e) {
+                    throw new RuntimeException(e);
+                }
+            });
+        }
+
+        super.destroy();
+    }
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/LDNMessageRestControllerIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/LDNMessageRestControllerIT.java
new file mode 100644
index 0000000000..a3001f6019
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/LDNMessageRestControllerIT.java
@@ -0,0 +1,151 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.nullValue;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import java.io.InputStream;
+import java.nio.charset.Charset;
+import java.sql.SQLException;
+import java.util.List;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.commons.collections4.CollectionUtils;
+import org.apache.commons.io.IOUtils;
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.NotifyServiceBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Community;
+import org.dspace.content.Item;
+import org.dspace.services.ConfigurationService;
+import org.junit.After;
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Integration Tests against {@link LDNMessageRestController}
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class LDNMessageRestControllerIT extends AbstractControllerIntegrationTest {
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    @Autowired
+    private LDNMessageService ldnMessageService;
+
+    @Test
+    public void findByItemUnAuthorizedTest() throws Exception {
+        getClient()
+                .perform(post("/api/ldn/messages/urn:uuid:668f26e0-2c8d-4117-a0d2-ee713523bcb4/enqueueretry"))
+                .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findByItemIsForbiddenTest() throws Exception {
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken)
+            .perform(post("/api/ldn/messages/urn:uuid:668f26e0-2c8d-4117-a0d2-ee713523bcb4/enqueueretry"))
+            .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findByItemNotFoundTest() throws Exception {
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(post("/api/ldn/messages/urn:uuid:668f26e0-2c8d-4117-a0d2-ee713523bcb4/enqueueretry"))
+            .andExpect(status().isNotFound());
+    }
+
+    @Test
+    public void findByItemTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context)
+                                              .withName("community")
+                                              .build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+
+        Item item = ItemBuilder.createItem(context, collection)
+                               .withTitle("item title")
+                               .build();
+
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("service url")
+                                .withLdnUrl("https://overlay-journal.com/inbox/")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        InputStream announceEndorsementStream = getClass().getResourceAsStream("ldn_announce_endorsement.json");
+        String announceEndorsement = IOUtils.toString(announceEndorsementStream, Charset.defaultCharset());
+        announceEndorsementStream.close();
+        String message = announceEndorsement.replaceAll("<<object>>", object);
+        message = message.replaceAll("<<object_handle>>", object);
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isAccepted());
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(post("/api/ldn/messages/" + notification.getId() + "/enqueueretry"))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.id", is(notification.getId())))
+            .andExpect(jsonPath("$.notificationId", is(notification.getId())))
+            .andExpect(jsonPath("$.queueStatus", is(7)))
+            .andExpect(jsonPath("$.queueStatusLabel", is("QUEUE_STATUS_QUEUED_FOR_RETRY")))
+            .andExpect(jsonPath("$.context", is(item.getID().toString())))
+            .andExpect(jsonPath("$.object", is(item.getID().toString())))
+            .andExpect(jsonPath("$.target", nullValue()))
+            .andExpect(jsonPath("$.origin", is(notifyService.getID())))
+            .andExpect(jsonPath("$.inReplyTo", nullValue()))
+            .andExpect(jsonPath("$.activityStreamType", is("Announce")))
+            .andExpect(jsonPath("$.coarNotifyType", is("coar-notify:EndorsementAction")))
+            .andExpect(jsonPath("$.queueAttempts", is(0)))
+            .andExpect(jsonPath("$.notificationType", is("Incoming")));
+
+    }
+
+    @Override
+    @After
+    public void destroy() throws Exception {
+        List<LDNMessageEntity> ldnMessageEntities = ldnMessageService.findAll(context);
+        if (CollectionUtils.isNotEmpty(ldnMessageEntities)) {
+            ldnMessageEntities.forEach(ldnMessage -> {
+                try {
+                    ldnMessageService.delete(context, ldnMessage);
+                } catch (SQLException e) {
+                    throw new RuntimeException(e);
+                }
+            });
+        }
+
+        super.destroy();
+    }
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/LDNMessageRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/LDNMessageRestRepositoryIT.java
new file mode 100644
index 0000000000..8b9cf3e066
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/LDNMessageRestRepositoryIT.java
@@ -0,0 +1,257 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static javax.ws.rs.core.MediaType.APPLICATION_JSON_PATCH_JSON;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.nullValue;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.patch;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import java.io.InputStream;
+import java.nio.charset.Charset;
+import java.sql.SQLException;
+import java.util.List;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.commons.collections4.CollectionUtils;
+import org.apache.commons.io.IOUtils;
+import org.dspace.app.ldn.LDNMessageEntity;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.rest.model.LDNMessageEntityRest;
+import org.dspace.app.rest.repository.LDNMessageRestRepository;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.NotifyServiceBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Community;
+import org.dspace.content.Item;
+import org.dspace.services.ConfigurationService;
+import org.junit.After;
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Integration Tests against {@link LDNMessageRestRepository}
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class LDNMessageRestRepositoryIT extends AbstractControllerIntegrationTest {
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    @Autowired
+    private LDNMessageService ldnMessageService;
+
+    @Test
+    public void findOneUnAuthorizedTest() throws Exception {
+        getClient()
+            .perform(get("/api/ldn/messages/urn:uuid:668f26e0-2c8d-4117-a0d2-ee713523bcb4"))
+            .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findOneIsForbiddenTest() throws Exception {
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/ldn/messages/urn:uuid:668f26e0-2c8d-4117-a0d2-ee713523bcb4"))
+            .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findOneIsNotFoundTest() throws Exception {
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/ldn/messages/urn:uuid:668f26e0-2c8d-4117-a0d2-ee713523bcb4"))
+            .andExpect(status().isNotFound());
+    }
+
+    @Test
+    public void findOneTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context)
+                                              .withName("community")
+                                              .build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+
+        Item item = ItemBuilder.createItem(context, collection)
+                               .withTitle("item title")
+                               .build();
+
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("service url")
+                                .withLdnUrl("https://overlay-journal.com/inbox/")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        InputStream announceEndorsementStream = getClass().getResourceAsStream("ldn_announce_endorsement.json");
+        String announceEndorsement = IOUtils.toString(announceEndorsementStream, Charset.defaultCharset());
+        announceEndorsementStream.close();
+        String message = announceEndorsement.replaceAll("<<object>>", object);
+        message = message.replaceAll("<<object_handle>>", object);
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isAccepted());
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/ldn/messages/" + notification.getId()))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.id", is(notification.getId())))
+            .andExpect(jsonPath("$.notificationId", is(notification.getId())))
+            .andExpect(jsonPath("$.queueStatus", is(1)))
+            .andExpect(jsonPath("$.queueStatusLabel", is("QUEUE_STATUS_QUEUED")))
+            .andExpect(jsonPath("$.context", is(item.getID().toString())))
+            .andExpect(jsonPath("$.object", is(item.getID().toString())))
+            .andExpect(jsonPath("$.target", nullValue()))
+            .andExpect(jsonPath("$.origin", is(notifyService.getID())))
+            .andExpect(jsonPath("$.inReplyTo", nullValue()))
+            .andExpect(jsonPath("$.activityStreamType", is("Announce")))
+            .andExpect(jsonPath("$.coarNotifyType", is("coar-notify:EndorsementAction")))
+            .andExpect(jsonPath("$.queueAttempts", is(0)))
+            .andExpect(jsonPath("$.notificationType", is("Incoming")));
+    }
+
+    @Test
+    public void findAllUnAuthorizedTest() throws Exception {
+        getClient().perform(get("/api/ldn/messages"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findAllIsForbiddenTest() throws Exception {
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken).perform(get("/api/ldn/messages"))
+                            .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findAllTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context)
+                                              .withName("community")
+                                              .build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+
+        Item item = ItemBuilder.createItem(context, collection)
+                               .withTitle("item title")
+                               .build();
+
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+
+        NotifyServiceEntity notifyService =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("service url")
+                                .withLdnUrl("https://overlay-journal.com/inbox/")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        InputStream announceEndorsementStream = getClass().getResourceAsStream("ldn_announce_endorsement.json");
+        String announceEndorsement = IOUtils.toString(announceEndorsementStream, Charset.defaultCharset());
+        announceEndorsementStream.close();
+        String message = announceEndorsement.replaceAll("<<object>>", object);
+        message = message.replaceAll("<<object_handle>>", object);
+
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isAccepted());
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/ldn/messages/"))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$._embedded.messages[0].id", is(notification.getId())))
+            .andExpect(jsonPath("$._embedded.messages[0].notificationId", is(notification.getId())))
+            .andExpect(jsonPath("$._embedded.messages[0].queueStatus", is(1)))
+            .andExpect(jsonPath("$._embedded.messages[0].queueStatusLabel", is("QUEUE_STATUS_QUEUED")))
+            .andExpect(jsonPath("$._embedded.messages[0].context", is(item.getID().toString())))
+            .andExpect(jsonPath("$._embedded.messages[0].object", is(item.getID().toString())))
+            .andExpect(jsonPath("$._embedded.messages[0].target", nullValue()))
+            .andExpect(jsonPath("$._embedded.messages[0].origin", is(notifyService.getID())))
+            .andExpect(jsonPath("$._embedded.messages[0].inReplyTo", nullValue()))
+            .andExpect(jsonPath("$._embedded.messages[0].activityStreamType", is("Announce")))
+            .andExpect(jsonPath("$._embedded.messages[0].coarNotifyType", is("coar-notify:EndorsementAction")))
+            .andExpect(jsonPath("$._embedded.messages[0].queueAttempts", is(0)))
+            .andExpect(jsonPath("$._embedded.messages[0].notificationType", is("Incoming")));
+    }
+
+    @Test
+    public void createLDNMessageTest() throws Exception {
+        ObjectMapper mapper = new ObjectMapper();
+        LDNMessageEntityRest data = new LDNMessageEntityRest();
+        String authToken = getAuthToken(admin.getEmail(), password);
+
+        getClient(authToken)
+            .perform(post("/api/ldn/messages")
+                .content(mapper.writeValueAsBytes(data))
+                .contentType(contentType))
+            .andExpect(status().isMethodNotAllowed());
+    }
+
+    @Test
+    public void deleteLDNMessageTest() throws Exception {
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(delete("/api/ldn/messages/urn:uuid:668f26e0-2c8d-4117-a0d2-ee713523bcb4"))
+            .andExpect(status().isMethodNotAllowed());
+    }
+
+    @Test
+    public void patchLDNMessageTest() throws Exception {
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/messages/urn:uuid:668f26e0-2c8d-4117-a0d2-ee713523bcb4")
+                .content(getPatchContent(List.of()))
+                .contentType(APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isMethodNotAllowed());
+    }
+
+    @Override
+    @After
+    public void destroy() throws Exception {
+        List<LDNMessageEntity> ldnMessageEntities = ldnMessageService.findAll(context);
+        if (CollectionUtils.isNotEmpty(ldnMessageEntities)) {
+            ldnMessageEntities.forEach(ldnMessage -> {
+                try {
+                    ldnMessageService.delete(context, ldnMessage);
+                } catch (SQLException e) {
+                    throw new RuntimeException(e);
+                }
+            });
+        }
+
+        super.destroy();
+    }
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/NotifyRequestStatusRestControllerIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/NotifyRequestStatusRestControllerIT.java
new file mode 100644
index 0000000000..65881c5609
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/NotifyRequestStatusRestControllerIT.java
@@ -0,0 +1,203 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static org.junit.Assert.assertEquals;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import java.io.InputStream;
+import java.math.BigDecimal;
+import java.nio.charset.Charset;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.commons.io.IOUtils;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.model.Notification;
+import org.dspace.app.ldn.service.LDNMessageService;
+import org.dspace.app.rest.model.NotifyRequestStatusRest;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.NotifyServiceBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Community;
+import org.dspace.content.Item;
+import org.dspace.services.ConfigurationService;
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+
+
+/**
+ * Rest Controller for NotifyRequestStatus targeting items IT
+ * class {@link NotifyRequestStatusRestController}
+ *
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science dot it)
+ */
+public class NotifyRequestStatusRestControllerIT extends AbstractControllerIntegrationTest {
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    @Autowired
+    private LDNMessageService ldnMessageService;
+
+    @Test
+    public void oneStatusReviewedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context).withName("community").build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+        NotifyServiceEntity notifyServiceEntity = NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://review-service.com/inbox/about/")
+                                .withLdnUrl("https://review-service.com/inbox/")
+                                .withStatus(true)
+                                .withScore(BigDecimal.valueOf(0.6d))
+                                .build();
+        //SEND OFFER REVIEW
+        InputStream offerReviewStream = getClass().getResourceAsStream("ldn_offer_review.json");
+        String announceReview = IOUtils.toString(offerReviewStream, Charset.defaultCharset());
+        offerReviewStream.close();
+        String message = announceReview.replaceAll("<<object_handle>>", object);
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isAccepted());
+
+        int processed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(processed, 1);
+        processed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(processed, 0);
+
+        //CHECK THE SERVICE ON ITS notifystatus ARRAY
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/" + NotifyRequestStatusRest.CATEGORY + "/"
+                + NotifyRequestStatusRest.NAME + "/" + item.getID())
+                .contentType("application/ld+json"))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyStatus").isArray())
+            .andExpect(jsonPath("$.notifyStatus").isNotEmpty())
+            .andExpect(jsonPath("$.notifyStatus[0].status").value("REQUESTED"))
+            .andExpect(jsonPath("$.notifyStatus[0].serviceUrl").value("https://review-service.com/inbox/about/"))
+            ;
+    }
+
+    @Test
+    public void oneStatusAnnounceEndorsementTestDisabledService() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context).withName("community").build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+        NotifyServiceEntity notifyServiceEntity = NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://review-service.com/inbox/about/")
+                                .withLdnUrl("https://review-service.com/inbox/")
+                                .withStatus(false) // service is disabled
+                                .withScore(BigDecimal.valueOf(0.6d))
+                                .build();
+        //SEND OFFER REVIEW
+        InputStream offerReviewStream = getClass().getResourceAsStream("ldn_offer_review3.json");
+        String announceReview = IOUtils.toString(offerReviewStream, Charset.defaultCharset());
+        offerReviewStream.close();
+        String message = announceReview.replaceAll("<<object_handle>>", object);
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isAccepted());
+
+        int processed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(processed, 0);
+        processed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(processed, 0);
+
+    }
+
+    @Test
+    public void oneStatusRejectedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Community community = CommunityBuilder.createCommunity(context).withName("community").build();
+        Collection collection = CollectionBuilder.createCollection(context, community).build();
+        Item item = ItemBuilder.createItem(context, collection).build();
+        String object = configurationService.getProperty("dspace.ui.url") + "/handle/" + item.getHandle();
+        NotifyServiceEntity notifyServiceEntity = NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://review-service.com/inbox/about/")
+                                .withLdnUrl("https://review-service.com/inbox/")
+                                .withStatus(true)
+                                .withScore(BigDecimal.valueOf(0.6d))
+                                .build();
+        //SEND OFFER REVIEW
+        InputStream offerReviewStream = getClass().getResourceAsStream("ldn_offer_review2.json");
+        String announceReview = IOUtils.toString(offerReviewStream, Charset.defaultCharset());
+        offerReviewStream.close();
+        String message = announceReview.replaceAll("<<object_handle>>", object);
+        ObjectMapper mapper = new ObjectMapper();
+        Notification notification = mapper.readValue(message, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(message))
+            .andExpect(status().isAccepted());
+
+        int processed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(processed, 1);
+        processed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+
+        assertEquals(processed, 0);
+        //SEND ACK REVIEW REJECTED
+        InputStream ackReviewStream = getClass().getResourceAsStream("ldn_ack_review_reject.json");
+        String ackReview = IOUtils.toString(ackReviewStream, Charset.defaultCharset());
+        ackReviewStream.close();
+        String ackMessage = ackReview.replaceAll("<<object_handle>>", object);
+        ackMessage = ackMessage.replaceAll(
+            "<<ldn_offer_review_uuid>>", "urn:uuid:0370c0fb-bb78-4a9b-87f5-bed307a509df");
+
+        ObjectMapper ackMapper = new ObjectMapper();
+        Notification ackNotification = ackMapper.readValue(ackMessage, Notification.class);
+        getClient()
+            .perform(post("/ldn/inbox")
+                .contentType("application/ld+json")
+                .content(ackMessage))
+            .andExpect(status().isAccepted());
+
+        int ackProcessed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(ackProcessed, 1);
+        ackProcessed = ldnMessageService.extractAndProcessMessageFromQueue(context);
+        assertEquals(ackProcessed, 0);
+
+        //CHECK THE SERVICE ON ITS notifystatus ARRAY
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/" + NotifyRequestStatusRest.CATEGORY + "/"
+                + NotifyRequestStatusRest.NAME + "/" + item.getID())
+                .contentType("application/ld+json"))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyStatus").isArray())
+            .andExpect(jsonPath("$.notifyStatus").isNotEmpty())
+            .andExpect(jsonPath("$.notifyStatus[0].status").value("REJECTED"))
+            .andExpect(jsonPath("$.notifyStatus[0].serviceUrl").value("https://review-service.com/inbox/about/"))
+            .andExpect(jsonPath("$.notifyStatus[0].offerType").value("Review"))
+            ;
+    }
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/NotifyServiceRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/NotifyServiceRestRepositoryIT.java
new file mode 100644
index 0000000000..a20f3b10ad
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/NotifyServiceRestRepositoryIT.java
@@ -0,0 +1,2495 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static com.jayway.jsonpath.JsonPath.read;
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.dspace.app.rest.matcher.NotifyServiceMatcher.matchNotifyService;
+import static org.dspace.app.rest.matcher.NotifyServiceMatcher.matchNotifyServicePattern;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.closeTo;
+import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.containsInAnyOrder;
+import static org.hamcrest.Matchers.empty;
+import static org.hamcrest.Matchers.hasItem;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.notNullValue;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.patch;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import java.math.BigDecimal;
+import java.sql.SQLException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.ws.rs.core.MediaType;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.apache.commons.collections4.CollectionUtils;
+import org.apache.commons.lang3.RandomUtils;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.ldn.service.NotifyService;
+import org.dspace.app.rest.model.NotifyServiceInboundPatternRest;
+import org.dspace.app.rest.model.NotifyServiceRest;
+import org.dspace.app.rest.model.patch.AddOperation;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.model.patch.RemoveOperation;
+import org.dspace.app.rest.model.patch.ReplaceOperation;
+import org.dspace.app.rest.repository.NotifyServiceRestRepository;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.builder.NotifyServiceBuilder;
+import org.dspace.builder.NotifyServiceInboundPatternBuilder;
+import org.junit.After;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+
+
+/**
+ * Integration test class for {@link NotifyServiceRestRepository}.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyServiceRestRepositoryIT extends AbstractControllerIntegrationTest {
+
+    @Autowired
+    private NotifyService notifyService;
+
+    @Test
+    public void findAllUnAuthorizedTest() throws Exception {
+        getClient().perform(get("/api/ldn/ldnservices"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findAllTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        NotifyServiceEntity notifyServiceEntityOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withDescription("service description one")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceEntityTwo =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name two")
+                                .withDescription("service description two")
+                                .withUrl("https://service2.ldn.org/about")
+                                .withLdnUrl("https://service2.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceEntityThree =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name three")
+                                .withDescription("service description three")
+                                .withUrl("https://service3.ldn.org/about")
+                                .withLdnUrl("https://service3.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/ldn/ldnservices"))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$._embedded.ldnservices", containsInAnyOrder(
+                matchNotifyService(notifyServiceEntityOne.getID(), "service name one", "service description one",
+                    "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                matchNotifyService(notifyServiceEntityTwo.getID(), "service name two", "service description two",
+                    "https://service2.ldn.org/about", "https://service2.ldn.org/inbox"),
+                matchNotifyService(notifyServiceEntityThree.getID(), "service name three", "service description three",
+                    "https://service3.ldn.org/about", "https://service3.ldn.org/inbox")
+            )));
+    }
+
+    @Test
+    public void findOneUnAuthorizedTest() throws Exception {
+        getClient().perform(get("/api/ldn/ldnservices/1"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findOneNotFoundTest() throws Exception {
+
+        getClient(getAuthToken(eperson.getEmail(), password))
+            .perform(get("/api/ldn/ldnservices/" + RandomUtils.nextInt()))
+            .andExpect(status().isNotFound());
+    }
+
+    @Test
+    public void findOneTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/ldn/ldnservices/" + notifyServiceEntity.getID()))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$",
+                matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                    "https://service.ldn.org/about", "https://service.ldn.org/inbox")));
+    }
+
+    @Test
+    public void createForbiddenTest() throws Exception {
+        ObjectMapper mapper = new ObjectMapper();
+        NotifyServiceRest notifyServiceRest = new NotifyServiceRest();
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken).perform(post("/api/ldn/ldnservices")
+                                .content(mapper.writeValueAsBytes(notifyServiceRest))
+                                .contentType(contentType))
+                            .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void createTestScoreFail() throws Exception {
+        ObjectMapper mapper = new ObjectMapper();
+
+        NotifyServiceInboundPatternRest inboundPatternRestOne = new NotifyServiceInboundPatternRest();
+        inboundPatternRestOne.setPattern("patternA");
+        inboundPatternRestOne.setConstraint("itemFilterA");
+        inboundPatternRestOne.setAutomatic(true);
+
+        NotifyServiceInboundPatternRest inboundPatternRestTwo = new NotifyServiceInboundPatternRest();
+        inboundPatternRestTwo.setPattern("patternB");
+        inboundPatternRestTwo.setAutomatic(false);
+
+        NotifyServiceRest notifyServiceRest = new NotifyServiceRest();
+        notifyServiceRest.setName("service name");
+        notifyServiceRest.setDescription("service description");
+        notifyServiceRest.setUrl("service url");
+        notifyServiceRest.setLdnUrl("service ldn url");
+        notifyServiceRest.setScore(BigDecimal.TEN);
+        notifyServiceRest.setNotifyServiceInboundPatterns(List.of(inboundPatternRestOne, inboundPatternRestTwo));
+        notifyServiceRest.setEnabled(false);
+
+        AtomicReference<Integer> idRef = new AtomicReference<Integer>();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken).perform(post("/api/ldn/ldnservices")
+            .content(mapper.writeValueAsBytes(notifyServiceRest))
+            .contentType(contentType))
+        .andExpect(status().isUnprocessableEntity());
+    }
+
+    @Test
+    public void createTest() throws Exception {
+        ObjectMapper mapper = new ObjectMapper();
+
+        NotifyServiceInboundPatternRest inboundPatternRestOne = new NotifyServiceInboundPatternRest();
+        inboundPatternRestOne.setPattern("patternA");
+        inboundPatternRestOne.setConstraint("itemFilterA");
+        inboundPatternRestOne.setAutomatic(true);
+
+        NotifyServiceInboundPatternRest inboundPatternRestTwo = new NotifyServiceInboundPatternRest();
+        inboundPatternRestTwo.setPattern("patternB");
+        inboundPatternRestTwo.setAutomatic(false);
+
+        NotifyServiceRest notifyServiceRest = new NotifyServiceRest();
+        notifyServiceRest.setName("service name");
+        notifyServiceRest.setDescription("service description");
+        notifyServiceRest.setUrl("https://service.ldn.org/about");
+        notifyServiceRest.setLdnUrl("https://service.ldn.org/inbox");
+        notifyServiceRest.setNotifyServiceInboundPatterns(List.of(inboundPatternRestOne, inboundPatternRestTwo));
+        notifyServiceRest.setEnabled(false);
+        notifyServiceRest.setLowerIp("192.168.0.1");
+        notifyServiceRest.setUpperIp("192.168.0.5");
+
+        AtomicReference<Integer> idRef = new AtomicReference<Integer>();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken).perform(post("/api/ldn/ldnservices")
+                                .content(mapper.writeValueAsBytes(notifyServiceRest))
+                                .contentType(contentType))
+                            .andExpect(status().isCreated())
+                            .andExpect(jsonPath("$", matchNotifyService("service name", "service description",
+                                "https://service.ldn.org/about", "https://service.ldn.org/inbox", false,
+                                "192.168.0.1", "192.168.0.5")))
+                            .andDo(result ->
+                                idRef.set((read(result.getResponse().getContentAsString(), "$.id"))));
+
+        getClient(authToken)
+            .perform(get("/api/ldn/ldnservices/" + idRef.get()))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$", allOf(
+                matchNotifyService(idRef.get(), "service name", "service description",
+                    "https://service.ldn.org/about", "https://service.ldn.org/inbox", false,
+                    "192.168.0.1", "192.168.0.5"),
+                hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                    matchNotifyServicePattern("patternA", "itemFilterA", true),
+                    matchNotifyServicePattern("patternB", null, false)
+                )))
+            ));
+    }
+
+    @Test
+    public void notifyServicePatchOperationForbiddenTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation operation = new AddOperation("/description", "add service description");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void notifyServiceDescriptionAddOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation operation = new AddOperation("/description", "add service description");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void notifyServiceDescriptionAddOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .isEnabled(false)
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation operation = new AddOperation("/description", "add service description");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                "add service description", "https://service.ldn.org/about", "https://service.ldn.org/inbox", false))
+            );
+    }
+
+    @Test
+    public void notifyServiceDescriptionReplaceOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/description", "service description replaced");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void notifyServiceDescriptionReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/description", "service description replaced");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                "service description replaced", "https://service.ldn.org/about",
+                "https://service.ldn.org/inbox", false))
+            );
+    }
+
+    @Test
+    public void notifyServiceDescriptionRemoveOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .isEnabled(false)
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        RemoveOperation operation = new RemoveOperation("/description");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                null, "https://service.ldn.org/about", "https://service.ldn.org/inbox", false))
+            );
+    }
+
+    @Test
+    public void notifyServiceUrlAddOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation operation = new AddOperation("/url", "add service url");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void notifyServiceUrlAddOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation operation = new AddOperation("/url", "add service url");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                "service description", "add service url", "https://service.ldn.org/inbox", false))
+            );
+    }
+
+    @Test
+    public void notifyServiceUrlReplaceOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/url", "service url replaced");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void notifyServiceUrlReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .isEnabled(true)
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/url", "service url replaced");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                "service description", "service url replaced", "https://service.ldn.org/inbox", true))
+            );
+    }
+
+    @Test
+    public void notifyServiceUrlRemoveOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        RemoveOperation operation = new RemoveOperation("/url");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                "service description", null, "https://service.ldn.org/inbox"))
+            );
+    }
+
+    @Test
+    public void notifyServiceNameReplaceOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/name", "service name replaced");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void notifyServiceNameReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/name", "service name replaced");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name replaced",
+                "service description", "https://service.ldn.org/about", "https://service.ldn.org/inbox"))
+            );
+    }
+
+    @Test
+    public void notifyServiceLdnUrlReplaceOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withUrl("https://service.ldn.org/about")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/ldnurl", "service ldn url replaced");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void notifyServiceLdnUrlReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/ldnurl", "service ldn url replaced");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                "service description", "https://service.ldn.org/about", "service ldn url replaced"))
+            );
+    }
+
+    @Test
+    public void notifyServiceNameRemoveOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        RemoveOperation operation = new RemoveOperation("/name");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isUnprocessableEntity());
+    }
+
+    @Test
+    @Ignore
+    /*
+     * frabacche senseless because it's a mandatory+unique
+     * entity field and also table column!
+     */
+    public void notifyServiceLdnUrlRemoveOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        RemoveOperation operation = new RemoveOperation("/ldnurl");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isUnprocessableEntity());
+    }
+
+    @Test
+    public void findByLdnUrlUnAuthorizedTest() throws Exception {
+        getClient().perform(get("/api/ldn/ldnservices/search/byLdnUrl")
+                       .param("ldnUrl", "test"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findByLdnUrlBadRequestTest() throws Exception {
+        getClient(getAuthToken(eperson.getEmail(), password))
+            .perform(get("/api/ldn/ldnservices/search/byLdnUrl"))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void findByLdnUrlTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        NotifyServiceEntity notifyServiceEntityOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withDescription("service description one")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+      NotifyServiceEntity notifyServiceEntityTwo =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name two")
+                                .withDescription("service description two")
+                                .withUrl("https://service2.ldn.org/about")
+                                .withLdnUrl("https://service2.ldn.org/inbox")
+                                .build();
+
+      NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                          .withName("service name three")
+                          .withDescription("service description three")
+                          .withUrl("https://service3.ldn.org/about")
+                          .withLdnUrl("https://service3.ldn.org/inbox")
+                          .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/ldn/ldnservices/search/byLdnUrl")
+                .param("ldnUrl", notifyServiceEntityOne.getLdnUrl()))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntityOne.getID(),
+                "service name one", "service description one",
+                "https://service.ldn.org/about", "https://service.ldn.org/inbox")));
+    }
+
+    @Test
+    public void deleteUnAuthorizedTest() throws Exception {
+        getClient().perform(delete("/api/ldn/ldnservices/" + RandomUtils.nextInt()))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void deleteForbiddenTest() throws Exception {
+        getClient(getAuthToken(eperson.getEmail(), password))
+            .perform(delete("/api/ldn/ldnservices/" + RandomUtils.nextInt()))
+            .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void deleteNotFoundTest() throws Exception {
+        getClient(getAuthToken(admin.getEmail(), password))
+            .perform(delete("/api/ldn/ldnservices/" + RandomUtils.nextInt()))
+            .andExpect(status().isNotFound());
+    }
+
+    @Test
+    public void deleteTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("service ldnUrl")
+                                .build();
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(delete("/api/ldn/ldnservices/" + notifyServiceEntity.getID()))
+            .andExpect(status().isNoContent());
+
+        getClient(authToken)
+            .perform(get("/api/ldn/ldnservices/" + notifyServiceEntity.getID()))
+            .andExpect(status().isNotFound());
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternsAddOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternsAddOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        // patch add operation but pattern is already existed
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternRemoveOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        RemoveOperation inboundRemoveOperation = new RemoveOperation("notifyServiceInboundPatterns[0]");
+        ops.clear();
+        ops.add(inboundRemoveOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(1)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", hasItem(
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternsRemoveOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperation = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        ops.add(inboundAddOperation);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(1)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false)
+                    ))
+                )));
+
+        // index out of the range
+        RemoveOperation inboundRemoveOperation = new RemoveOperation("notifyServiceInboundPatterns[1]");
+        ops.clear();
+        ops.add(inboundRemoveOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternConstraintAddOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":null,\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern("patternA", null, false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        AddOperation inboundAddOperation = new AddOperation("notifyServiceInboundPatterns[0]/constraint",
+            "itemFilterA");
+        ops.clear();
+        ops.add(inboundAddOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternConstraintAddOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        AddOperation inboundAddOperation = new AddOperation("notifyServiceInboundPatterns[0]/constraint",
+            "itemFilterA");
+        ops.clear();
+        ops.add(inboundAddOperation);
+        patchBody = getPatchContent(ops);
+
+        // constraint at index 0 already has value
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternConstraintReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("notifyServiceInboundPatterns[0]/constraint",
+            "itemFilterC");
+        ops.clear();
+        ops.add(inboundReplaceOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterC", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternConstraintReplaceOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":null,\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern("patternA", null, false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("notifyServiceInboundPatterns[0]/constraint",
+            "itemFilterA");
+        ops.clear();
+        ops.add(inboundReplaceOperation);
+        patchBody = getPatchContent(ops);
+
+        // constraint at index 0 is null
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternConstraintRemoveOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        RemoveOperation inboundRemoveOperation = new RemoveOperation("notifyServiceInboundPatterns[1]/constraint");
+        ops.clear();
+        ops.add(inboundRemoveOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", null, true)
+                    ))
+                )));
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternConstraintRemoveOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperation = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        ops.add(inboundAddOperation);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(1)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false)
+                    ))
+                )));
+
+        // index out of the range
+        RemoveOperation inboundRemoveOperation = new RemoveOperation("notifyServiceInboundPatterns[1]/constraint");
+        ops.clear();
+        ops.add(inboundRemoveOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternPatternAddOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":null,\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern(null, "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        AddOperation inboundAddOperation = new AddOperation("notifyServiceInboundPatterns[0]/pattern",
+            "patternA");
+        ops.clear();
+        ops.add(inboundAddOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternPatternAddOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        AddOperation inboundAddOperation = new AddOperation("notifyServiceInboundPatterns[0]/pattern",
+            "patternA");
+        ops.clear();
+        ops.add(inboundAddOperation);
+        patchBody = getPatchContent(ops);
+
+        // pattern at index 0 already has value
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternPatternReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("notifyServiceInboundPatterns[0]/pattern",
+            "patternC");
+        ops.clear();
+        ops.add(inboundReplaceOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternC", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternPatternReplaceOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":null,\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern(null, "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("notifyServiceInboundPatterns[0]/pattern",
+            "patternA");
+        ops.clear();
+        ops.add(inboundReplaceOperation);
+        patchBody = getPatchContent(ops);
+
+        // pattern at index 0 is null
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternAutomaticReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("notifyServiceInboundPatterns[0]/automatic",
+            "true");
+        ops.clear();
+        ops.add(inboundReplaceOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", true),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternAutomaticReplaceOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("notifyServiceInboundPatterns[0]/automatic",
+            "test");
+        ops.clear();
+        ops.add(inboundReplaceOperation);
+        patchBody = getPatchContent(ops);
+
+        // patch not boolean value
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternsReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("notifyServiceInboundPatterns",
+            "[{\"pattern\":\"patternC\",\"constraint\":\"itemFilterC\",\"automatic\":\"true\"}," +
+                "{\"pattern\":\"patternD\",\"constraint\":\"itemFilterD\",\"automatic\":\"true\"}]");
+        ops.clear();
+        ops.add(inboundReplaceOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternC", "itemFilterC", true),
+                        matchNotifyServicePattern("patternD", "itemFilterD", true)
+                    ))
+                )));
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternsReplaceWithEmptyArrayOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        // empty array will only remove all old patterns
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("notifyServiceInboundPatterns", "[]");
+        ops.clear();
+        ops.add(inboundReplaceOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", empty()));
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternsReplaceOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        // value must be an array not object
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("notifyServiceInboundPatterns",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+        ops.clear();
+        ops.add(inboundReplaceOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternsRemoveOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", containsInAnyOrder(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        RemoveOperation inboundRemoveOperation = new RemoveOperation("notifyServiceInboundPatterns");
+        ops.clear();
+        ops.add(inboundRemoveOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", empty()));
+    }
+
+    @Test
+    public void NotifyServiceInboundPatternReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation inboundAddOperationOne = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternA\",\"constraint\":\"itemFilterA\",\"automatic\":\"false\"}");
+
+        AddOperation inboundAddOperationTwo = new AddOperation("notifyServiceInboundPatterns/-",
+            "{\"pattern\":\"patternB\",\"constraint\":\"itemFilterB\",\"automatic\":\"true\"}");
+
+        ops.add(inboundAddOperationOne);
+        ops.add(inboundAddOperationTwo);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternB", "itemFilterB", true)
+                    ))
+                )));
+
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("notifyServiceInboundPatterns[1]",
+            "{\"pattern\":\"patternC\",\"constraint\":\"itemFilterC\",\"automatic\":\"false\"}");
+        ops.clear();
+        ops.add(inboundReplaceOperation);
+        patchBody = getPatchContent(ops);
+
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", hasSize(2)))
+            .andExpect(jsonPath("$",
+                allOf(
+                    matchNotifyService(notifyServiceEntity.getID(), "service name", "service description",
+                        "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                    hasJsonPath("$.notifyServiceInboundPatterns", contains(
+                        matchNotifyServicePattern("patternA", "itemFilterA", false),
+                        matchNotifyServicePattern("patternC", "itemFilterC", false)
+                    ))
+                )));
+    }
+
+    @Test
+    public void findManualServicesByInboundPatternUnAuthorizedTest() throws Exception {
+        getClient().perform(get("/api/ldn/ldnservices/search/byInboundPattern")
+                       .param("pattern", "pattern"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findManualServicesByInboundPatternBadRequestTest() throws Exception {
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/ldn/ldnservices/search/byInboundPattern"))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void findManualServicesByInboundPatternTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntityOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withDescription("service description one")
+                                .withUrl("https://service.ldn.org/about")
+                                .withStatus(true)
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceEntityTwo =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name two")
+                                .withDescription("service description two")
+                                .withUrl("https://service2.ldn.org/about")
+                                .withStatus(true)
+                                .withLdnUrl("https://service2.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceEntityThree =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name three")
+                                .withDescription("service description")
+                                .withUrl("https://service3.ldn.org/about")
+                                .withStatus(true)
+                                .withLdnUrl("https://service3.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceEntityOne)
+                                          .withPattern("review")
+                                          .withConstraint("itemFilterA")
+                                          .isAutomatic(false)
+                                          .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceEntityOne)
+                                          .withPattern("review")
+                                          .withConstraint("itemFilterB")
+                                          .isAutomatic(true)
+                                          .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceEntityTwo)
+                                          .withPattern("review")
+                                          .withConstraint("itemFilterA")
+                                          .isAutomatic(false)
+                                          .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceEntityTwo)
+                                          .withPattern("review")
+                                          .withConstraint("itemFilterB")
+                                          .isAutomatic(true)
+                                          .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceEntityThree)
+                                          .withPattern("review")
+                                          .withConstraint("itemFilterB")
+                                          .isAutomatic(true)
+                                          .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/ldn/ldnservices/search/byInboundPattern")
+                .param("pattern", "review"))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.page.totalElements", is(2)))
+            .andExpect(jsonPath("$._embedded.ldnservices", containsInAnyOrder(
+                matchNotifyService(notifyServiceEntityOne.getID(), "service name one", "service description one",
+                "https://service.ldn.org/about", "https://service.ldn.org/inbox"),
+                matchNotifyService(notifyServiceEntityTwo.getID(), "service name two", "service description two",
+                    "https://service2.ldn.org/about", "https://service2.ldn.org/inbox")
+                )));
+    }
+
+    @Test
+    public void NotifyServiceStatusReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .isEnabled(true)
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("/enabled", "false");
+        ops.add(inboundReplaceOperation);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.notifyServiceInboundPatterns", empty()))
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                "service description", "https://service.ldn.org/about", "https://service.ldn.org/inbox", false)));
+    }
+
+    @Test
+    public void NotifyServiceScoreReplaceOperationTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withScore(BigDecimal.ZERO)
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("/score", "0.522");
+        ops.add(inboundReplaceOperation);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                "service description", "https://service.ldn.org/about", "https://service.ldn.org/inbox", false)))
+            .andExpect(jsonPath("$.score", notNullValue()))
+            .andExpect(jsonPath("$.score", closeTo(0.522d, 0.001d)));
+    }
+
+    @Test
+    public void NotifyServiceScoreReplaceOperationTestUnprocessableTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("service url")
+                                .withLdnUrl("service ldn url")
+                                .withScore(BigDecimal.ZERO)
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation inboundReplaceOperation = new ReplaceOperation("/score", "10");
+        ops.add(inboundReplaceOperation);
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isUnprocessableEntity());
+    }
+
+
+    @Test
+    public void notifyServiceScoreAddOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("service url")
+                                .withLdnUrl("service ldn url")
+                                .isEnabled(false)
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        AddOperation operation = new AddOperation("/score", "1");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                "service description", "service url", "service ldn url", false)))
+            .andExpect(jsonPath("$.score", notNullValue()))
+            .andExpect(jsonPath("$.score", closeTo(1d, 0.001d)))
+        ;
+    }
+
+    @Override
+    @After
+    public void destroy() throws Exception {
+        List<NotifyServiceEntity> notifyServiceEntities = notifyService.findAll(context);
+        if (CollectionUtils.isNotEmpty(notifyServiceEntities)) {
+            notifyServiceEntities.forEach(notifyServiceEntity -> {
+                try {
+                    notifyService.delete(context, notifyServiceEntity);
+                } catch (SQLException e) {
+                    throw new RuntimeException(e);
+                }
+            });
+        }
+
+        super.destroy();
+    }
+
+    @Test
+    public void notifyServiceLowerIpReplaceOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withUrl("https://service.ldn.org/about")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/lowerIp", "192.168.0.1");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void notifyServiceLowerIpReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .withLowerIp("192.168.0.1")
+                                .withUpperIp("192.168.0.5")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/lowerIp", "192.168.0.2");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                "service description", "https://service.ldn.org/about", "https://service.ldn.org/inbox",
+                false, "192.168.0.2", "192.168.0.5"))
+            );
+    }
+
+    @Test
+    public void notifyServiceLowerIpRemoveOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .withLowerIp("192.168.0.1")
+                                .withUpperIp("192.168.0.5")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        RemoveOperation operation = new RemoveOperation("/lowerIp");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isUnprocessableEntity());
+    }
+
+    @Test
+    public void notifyServiceUpperIpReplaceOperationBadRequestTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withUrl("https://service.ldn.org/about")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/lowerIp", "192.168.0.8");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void notifyServiceUpperIpReplaceOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .withLowerIp("192.168.0.1")
+                                .withUpperIp("192.168.0.5")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        ReplaceOperation operation = new ReplaceOperation("/upperIp", "192.168.0.8");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", matchNotifyService(notifyServiceEntity.getID(), "service name",
+                "service description", "https://service.ldn.org/about", "https://service.ldn.org/inbox",
+                false, "192.168.0.1", "192.168.0.8"))
+            );
+    }
+
+    @Test
+    public void notifyServiceUpperIpRemoveOperationTest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        NotifyServiceEntity notifyServiceEntity =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://service.ldn.org/about")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .withLowerIp("192.168.0.1")
+                                .withUpperIp("192.168.0.5")
+                                .build();
+        context.restoreAuthSystemState();
+
+        List<Operation> ops = new ArrayList<Operation>();
+        RemoveOperation operation = new RemoveOperation("/upperIp");
+        ops.add(operation);
+
+        String patchBody = getPatchContent(ops);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(patch("/api/ldn/ldnservices/" + notifyServiceEntity.getID())
+                .content(patchBody)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isUnprocessableEntity());
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/OpenAIREFundingExternalSourcesIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/OpenaireFundingExternalSourcesIT.java
similarity index 83%
rename from dspace-server-webapp/src/test/java/org/dspace/app/rest/OpenAIREFundingExternalSourcesIT.java
rename to dspace-server-webapp/src/test/java/org/dspace/app/rest/OpenaireFundingExternalSourcesIT.java
index b8f886b2e4..8c76c7adea 100644
--- a/dspace-server-webapp/src/test/java/org/dspace/app/rest/OpenAIREFundingExternalSourcesIT.java
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/OpenaireFundingExternalSourcesIT.java
@@ -19,7 +19,7 @@ import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
 import org.hamcrest.Matchers;
 import org.junit.Test;
 
-public class OpenAIREFundingExternalSourcesIT extends AbstractControllerIntegrationTest {
+public class OpenaireFundingExternalSourcesIT extends AbstractControllerIntegrationTest {
 
     /**
      * Test openaire funding external source
@@ -27,10 +27,10 @@ public class OpenAIREFundingExternalSourcesIT extends AbstractControllerIntegrat
      * @throws Exception
      */
     @Test
-    public void findOneOpenAIREFundingExternalSourceTest() throws Exception {
+    public void findOneOpenaireFundingExternalSourceTest() throws Exception {
         getClient().perform(get("/api/integration/externalsources")).andExpect(status().isOk())
                 .andExpect(jsonPath("$._embedded.externalsources", Matchers.hasItem(
-                        ExternalSourceMatcher.matchExternalSource("openAIREFunding", "openAIREFunding", false))));
+                        ExternalSourceMatcher.matchExternalSource("openaireFunding", "openaireFunding", false))));
     }
 
     /**
@@ -39,9 +39,9 @@ public class OpenAIREFundingExternalSourcesIT extends AbstractControllerIntegrat
      * @throws Exception
      */
     @Test
-    public void findOneOpenAIREFundingExternalSourceEntriesEmptyWithQueryTest() throws Exception {
+    public void findOneOpenaireFundingExternalSourceEntriesEmptyWithQueryTest() throws Exception {
 
-        getClient().perform(get("/api/integration/externalsources/openAIREFunding/entries").param("query", "empty"))
+        getClient().perform(get("/api/integration/externalsources/openaireFunding/entries").param("query", "empty"))
                 .andExpect(status().isOk()).andExpect(jsonPath("$.page.number", is(0)));
     }
 
@@ -52,11 +52,11 @@ public class OpenAIREFundingExternalSourcesIT extends AbstractControllerIntegrat
      * @throws Exception
      */
     @Test
-    public void findOneOpenAIREFundingExternalSourceEntriesWithQueryMultipleKeywordsTest() throws Exception {
+    public void findOneOpenaireFundingExternalSourceEntriesWithQueryMultipleKeywordsTest() throws Exception {
 
         getClient()
                 .perform(
-                        get("/api/integration/externalsources/openAIREFunding/entries").param("query", "empty+results"))
+                        get("/api/integration/externalsources/openaireFunding/entries").param("query", "empty+results"))
                 .andExpect(status().isOk()).andExpect(jsonPath("$.page.number", is(0)));
     }
 
@@ -66,14 +66,14 @@ public class OpenAIREFundingExternalSourcesIT extends AbstractControllerIntegrat
      * @throws Exception
      */
     @Test
-    public void findOneOpenAIREFundingExternalSourceEntriesWithQueryTest() throws Exception {
-        getClient().perform(get("/api/integration/externalsources/openAIREFunding/entries").param("query", "mushroom"))
+    public void findOneOpenaireFundingExternalSourceEntriesWithQueryTest() throws Exception {
+        getClient().perform(get("/api/integration/externalsources/openaireFunding/entries").param("query", "mushroom"))
                 .andExpect(status().isOk())
                 .andExpect(jsonPath("$._embedded.externalSourceEntries",
                         Matchers.hasItem(ExternalSourceEntryMatcher.matchExternalSourceEntry(
                                 "aW5mbzpldS1yZXBvL2dyYW50QWdyZWVtZW50L05XTy8rLzIzMDAxNDc3MjgvTkw=",
                                 "Master switches of initiation of mushroom formation",
-                                "Master switches of initiation of mushroom formation", "openAIREFunding"))));
+                                "Master switches of initiation of mushroom formation", "openaireFunding"))));
 
     }
 
@@ -83,19 +83,19 @@ public class OpenAIREFundingExternalSourcesIT extends AbstractControllerIntegrat
      * @throws Exception
      */
     @Test
-    public void findOneOpenAIREFundingExternalSourceEntryValueTest() throws Exception {
+    public void findOneOpenaireFundingExternalSourceEntryValueTest() throws Exception {
 
         // "info:eu-repo/grantAgreement/mock/mock/mock/mock" base64 encoded
         String projectID = "aW5mbzpldS1yZXBvL2dyYW50QWdyZWVtZW50L0ZDVC81ODc2LVBQQ0RUSS8xMTAwNjIvUFQ=";
         String projectName = "Portuguese Wild Mushrooms: Chemical characterization and functional study"
                 + " of antiproliferative and proapoptotic properties in cancer cell lines";
 
-        getClient().perform(get("/api/integration/externalsources/openAIREFunding/entryValues/" + projectID))
+        getClient().perform(get("/api/integration/externalsources/openaireFunding/entryValues/" + projectID))
                 .andExpect(status().isOk())
                 .andExpect(jsonPath("$",
                         Matchers.allOf(hasJsonPath("$.id", is(projectID)), hasJsonPath("$.display", is(projectName)),
                                 hasJsonPath("$.value", is(projectName)),
-                                hasJsonPath("$.externalSource", is("openAIREFunding")),
+                                hasJsonPath("$.externalSource", is("openaireFunding")),
                                 hasJsonPath("$.type", is("externalSourceEntry")))));
 
     }
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/QAEventRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/QAEventRestRepositoryIT.java
new file mode 100644
index 0000000000..5cecff6ef4
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/QAEventRestRepositoryIT.java
@@ -0,0 +1,1498 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static com.jayway.jsonpath.JsonPath.read;
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasNoJsonPath;
+import static org.dspace.content.QAEvent.COAR_NOTIFY_SOURCE;
+import static org.dspace.content.QAEvent.DSPACE_USERS_SOURCE;
+import static org.dspace.content.QAEvent.OPENAIRE_SOURCE;
+import static org.dspace.correctiontype.WithdrawnCorrectionType.WITHDRAWAL_REINSTATE_GROUP;
+import static org.hamcrest.MatcherAssert.assertThat;
+import static org.hamcrest.Matchers.empty;
+import static org.hamcrest.Matchers.hasSize;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.not;
+import static org.hamcrest.Matchers.notNullValue;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.patch;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import java.math.BigDecimal;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.UUID;
+import java.util.concurrent.atomic.AtomicReference;
+import javax.ws.rs.core.MediaType;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.dspace.app.ldn.NotifyServiceEntity;
+import org.dspace.app.rest.matcher.ItemMatcher;
+import org.dspace.app.rest.matcher.MetadataMatcher;
+import org.dspace.app.rest.matcher.QAEventMatcher;
+import org.dspace.app.rest.model.patch.Operation;
+import org.dspace.app.rest.model.patch.ReplaceOperation;
+import org.dspace.app.rest.repository.QAEventRestRepository;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.EPersonBuilder;
+import org.dspace.builder.EntityTypeBuilder;
+import org.dspace.builder.GroupBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.NotifyServiceBuilder;
+import org.dspace.builder.QAEventBuilder;
+import org.dspace.builder.RelationshipTypeBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.EntityType;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.content.QAEventProcessed;
+import org.dspace.content.service.ItemService;
+import org.dspace.eperson.EPerson;
+import org.dspace.eperson.Group;
+import org.dspace.qaevent.QANotifyPatterns;
+import org.dspace.qaevent.action.ASimpleMetadataAction;
+import org.dspace.qaevent.dao.QAEventsDAO;
+import org.dspace.qaevent.service.dto.CorrectionTypeMessageDTO;
+import org.dspace.services.ConfigurationService;
+import org.hamcrest.Matchers;
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Integration tests for {@link QAEventRestRepository}.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class QAEventRestRepositoryIT extends AbstractControllerIntegrationTest {
+
+    @Autowired
+    private QAEventsDAO qaEventsDao;
+    @Autowired
+    private ConfigurationService configurationService;
+
+    @Autowired
+    private ItemService itemService;
+
+    @Autowired
+    private ASimpleMetadataAction AddReviewMetadataAction;
+
+    @Autowired
+    private ASimpleMetadataAction AddEndorsedMetadataAction;
+
+    @Test
+    public void findAllNotImplementedTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/integration/qualityassuranceevents"))
+                             .andExpect(status()
+                             .isMethodNotAllowed());
+
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(epersonToken).perform(get("/api/integration/qualityassuranceevents"))
+                               .andExpect(status()
+                               .isMethodNotAllowed());
+
+        getClient().perform(get("/api/integration/qualityassuranceevents"))
+                   .andExpect(status()
+                   .isMethodNotAllowed());
+    }
+
+    @Test
+    public void findOneTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        QAEvent event1 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}").build();
+        QAEvent event2 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 4")
+                .withTopic(org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT)
+                .withMessage("{\"abstracts[0]\": \"Descrizione delle caratteristiche...\"}").build();
+        EPerson anotherSubmitter = EPersonBuilder.createEPerson(context).withEmail("another-submitter@example.com")
+                .withPassword(password).build();
+        context.setCurrentUser(anotherSubmitter);
+        QAEvent event3 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withSource(COAR_NOTIFY_SOURCE)
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_REVIEW)
+                .withMessage("{\"abstracts[0]\": \"Descrizione delle caratteristiche...\"}").build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event1.getEventId()))
+            .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(event1)));
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event2.getEventId()))
+            .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(event2)));
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event3.getEventId()))
+            .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(event3)));
+        authToken = getAuthToken(anotherSubmitter.getEmail(), password);
+        // eperson should be see the coar-notify event related to the item that it has submitted
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event3.getEventId()))
+            .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(event3)));
+    }
+
+    @Test
+    public void findOneWithProjectionTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity)
+                                           .withName("Collection 1")
+                                           .build();
+
+        QAEvent event1 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                                       .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                                       .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}")
+                                       .build();
+        QAEvent event5 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 5")
+                        .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PROJECT)
+                        .withMessage(
+                                "{\"projects[0].acronym\":\"PAThs\","
+                                + "\"projects[0].code\":\"687567\","
+                                + "\"projects[0].funder\":\"EC\","
+                                + "\"projects[0].fundingProgram\":\"H2020\","
+                                + "\"projects[0].jurisdiction\":\"EU\","
+                                + "\"projects[0].openaireId\":\"40|corda__h2020::6e32f5eb912688f2424c68b851483ea4\","
+                                + "\"projects[0].title\":\"Tracking Papyrus and Parchment Paths: "
+                                + "An Archaeological Atlas of Coptic Literature."
+                                + "\\nLiterary Texts in their Geographical Context: Production, Copying, Usage, "
+                                + "Dissemination and Storage\"}")
+                        .build();
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event1.getEventId())
+                            .param("projection", "full"))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventFullEntry(event1)));
+
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event5.getEventId())
+                            .param("projection", "full"))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventFullEntry(event5)));
+    }
+
+    @Test
+    public void findOneUnauthorizedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity)
+                                           .withName("Collection 1")
+                                           .build();
+        QAEvent event1 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                                       .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                                       .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}")
+                                       .build();
+        context.restoreAuthSystemState();
+
+        getClient().perform(get("/api/integration/qualityassuranceevents/" + event1.getEventId()))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findOneForbiddenTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        QAEvent event1 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}").build();
+        EPerson anotherSubmitter = EPersonBuilder.createEPerson(context).withEmail("another_submitter@example.com")
+                .build();
+        context.setCurrentUser(anotherSubmitter);
+        QAEvent event2 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withSource(COAR_NOTIFY_SOURCE)
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_REVIEW)
+                .withMessage("{\"href\":\"https://doi.org/10.2307/2144300\"}").build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event1.getEventId()))
+                .andExpect(status().isForbidden());
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event2.getEventId()))
+                .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findByTopicAndTargetTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        String uuid = UUID.randomUUID().toString();
+        Item item = ItemBuilder.createItem(context, col1).withTitle("Tracking Papyrus and Parchment Paths")
+                .build();
+        QAEvent event1 = QAEventBuilder.createTarget(context, item)
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}")
+                .build();
+        QAEvent event2 = QAEventBuilder.createTarget(context, item)
+                .withSource(COAR_NOTIFY_SOURCE)
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_REVIEW)
+                .withMessage("{\"href\":\"https://doi.org/10.2307/2144301\"}").build();
+        EPerson anotherSubmitter = EPersonBuilder.createEPerson(context).withEmail("another-submitter@example.com")
+                .withPassword(password).build();
+        context.setCurrentUser(anotherSubmitter);
+        // this event is related to a new item not submitted by eperson
+        QAEvent event3 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withSource(COAR_NOTIFY_SOURCE)
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_REVIEW)
+                .withMessage("{\"href\":\"https://doi.org/10.2307/2144300\"}").build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(
+                get("/api/integration/qualityassuranceevents/search/findByTopic")
+                    .param("topic", QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID:" + uuid.toString()))
+            .andExpect(status().isOk()).andExpect(jsonPath("$.page.size", is(20)))
+            .andExpect(jsonPath("$.page.totalElements", is(0)));
+
+        uuid = item.getID().toString();
+        // check for an existing item but a different topic
+        getClient(authToken)
+            .perform(
+                get("/api/integration/qualityassuranceevents/search/findByTopic")
+                    .param("topic", QAEvent.OPENAIRE_SOURCE + ":not-existing:" + uuid.toString()))
+            .andExpect(status().isOk()).andExpect(jsonPath("$.page.size", is(20)))
+            .andExpect(jsonPath("$.page.totalElements", is(0)));
+        // check for an existing topic but a different source
+        getClient(authToken)
+            .perform(
+                get("/api/integration/qualityassuranceevents/search/findByTopic")
+                    .param("topic", QAEvent.COAR_NOTIFY_SOURCE + ":ENRICH!MISSING!PID"))
+            .andExpect(status().isOk()).andExpect(jsonPath("$.page.size", is(20)))
+            .andExpect(jsonPath("$.page.totalElements", is(0)));
+
+        // check for an existing item and topic
+        getClient(authToken)
+            .perform(
+                get("/api/integration/qualityassuranceevents/search/findByTopic")
+                    .param("topic", QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID:" + uuid.toString()))
+            .andExpect(status().isOk()).andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(1)))
+            .andExpect(jsonPath("$._embedded.qualityassuranceevents",
+                        Matchers.contains(QAEventMatcher.matchQAEventEntry(event1))))
+            .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(1)));
+        // use the coar-notify source that has a custom security
+        getClient(authToken)
+            .perform(
+                get("/api/integration/qualityassuranceevents/search/findByTopic")
+                    .param("topic", QAEvent.COAR_NOTIFY_SOURCE + ":ENRICH!MORE!REVIEW:" + uuid.toString()))
+            .andExpect(status().isOk()).andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(1)))
+            .andExpect(jsonPath("$._embedded.qualityassuranceevents",
+                        Matchers.contains(QAEventMatcher.matchQAEventEntry(event2))))
+            .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(1)));
+        // check for an existing topic
+        getClient(authToken)
+            .perform(
+                get("/api/integration/qualityassuranceevents/search/findByTopic")
+                    .param("topic", QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"))
+            .andExpect(status().isOk()).andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(1)))
+            .andExpect(jsonPath("$._embedded.qualityassuranceevents",
+                        Matchers.contains(QAEventMatcher.matchQAEventEntry(event1))))
+            .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(1)));
+        // use the coar-notify source that has a custom security
+        getClient(authToken)
+            .perform(
+                get("/api/integration/qualityassuranceevents/search/findByTopic")
+                    .param("topic", QAEvent.COAR_NOTIFY_SOURCE + ":ENRICH!MORE!REVIEW"))
+            .andExpect(status().isOk()).andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(2)))
+            .andExpect(jsonPath("$._embedded.qualityassuranceevents",
+                    Matchers.containsInAnyOrder(
+                            QAEventMatcher.matchQAEventEntry(event2),
+                            QAEventMatcher.matchQAEventEntry(event3))))
+            .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(2)));
+        // check results for eperson
+        authToken = getAuthToken(eperson.getEmail(), password);
+        // check for an item that was submitted by eperson but in a qasource restricted to admins
+        getClient(authToken)
+            .perform(
+                get("/api/integration/qualityassuranceevents/search/findByTopic")
+                    .param("topic", QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID:" + uuid.toString()))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.page.size", is(20)))
+            .andExpect(jsonPath("$.page.totalElements", is(0)));
+        // use the coar-notify source that has a custom security, only 1 event is related to the item submitted by
+        // eperson
+        getClient(authToken)
+            .perform(
+                get("/api/integration/qualityassuranceevents/search/findByTopic")
+                    .param("topic", QAEvent.COAR_NOTIFY_SOURCE + ":ENRICH!MORE!REVIEW:" + uuid.toString()))
+            .andExpect(status().isOk()).andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(1)))
+            .andExpect(jsonPath("$._embedded.qualityassuranceevents",
+                        Matchers.contains(QAEventMatcher.matchQAEventEntry(event2))))
+            .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(1)));
+        // check for an existing topic
+        getClient(authToken)
+            .perform(
+                get("/api/integration/qualityassuranceevents/search/findByTopic")
+                    .param("topic", QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.page.size", is(20)))
+            .andExpect(jsonPath("$.page.totalElements", is(0)));
+
+    }
+
+    @Test
+    public void findByTopicTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        QAEvent event1 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withTopic("ENRICH/MISSING/PID")
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}").build();
+        QAEvent event2 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 2")
+                .withTopic("ENRICH/MISSING/PID")
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144301\"}").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 3")
+                .withTopic("ENRICH/MORE/PID")
+                .withMessage("{\"pids[0].type\":\"pmid\",\"pids[0].value\":\"10.2307/2144302\"}").build();
+        QAEvent event4 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 4")
+                .withTopic("ENRICH/MISSING/ABSTRACT")
+                .withMessage("{\"abstracts[0]\": \"Descrizione delle caratteristiche...\"}").build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/search/findByTopic")
+                        .param("topic", OPENAIRE_SOURCE + ":" + "ENRICH!MISSING!PID"))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(2)))
+                .andExpect(jsonPath("$._embedded.qualityassuranceevents",Matchers.containsInAnyOrder(
+                        QAEventMatcher.matchQAEventEntry(event1),
+                        QAEventMatcher.matchQAEventEntry(event2)
+                )))
+                .andExpect(jsonPath("$.page.size", is(20)))
+                .andExpect(jsonPath("$.page.totalElements", is(2)));
+
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/search/findByTopic")
+                        .param("topic", OPENAIRE_SOURCE + ":" + "ENRICH!MISSING!ABSTRACT"))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(1)))
+                .andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.containsInAnyOrder(
+                        QAEventMatcher.matchQAEventEntry(event4))))
+                .andExpect(jsonPath("$.page.size", is(20)))
+                .andExpect(jsonPath("$.page.totalElements", is(1)));
+
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/search/findByTopic")
+                        .param("topic", "not-existing"))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$.page.size", is(20)))
+                .andExpect(jsonPath("$.page.totalElements", is(0)));
+    }
+
+    @Test
+    public void findByTopicPaginatedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        QAEvent event1 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}").build();
+        QAEvent event2 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 2")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144301\"}").build();
+        QAEvent event3 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 3")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144302\"}").build();
+        QAEvent event4 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 4")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"pmc\",\"pids[0].value\":\"2144303\"}").build();
+        QAEvent event5 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 5")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"pmid\",\"pids[0].value\":\"2144304\"}").build();
+        QAEvent event6 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withSource(OPENAIRE_SOURCE)
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}").build();
+        QAEvent event7 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 2")
+                .withSource(OPENAIRE_SOURCE)
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144301\"}").build();
+        QAEvent event8 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 3")
+                .withSource(OPENAIRE_SOURCE)
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144302\"}").build();
+        QAEvent event9 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 4")
+                .withSource(OPENAIRE_SOURCE)
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"pmc\",\"pids[0].value\":\"2144303\"}").build();
+        QAEvent event10 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 5")
+                .withSource(OPENAIRE_SOURCE)
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"pmid\",\"pids[0].value\":\"2144304\"}").build();
+        context.setCurrentUser(admin);
+        // this event will be related to an item submitted by the admin
+        QAEvent event11 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 5")
+                .withSource(OPENAIRE_SOURCE)
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"pmid\",\"pids[0].value\":\"2144304\"}").build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+                .perform(
+                        get("/api/integration/qualityassuranceevents/search/findByTopic")
+                                .param("topic", QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID")
+                                .param("size", "2"))
+                .andExpect(status().isOk()).andExpect(
+                        jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(2)))
+                .andExpect(jsonPath("$._embedded.qualityassuranceevents",
+                        Matchers.containsInAnyOrder(
+                                QAEventMatcher.matchQAEventEntry(event1),
+                                QAEventMatcher.matchQAEventEntry(event2))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.next.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=1"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=5"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=0"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.prev.href").doesNotExist())
+                .andExpect(jsonPath("$.page.size", is(2)))
+                .andExpect(jsonPath("$.page.totalPages", is(6)))
+                .andExpect(jsonPath("$.page.totalElements", is(11)));
+
+        getClient(authToken)
+                .perform(
+                        get("/api/integration/qualityassuranceevents/search/findByTopic")
+                                .param("topic", QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID")
+                                .param("size", "2").param("page", "1"))
+                .andExpect(status().isOk()).andExpect(
+                        jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(2)))
+                .andExpect(jsonPath("$._embedded.qualityassuranceevents",
+                        Matchers.containsInAnyOrder(
+                                QAEventMatcher.matchQAEventEntry(event3),
+                                QAEventMatcher.matchQAEventEntry(event4))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=1"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.next.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=2"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=5"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=0"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.prev.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=0"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$.page.size", is(2)))
+                .andExpect(jsonPath("$.page.totalPages", is(6)))
+                .andExpect(jsonPath("$.page.totalElements", is(11)));
+
+        getClient(authToken)
+                .perform(
+                        get("/api/integration/qualityassuranceevents/search/findByTopic")
+                                .param("topic", QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID")
+                                .param("size", "2").param("page", "2"))
+                .andExpect(status().isOk()).andExpect(
+                        jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(2)))
+                .andExpect(jsonPath("$._embedded.qualityassuranceevents",
+                        Matchers.hasItem(
+                                QAEventMatcher.matchQAEventEntry(event5))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=2"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.next.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=3"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=5"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=0"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$._links.prev.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/qualityassuranceevents/search/findByTopic?"),
+                                Matchers.containsString("topic=" + QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"),
+                                Matchers.containsString("page=1"),
+                                Matchers.containsString("size=2"))))
+                .andExpect(jsonPath("$.page.size", is(2)))
+                .andExpect(jsonPath("$.page.totalPages", is(6)))
+                .andExpect(jsonPath("$.page.totalElements", is(11)));
+
+        // check if the pagination is working properly also when a security filter is in place
+        authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken)
+                .perform(
+                        get("/api/integration/qualityassuranceevents/search/findByTopic")
+                                .param("topic", QAEvent.OPENAIRE_SOURCE + ":ENRICH!MISSING!PID")
+                                .param("size", "2"))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$", hasNoJsonPath("$._embedded.qualityassuranceevents")))
+                .andExpect(jsonPath("$.page.size", is(2)))
+                .andExpect(jsonPath("$.page.totalPages", is(0)))
+                .andExpect(jsonPath("$.page.totalElements", is(0)));
+    }
+
+    @Test
+    public void findByTopicUnauthorizedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 2")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144301\"}").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 3")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_PID)
+                .withMessage("{\"pids[0].type\":\"pmid\",\"pids[0].value\":\"10.2307/2144302\"}").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 4")
+                .withTopic(org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT)
+                .withMessage("{\"abstracts[0]\": \"Descrizione delle caratteristiche...\"}").build();
+        context.restoreAuthSystemState();
+        getClient().perform(get("/api/integration/qualityassuranceevents/search/findByTopic")
+                   .param("topic", OPENAIRE_SOURCE + ":" + "ENRICH!MISSING!PID"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findByTopicBadRequestTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 2")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144301\"}").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 3")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_PID)
+                .withMessage("{\"pids[0].type\":\"pmid\",\"pids[0].value\":\"10.2307/2144302\"}").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 4")
+                .withTopic(org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT)
+                .withMessage("{\"abstracts[0]\": \"Descrizione delle caratteristiche...\"}").build();
+        context.restoreAuthSystemState();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/integration/qualityassuranceevents/search/findByTopic"))
+                .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void recordDecisionTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        EntityType publication = EntityTypeBuilder.createEntityTypeBuilder(context, "Publication").build();
+        EntityType project = EntityTypeBuilder.createEntityTypeBuilder(context, "Project").build();
+
+        RelationshipTypeBuilder.createRelationshipTypeBuilder(context, publication, project,
+                                "isProjectOfPublication", "isPublicationOfProject", 0, null, 0, null)
+                               .withCopyToRight(true)
+                               .build();
+
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity)
+                                           .withEntityType("Publication")
+                                           .withName("Collection 1")
+                                           .build();
+        Collection colFunding = CollectionBuilder.createCollection(context, parentCommunity)
+                                                 .withName("Collection Fundings")
+                                                 .withEntityType("Project")
+                                                 .build();
+
+        Item funding = ItemBuilder.createItem(context, colFunding)
+                                  .withTitle("Tracking Papyrus and Parchment Paths")
+                                  .build();
+
+        QAEvent eventProjectBound = QAEventBuilder.createTarget(context, col1, "Science and Freedom with project")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PROJECT)
+                .withMessage(
+                        "{\"projects[0].acronym\":\"PAThs\","
+                        + "\"projects[0].code\":\"687567\","
+                        + "\"projects[0].funder\":\"EC\","
+                        + "\"projects[0].fundingProgram\":\"H2020\","
+                        + "\"projects[0].jurisdiction\":\"EU\","
+                        + "\"projects[0].openaireId\":\"40|corda__h2020::6e32f5eb912688f2424c68b851483ea4\","
+                        + "\"projects[0].title\":\"Tracking Papyrus and Parchment Paths: "
+                        + "An Archaeological Atlas of Coptic Literature."
+                        + "\\nLiterary Texts in their Geographical Context: Production, Copying, Usage, "
+                        + "Dissemination and Storage\"}")
+                .withRelatedItem(funding.getID().toString())
+                .build();
+        QAEvent eventProjectNoBound = QAEventBuilder
+                .createTarget(context, col1, "Science and Freedom with unrelated project")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PROJECT)
+                .withMessage(
+                        "{\"projects[0].acronym\":\"NEW\","
+                        + "\"projects[0].code\":\"123456\","
+                        + "\"projects[0].funder\":\"EC\","
+                        + "\"projects[0].fundingProgram\":\"H2020\","
+                        + "\"projects[0].jurisdiction\":\"EU\","
+                        + "\"projects[0].openaireId\":\"newProjectID\","
+                        + "\"projects[0].title\":\"A new project\"}")
+                .build();
+        QAEvent eventMissingPID1 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}")
+                .build();
+        QAEvent eventMissingPID2 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 2")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144301\"}")
+                .build();
+        QAEvent eventMissingUnknownPID = QAEventBuilder.createTarget(context, col1, "Science and Freedom URN PID")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage(
+                        "{\"pids[0].type\":\"urn\",\"pids[0].value\":\"http://thesis2.sba.units.it/store/handle/item/12937\"}")
+                .build();
+        QAEvent eventMorePID = QAEventBuilder.createTarget(context, col1, "Science and Freedom 3")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_PID)
+                .withMessage("{\"pids[0].type\":\"pmid\",\"pids[0].value\":\"2144302\"}")
+                .build();
+        QAEvent eventAbstract = QAEventBuilder.createTarget(context, col1, "Science and Freedom 4")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT)
+                .withMessage("{\"abstracts[0]\": \"An abstract to add...\"}")
+                .build();
+        QAEvent eventAbstractToDiscard = QAEventBuilder.createTarget(context, col1, "Science and Freedom 7")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT)
+                .withMessage("{\"abstracts[0]\": \"Abstract to discard...\"}")
+                .build();
+        context.restoreAuthSystemState();
+
+        // prepare the different patches for our decisions
+        List<Operation> acceptOp = new ArrayList<Operation>();
+        acceptOp.add(new ReplaceOperation("/status", QAEvent.ACCEPTED));
+
+        List<Operation> acceptOpUppercase = new ArrayList<Operation>();
+        acceptOpUppercase.add(new ReplaceOperation("/status", QAEvent.ACCEPTED));
+
+        List<Operation> discardOp = new ArrayList<Operation>();
+        discardOp.add(new ReplaceOperation("/status", QAEvent.DISCARDED));
+
+        List<Operation> rejectOp = new ArrayList<Operation>();
+        rejectOp.add(new ReplaceOperation("/status", QAEvent.REJECTED));
+
+        String patchAccept = getPatchContent(acceptOp);
+        String patchAcceptUppercase = getPatchContent(acceptOpUppercase);
+        String patchDiscard = getPatchContent(discardOp);
+        String patchReject = getPatchContent(rejectOp);
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        // accept pid1, unknownPID, morePID, the two projects and abstract
+        eventMissingPID1.setStatus(QAEvent.ACCEPTED);
+        eventMorePID.setStatus(QAEvent.ACCEPTED);
+        eventMissingUnknownPID.setStatus(QAEvent.ACCEPTED);
+        eventMissingUnknownPID.setStatus(QAEvent.ACCEPTED);
+        eventProjectBound.setStatus(QAEvent.ACCEPTED);
+        eventProjectNoBound.setStatus(QAEvent.ACCEPTED);
+        eventAbstract.setStatus(QAEvent.ACCEPTED);
+
+        getClient(authToken).perform(patch("/api/integration/qualityassuranceevents/" + eventMissingPID1.getEventId())
+                            .content(patchAccept)
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(eventMissingPID1)));
+
+        getClient(authToken).perform(patch("/api/integration/qualityassuranceevents/" + eventMorePID.getEventId())
+                            .content(patchAcceptUppercase)
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(eventMorePID)));
+
+        getClient(authToken)
+            .perform(patch("/api/integration/qualityassuranceevents/" + eventMissingUnknownPID.getEventId())
+                .content(patchAccept)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(eventMissingUnknownPID)));
+
+        getClient(authToken).perform(patch("/api/integration/qualityassuranceevents/" + eventProjectBound.getEventId())
+                            .content(patchAccept)
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(eventProjectBound)));
+
+        getClient(authToken)
+            .perform(patch("/api/integration/qualityassuranceevents/" + eventProjectNoBound.getEventId())
+                .content(patchAccept)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(eventProjectNoBound)));
+
+        getClient(authToken).perform(patch("/api/integration/qualityassuranceevents/" + eventAbstract.getEventId())
+                            .content(patchAccept)
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(eventAbstract)));
+
+        // check if the item has been updated
+        getClient(authToken).perform(get("/api/core/items/" + eventMissingPID1.getTarget())
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$",hasJsonPath("$.metadata['dc.identifier.other'][0].value",
+                                                    is("10.2307/2144300"))));
+
+        getClient(authToken).perform(get("/api/core/items/" + eventMorePID.getTarget())
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", hasJsonPath("$.metadata['dc.identifier.other'][0].value",
+                                                     is("2144302"))));
+
+        getClient(authToken).perform(get("/api/core/items/" + eventMissingUnknownPID.getTarget())
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", hasJsonPath("$.metadata['dc.identifier.other'][0].value",
+                                                     is("http://thesis2.sba.units.it/store/handle/item/12937"))));
+
+        getClient(authToken).perform(get("/api/core/items/" + eventProjectBound.getTarget())
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$",
+                                    hasJsonPath("$.metadata['relation.isProjectOfPublication'][0].value",
+                                             is(funding.getID().toString()))));
+
+        getClient(authToken).perform(get("/api/core/items/" + eventProjectNoBound.getTarget())
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$",
+                                    hasJsonPath("$.metadata['relation.isProjectOfPublication'][0].value",
+                                             is(not(empty())))));
+
+        getClient(authToken).perform(get("/api/core/items/" + eventAbstract.getTarget())
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", hasJsonPath("$.metadata['dc.description.abstract'][0].value",
+                                                              is("An abstract to add..."))));
+
+        // reject pid2
+        eventMissingPID2.setStatus(QAEvent.REJECTED);
+        getClient(authToken).perform(patch("/api/integration/qualityassuranceevents/" + eventMissingPID2.getEventId())
+                            .content(patchReject)
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(eventMissingPID2)));
+
+        getClient(authToken).perform(get("/api/core/items/" + eventMissingPID2.getTarget())
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", hasNoJsonPath("$.metadata['dc.identifier.other']")));
+
+        // discard abstractToDiscard
+        eventAbstractToDiscard.setStatus(QAEvent.DISCARDED);
+        getClient(authToken)
+            .perform(patch("/api/integration/qualityassuranceevents/" + eventAbstractToDiscard.getEventId())
+                .content(patchDiscard)
+                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(eventAbstractToDiscard)));
+
+        getClient(authToken).perform(get("/api/core/items/" + eventMissingPID2.getTarget())
+                            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", hasNoJsonPath("$.metadata['dc.description.abstract']")));
+
+        // no pending qa events should be longer available
+        getClient(authToken).perform(get("/api/integration/qualityassurancesources/" + QAEvent.OPENAIRE_SOURCE))
+                            .andExpect(status().isOk())
+                            .andExpect(content().contentType(contentType))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.totalEvents", is(0)));
+    }
+
+    @Test
+    public void recordDecisionNotifyTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        EntityType publication = EntityTypeBuilder.createEntityTypeBuilder(context, "Publication").build();
+        EntityType project = EntityTypeBuilder.createEntityTypeBuilder(context, "Project").build();
+        RelationshipTypeBuilder.createRelationshipTypeBuilder(context, publication, project, "isProjectOfPublication",
+                "isPublicationOfProject", 0, null, 0,
+                null).withCopyToRight(true).build();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity)
+            .withEntityType("Publication")
+            .withName("Collection 1").build();
+        Collection colFunding = CollectionBuilder.createCollection(context, parentCommunity)
+            .withName("Collection Fundings")
+            .withEntityType("Project").build();
+        Item item = ItemBuilder.createItem(context, colFunding).withTitle("Tracking Papyrus and Parchment Paths")
+                .build();
+        NotifyServiceEntity notifyServiceEntity = NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name")
+                                .withDescription("service description")
+                                .withUrl("https://review-service.com/inbox/about/")
+                                .withLdnUrl("https://review-service.com/inbox/")
+                                .withScore(BigDecimal.valueOf(0.6d))
+                                .build();
+        String href = "EC";
+        QAEvent eventMoreReview = QAEventBuilder.createTarget(context, col1, "Science and Freedom with project")
+                .withSource(COAR_NOTIFY_SOURCE)
+                .withTopic("ENRICH/MORE/REVIEW")
+                .withMessage(
+                        "{"
+                        + "\"serviceName\":\"" + notifyServiceEntity.getName() + "\","
+                        + "\"serviceId\":\"" + notifyServiceEntity.getID() + "\","
+                        + "\"href\":\"" + href + "\","
+                        + "\"relationship\":\"H2020\""
+                        + "}")
+                .withRelatedItem(item.getID().toString())
+                .build();
+        QAEvent eventMoreEndorsement = QAEventBuilder.createTarget(context, col1, "Science and Freedom with project")
+            .withSource(COAR_NOTIFY_SOURCE)
+            .withTopic("ENRICH/MORE/ENDORSEMENT")
+            .withMessage(
+                    "{"
+                    + "\"serviceName\":\"" + notifyServiceEntity.getName() + "\","
+                    + "\"serviceId\":\"" + notifyServiceEntity.getID() + "\","
+                    + "\"href\":\"" + href + "\","
+                    + "\"relationship\":\"H2020\""
+                    + "}")
+            .withRelatedItem(item.getID().toString())
+            .build();
+        context.restoreAuthSystemState();
+        List<Operation> acceptOp = new ArrayList<Operation>();
+        acceptOp.add(new ReplaceOperation("/status", QAEvent.ACCEPTED));
+        String patchAccept = getPatchContent(acceptOp);
+        String authToken = getAuthToken(admin.getEmail(), password);
+        eventMoreEndorsement.setStatus(QAEvent.ACCEPTED);
+        eventMoreReview.setStatus(QAEvent.ACCEPTED);
+        // MORE REVIEW
+        getClient(authToken).perform(patch("/api/integration/qualityassuranceevents/" + eventMoreReview.getEventId())
+            .content(patchAccept)
+            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventNotifyEntry(eventMoreReview)));
+        getClient(authToken).perform(get("/api/core/items/" + eventMoreReview.getTarget())
+            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+        .andExpect(status().isOk())
+        .andExpect(jsonPath("$",
+                hasJsonPath("$.metadata",
+                        MetadataMatcher.matchMetadata(AddReviewMetadataAction.getMetadata(), href))));
+        // MORE ENDORSEMENT
+        getClient(authToken).perform(patch("/api/integration/qualityassuranceevents/"
+            + eventMoreEndorsement.getEventId())
+            .content(patchAccept)
+            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventNotifyEntry(eventMoreEndorsement)));
+
+        getClient(authToken).perform(get("/api/core/items/" + eventMoreEndorsement.getTarget())
+            .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+        .andExpect(status().isOk())
+        .andExpect(jsonPath("$",
+                hasJsonPath("$.metadata",
+                        MetadataMatcher.matchMetadata(AddEndorsedMetadataAction.getMetadata(), href))));
+
+    }
+
+    @Test
+    public void setRelatedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        Collection colFunding = CollectionBuilder.createCollection(context, parentCommunity)
+                .withName("Collection Fundings").build();
+        QAEvent event = QAEventBuilder.createTarget(context, col1, "Science and Freedom 5")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PROJECT)
+                .withMessage(
+                        "{\"projects[0].acronym\":\"PAThs\","
+                        + "\"projects[0].code\":\"687567\","
+                        + "\"projects[0].funder\":\"EC\","
+                        + "\"projects[0].fundingProgram\":\"H2020\","
+                        + "\"projects[0].jurisdiction\":\"EU\","
+                        + "\"projects[0].openaireId\":\"40|corda__h2020::6e32f5eb912688f2424c68b851483ea4\","
+                        + "\"projects[0].title\":\"Tracking Papyrus and Parchment Paths: "
+                        + "An Archaeological Atlas of Coptic Literature."
+                        + "\\nLiterary Texts in their Geographical Context: Production, Copying, Usage, "
+                        + "Dissemination and Storage\"}")
+                .build();
+        Item funding = ItemBuilder.createItem(context, colFunding).withTitle("Tracking Papyrus and Parchment Paths")
+                .build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/integration/qualityassuranceevents/" + event.getEventId()).param("projection", "full"))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventFullEntry(event)));
+
+        getClient(authToken)
+            .perform(post("/api/integration/qualityassuranceevents/" + event.getEventId() + "/related").param("item",
+                        funding.getID().toString()))
+                .andExpect(status().isCreated())
+                .andExpect(jsonPath("$", ItemMatcher.matchItemProperties(funding)));
+        // update our local event copy to reflect the association with the related item
+        event.setRelated(funding.getID().toString());
+        getClient(authToken)
+            .perform(get("/api/integration/qualityassuranceevents/" + event.getEventId()).param("projection", "full"))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventFullEntry(event)));
+        getClient(authToken)
+            .perform(get("/api/integration/qualityassuranceevents/" + event.getEventId() + "/related"))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$", ItemMatcher.matchItemProperties(funding)));
+    }
+
+    @Test
+    public void unsetRelatedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        Collection colFunding = CollectionBuilder.createCollection(context, parentCommunity)
+                .withName("Collection Fundings").build();
+        Item funding = ItemBuilder.createItem(context, colFunding).withTitle("Tracking Papyrus and Parchment Paths")
+                .build();
+        QAEvent event = QAEventBuilder.createTarget(context, col1, "Science and Freedom 5")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PROJECT)
+                .withMessage(
+                        "{\"projects[0].acronym\":\"PAThs\","
+                        + "\"projects[0].code\":\"687567\","
+                        + "\"projects[0].funder\":\"EC\","
+                        + "\"projects[0].fundingProgram\":\"H2020\","
+                        + "\"projects[0].jurisdiction\":\"EU\","
+                        + "\"projects[0].openaireId\":\"40|corda__h2020::6e32f5eb912688f2424c68b851483ea4\","
+                        + "\"projects[0].title\":\"Tracking Papyrus and Parchment Paths: "
+                        + "An Archaeological Atlas of Coptic Literature."
+                        + "\\nLiterary Texts in their Geographical Context: Production, Copying, Usage, "
+                        + "Dissemination and Storage\"}")
+                .withRelatedItem(funding.getID().toString())
+                .build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/integration/qualityassuranceevents/" + event.getEventId()).param("projection", "full"))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventFullEntry(event)));
+        getClient(authToken)
+            .perform(delete("/api/integration/qualityassuranceevents/" + event.getEventId() + "/related"))
+                .andExpect(status().isNoContent());
+
+        // update our local event copy to reflect the association with the related item
+        event.setRelated(null);
+        getClient(authToken)
+            .perform(get("/api/integration/qualityassuranceevents/" + event.getEventId()).param("projection", "full"))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventFullEntry(event)));
+        getClient(authToken)
+            .perform(get("/api/integration/qualityassuranceevents/" + event.getEventId() + "/related"))
+            .andExpect(status().isNoContent());
+    }
+
+    @Test
+    public void setInvalidRelatedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        Collection colFunding = CollectionBuilder.createCollection(context, parentCommunity)
+                .withName("Collection Fundings").build();
+        QAEvent event = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}").build();
+        Item funding = ItemBuilder.createItem(context, colFunding).withTitle("Tracking Papyrus and Parchment Paths")
+                .build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+            .perform(get("/api/integration/qualityassuranceevents/" + event.getEventId()).param("projection", "full"))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventFullEntry(event)));
+
+        getClient(authToken)
+            .perform(post("/api/integration/qualityassuranceevents/" + event.getEventId() + "/related").param("item",
+                        funding.getID().toString()))
+                .andExpect(status().isUnprocessableEntity());
+        // check that no related item has been added to our event
+        getClient(authToken)
+            .perform(get("/api/integration/qualityassuranceevents/" + event.getEventId()).param("projection", "full"))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$", QAEventMatcher.matchQAEventFullEntry(event)));
+    }
+
+    @Test
+    public void deleteItemWithEventTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity)
+                                           .withName("Collection 1")
+                                           .build();
+        QAEvent event1 = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                                       .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                                       .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}")
+                                       .build();
+        QAEvent event2 = QAEventBuilder.createTarget(context, col1, "Science and Freedom 2")
+                                       .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                                       .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144301\"}")
+                                       .build();
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/search/findByTopic")
+                            .param("topic", OPENAIRE_SOURCE + ":" + "ENRICH!MISSING!PID"))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(2)))
+                            .andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.containsInAnyOrder(
+                                       QAEventMatcher.matchQAEventEntry(event1),
+                                       QAEventMatcher.matchQAEventEntry(event2)
+                                       )))
+                            .andExpect(jsonPath("$.page.size", is(20)))
+                            .andExpect(jsonPath("$.page.totalElements", is(2)));
+
+        getClient(authToken).perform(delete("/api/core/items/" + event1.getTarget()))
+                            .andExpect(status().is(204));
+
+        getClient(authToken).perform(get("/api/core/items/" + event1.getTarget()))
+                            .andExpect(status().is(404));
+
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/search/findByTopic")
+                            .param("topic", OPENAIRE_SOURCE + ":" + "ENRICH!MISSING!PID"))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.hasSize(1)))
+                            .andExpect(jsonPath("$._embedded.qualityassuranceevents", Matchers.containsInAnyOrder(
+                                       QAEventMatcher.matchQAEventEntry(event2)
+                                       )))
+                            .andExpect(jsonPath("$.page.size", is(20)))
+                            .andExpect(jsonPath("$.page.totalElements", is(1)));
+    }
+
+    @Test
+    public void testEventDeletion() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        parentCommunity = CommunityBuilder.createCommunity(context)
+            .withName("Parent Community")
+            .build();
+
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity)
+            .withName("Collection 1")
+            .build();
+
+        QAEvent event = QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+            .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+            .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}")
+            .build();
+
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+            .withTopic("ENRICH/MISSING/PID")
+            .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}")
+            .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event.getEventId()))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventEntry(event)));
+
+        List<QAEventProcessed> processedEvents = qaEventsDao.findAll(context);
+        assertThat(processedEvents, empty());
+
+        getClient(authToken).perform(delete("/api/integration/qualityassuranceevents/" + event.getEventId()))
+            .andExpect(status().isNoContent());
+
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event.getEventId()))
+            .andExpect(status().isNotFound());
+
+        processedEvents = qaEventsDao.findAll(context);
+        assertThat(processedEvents, hasSize(1));
+
+        QAEventProcessed processedEvent = processedEvents.get(0);
+        assertThat(processedEvent.getEventId(), is(event.getEventId()));
+        assertThat(processedEvent.getItem(), notNullValue());
+        assertThat(processedEvent.getItem().getID().toString(), is(event.getTarget()));
+        assertThat(processedEvent.getEventTimestamp(), notNullValue());
+        assertThat(processedEvent.getEperson().getID(), is(admin.getID()));
+    }
+
+    @Test
+    public void createQAEventByCorrectionTypeUnAuthorizedTest() throws Exception {
+        getClient().perform(post("/api/integration/qualityassuranceevents")
+                   .param("correctionType", "request-withdrawn")
+                   .param("target", UUID.randomUUID().toString())
+                   .contentType(contentType))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void createQAEventByCorrectionTypeWithMissingTargetTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(post("/api/integration/qualityassuranceevents")
+                             .param("correctionType", "request-withdrawn")
+                             .contentType(contentType))
+                             .andExpect(status().isUnprocessableEntity());
+    }
+
+    @Test
+    public void createQAEventsAndIgnoreAutomaticallyByScoreAndFilterTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        Item item = ItemBuilder.createItem(context, col1).withTitle("demo").build();
+
+        QAEvent event =
+            QAEventBuilder.createTarget(context, item)
+                          .withSource(COAR_NOTIFY_SOURCE)
+                          .withTrust(0.4)
+                          .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_REVIEW)
+                          .withMessage("{\"abstracts[0]\": \"https://doi.org/10.3214/987654\"}")
+                          .build();
+
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+
+        getClient(authToken).perform(get("/api/core/items/" + item.getID()))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.metadata['datacite.relation.isReviewedBy']").doesNotExist());
+
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event.getEventId()))
+                            .andExpect(status().isNotFound());
+    }
+
+    @Test
+    public void createQAEventsAndRejectAutomaticallyByScoreAndFilterTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        Item item = ItemBuilder.createItem(context, col1).withTitle("demo").build();
+
+        QAEvent event =
+            QAEventBuilder.createTarget(context, item)
+                          .withSource(COAR_NOTIFY_SOURCE)
+                          .withTrust(0.3)
+                          .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_REVIEW)
+                          .withMessage("{\"abstracts[0]\": \"https://doi.org/10.3214/987654\"}")
+                          .build();
+
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+
+        getClient(authToken).perform(get("/api/core/items/" + item.getID()))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.metadata['datacite.relation.isReviewedBy']").doesNotExist());
+
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event.getEventId()))
+                            .andExpect(status().isNotFound());
+    }
+
+    @Test
+    public void createQAEventsAndDoNothingScoreNotInRangTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        Item item = ItemBuilder.createItem(context, col1).withTitle("demo").build();
+
+        QAEvent event =
+            QAEventBuilder.createTarget(context, item)
+                          .withSource(COAR_NOTIFY_SOURCE)
+                          .withTrust(0.7)
+                          .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_REVIEW)
+                          .withMessage("{\"abstracts[0]\": \"https://doi.org/10.3214/987654\"}")
+                          .build();
+
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+
+        getClient(authToken).perform(get("/api/core/items/" + item.getID()))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.metadata['datacite.relation.isReviewedBy']").doesNotExist());
+
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event.getEventId())
+                                .param("projection", "full"))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventFullEntry(event)));
+    }
+
+    @Test
+    public void createQAEventsAndDoNothingFilterNotCompatibleWithItemTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        Item item = ItemBuilder.createItem(context, col1).withTitle("item title").build();
+
+        QAEvent event =
+            QAEventBuilder.createTarget(context, item)
+                          .withSource(COAR_NOTIFY_SOURCE)
+                          .withTrust(0.8)
+                          .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_REVIEW)
+                          .withMessage("{\"abstracts[0]\": \"https://doi.org/10.3214/987654\"}")
+                          .build();
+
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+
+        getClient(authToken).perform(get("/api/core/items/" + item.getID()))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.metadata['datacite.relation.isReviewedBy']").doesNotExist());
+
+        getClient(authToken).perform(get("/api/integration/qualityassuranceevents/" + event.getEventId())
+                                .param("projection", "full"))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", QAEventMatcher.matchQAEventFullEntry(event)));
+    }
+
+
+    @Test
+    public void createQAEventByCorrectionTypeWithdrawnRequestTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        configurationService.setProperty(WITHDRAWAL_REINSTATE_GROUP, "Anonymous");
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+
+        Collection col = CollectionBuilder.createCollection(context, parentCommunity)
+                                          .withName("Collection for Publications")
+                                          .withEntityType("Publication")
+                                          .build();
+
+        Item publication = ItemBuilder.createItem(context, col)
+                                      .withTitle("Publication archived item")
+                                      .build();
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/core/items/" + publication.getID()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.inArchive", is(true)))
+                             .andExpect(jsonPath("$.withdrawn", is(false)));
+
+        AtomicReference<String> idRef = new AtomicReference<String>();
+
+        CorrectionTypeMessageDTO message = new CorrectionTypeMessageDTO("reasone");
+
+        String ePersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(ePersonToken).perform(post("/api/integration/qualityassuranceevents")
+                               .param("correctionType", "request-withdrawn")
+                               .param("target", publication.getID().toString())
+                               .content(new ObjectMapper().writeValueAsBytes(message))
+                               .contentType(contentType))
+                               .andExpect(status().isCreated())
+                               .andDo(result -> idRef.set(read(result.getResponse().getContentAsString(), "$.id")));
+
+        getClient(adminToken).perform(get("/api/integration/qualityassuranceevents/" + idRef.get()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.id", is(idRef.get())))
+                             .andExpect(jsonPath("$.source", is(DSPACE_USERS_SOURCE)))
+                             .andExpect(jsonPath("$.title", is(publication.getName())))
+                             .andExpect(jsonPath("$.topic", is("REQUEST/WITHDRAWN")))
+                             .andExpect(jsonPath("$.trust", is("1.000")))
+                             .andExpect(jsonPath("$.status", is("PENDING")));
+
+        getClient(adminToken).perform(get("/api/core/items/" + publication.getID()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.inArchive", is(true)))
+                             .andExpect(jsonPath("$.withdrawn", is(false)));
+
+        List<Operation> acceptOp = new ArrayList<Operation>();
+        acceptOp.add(new ReplaceOperation("/status", QAEvent.ACCEPTED));
+
+        getClient(adminToken).perform(patch("/api/integration/qualityassuranceevents/" + idRef.get())
+                             .content(getPatchContent(acceptOp))
+                             .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                             .andExpect(status().isOk());
+
+        getClient(adminToken).perform(get("/api/core/items/" + publication.getID()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.inArchive", is(false)))
+                             .andExpect(jsonPath("$.withdrawn", is(true)));
+    }
+
+    @Test
+    public void createQAEventByCorrectionTypeReinstateRequestTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        configurationService.setProperty(WITHDRAWAL_REINSTATE_GROUP, "Anonymous");
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+
+        Collection col = CollectionBuilder.createCollection(context, parentCommunity)
+                                          .withName("Collection for Publications")
+                                          .withEntityType("Publication")
+                                          .build();
+
+        Item publication = ItemBuilder.createItem(context, col)
+                                      .withTitle("Publication archived item")
+                                      .withdrawn()
+                                      .build();
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        String ePersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(adminToken).perform(get("/api/core/items/" + publication.getID()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.inArchive", is(false)))
+                             .andExpect(jsonPath("$.withdrawn", is(true)));
+
+        AtomicReference<String> idRef = new AtomicReference<String>();
+
+        ObjectMapper mapper = new ObjectMapper();
+        CorrectionTypeMessageDTO dto = new CorrectionTypeMessageDTO("provided reason!");
+
+        getClient(ePersonToken).perform(post("/api/integration/qualityassuranceevents")
+                               .param("correctionType", "request-reinstate")
+                               .param("target", publication.getID().toString())
+                               .contentType(contentType)
+                               .content(mapper.writeValueAsBytes(dto)))
+                               .andExpect(status().isCreated())
+                               .andDo(result -> idRef.set(read(result.getResponse().getContentAsString(), "$.id")));
+
+        getClient(adminToken).perform(get("/api/integration/qualityassuranceevents/" + idRef.get()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.id", is(idRef.get())))
+                             .andExpect(jsonPath("$.source", is(DSPACE_USERS_SOURCE)))
+                             .andExpect(jsonPath("$.title", is(publication.getName())))
+                             .andExpect(jsonPath("$.topic", is("REQUEST/REINSTATE")))
+                             .andExpect(jsonPath("$.trust", is("1.000")))
+                             .andExpect(jsonPath("$.status", is("PENDING")));
+
+        getClient(adminToken).perform(get("/api/core/items/" + publication.getID()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.inArchive", is(false)))
+                             .andExpect(jsonPath("$.withdrawn", is(true)));
+
+        List<Operation> acceptOp = new ArrayList<Operation>();
+        acceptOp.add(new ReplaceOperation("/status", QAEvent.ACCEPTED));
+
+        getClient(adminToken).perform(patch("/api/integration/qualityassuranceevents/" + idRef.get())
+                             .content(getPatchContent(acceptOp))
+                             .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                             .andExpect(status().isOk());
+
+        getClient(adminToken).perform(get("/api/core/items/" + publication.getID()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.inArchive", is(true)))
+                             .andExpect(jsonPath("$.withdrawn", is(false)));
+    }
+
+    @Test
+    public void createQAEventOnlyUserPresentInWithdrawalReinstateGroupTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        EPerson user1 = EPersonBuilder.createEPerson(context)
+                                      .withEmail("eperson-test@mail.com")
+                                      .withPassword(password)
+                                      .build();
+
+        Group withdrawalGroup = GroupBuilder.createGroup(context)
+                                            .withName("WithdrawGroup")
+                                            .addMember(user1)
+                                            .build();
+
+        configurationService.setProperty(WITHDRAWAL_REINSTATE_GROUP, withdrawalGroup.getName());
+
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+
+        Collection col = CollectionBuilder.createCollection(context, parentCommunity)
+                                          .withName("Collection for Publications")
+                                          .withEntityType("Publication")
+                                          .build();
+
+        Item publication = ItemBuilder.createItem(context, col)
+                                      .withTitle("Publication archived item")
+                                      .build();
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        AtomicReference<String> idRef = new AtomicReference<String>();
+
+        CorrectionTypeMessageDTO message = new CorrectionTypeMessageDTO("reasone");
+
+        String ePersonToken = getAuthToken(eperson.getEmail(), password);
+        // eperson is not present into the withdraw-reinstate group
+        // and so cannot make the request
+        getClient(ePersonToken).perform(post("/api/integration/qualityassuranceevents")
+                               .param("correctionType", "request-withdrawn")
+                               .param("target", publication.getID().toString())
+                               .content(new ObjectMapper().writeValueAsBytes(message))
+                               .contentType(contentType))
+                               .andExpect(status().isUnprocessableEntity());
+
+        String user1Token = getAuthToken(user1.getEmail(), password);
+        // instead user1 is present into the withdraw-reinstate group
+        getClient(user1Token).perform(post("/api/integration/qualityassuranceevents")
+                             .param("correctionType", "request-withdrawn")
+                             .param("target", publication.getID().toString())
+                             .content(new ObjectMapper().writeValueAsBytes(message))
+                             .contentType(contentType))
+                             .andExpect(status().isCreated())
+                             .andDo(result -> idRef.set(read(result.getResponse().getContentAsString(), "$.id")));
+
+        getClient(adminToken).perform(get("/api/integration/qualityassuranceevents/" + idRef.get()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.id", is(idRef.get())))
+                             .andExpect(jsonPath("$.source", is(DSPACE_USERS_SOURCE)))
+                             .andExpect(jsonPath("$.title", is(publication.getName())))
+                             .andExpect(jsonPath("$.topic", is("REQUEST/WITHDRAWN")))
+                             .andExpect(jsonPath("$.trust", is("1.000")))
+                             .andExpect(jsonPath("$.status", is("PENDING")));
+
+        getClient(adminToken).perform(get("/api/core/items/" + publication.getID()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.inArchive", is(true)))
+                             .andExpect(jsonPath("$.withdrawn", is(false)));
+
+        List<Operation> acceptOp = new ArrayList<Operation>();
+        acceptOp.add(new ReplaceOperation("/status", QAEvent.ACCEPTED));
+
+        getClient(adminToken).perform(patch("/api/integration/qualityassuranceevents/" + idRef.get())
+                             .content(getPatchContent(acceptOp))
+                             .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                             .andExpect(status().isOk());
+
+        getClient(adminToken).perform(get("/api/core/items/" + publication.getID()))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$.inArchive", is(false)))
+                             .andExpect(jsonPath("$.withdrawn", is(true)));
+    }
+
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/QASourceRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/QASourceRestRepositoryIT.java
new file mode 100644
index 0000000000..71b87d460a
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/QASourceRestRepositoryIT.java
@@ -0,0 +1,349 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static org.dspace.app.rest.matcher.QASourceMatcher.matchQASourceEntry;
+import static org.dspace.qaevent.service.impl.QAEventServiceImpl.QAEVENTS_SOURCES;
+import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.is;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import org.dspace.app.rest.repository.QASourceRestRepository;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.QAEventBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Community;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.services.ConfigurationService;
+import org.junit.Before;
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Integration tests for {@link QASourceRestRepository}.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+public class QASourceRestRepositoryIT extends AbstractControllerIntegrationTest {
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    private Item target;
+
+    @Before
+    public void setup() {
+        context.turnOffAuthorisationSystem();
+
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withTitle("Community")
+                                          .build();
+
+        Collection collection = CollectionBuilder.createCollection(context, parentCommunity)
+                                                 .withName("Collection")
+                                                 .build();
+
+        target = ItemBuilder.createItem(context, collection)
+                            .withTitle("Item")
+                            .build();
+
+        context.restoreAuthSystemState();
+
+        configurationService.setProperty(QAEVENTS_SOURCES,
+                new String[] { QAEvent.OPENAIRE_SOURCE,"coar-notify", "test-source","test-source-2" });
+    }
+
+    @Test
+    public void testFindAll() throws Exception {
+        context.turnOffAuthorisationSystem();
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/1", "Title 1");
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/2", "Title 2");
+        context.setCurrentUser(eperson);
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/2", "Title 3");
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/2", "Title 4");
+
+        createEvent("test-source", "TOPIC/TEST/1", "Title 5");
+        createEvent("test-source", "TOPIC/TEST/1", "Title 6");
+        createEvent("coar-notify", "TOPIC", "Title 7");
+        context.setCurrentUser(eperson);
+        createEvent("coar-notify", "TOPIC", "Title 8");
+        createEvent("coar-notify", "TOPIC", "Title 9");
+        context.setCurrentUser(null);
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassurancesources"))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$._embedded.qualityassurancesources", contains(
+                matchQASourceEntry(QAEvent.OPENAIRE_SOURCE, 4),
+                matchQASourceEntry("coar-notify", 3),
+                matchQASourceEntry("test-source", 2),
+                matchQASourceEntry("test-source-2", 0))))
+            .andExpect(jsonPath("$.page.size", is(20)))
+            .andExpect(jsonPath("$.page.totalElements", is(4)));
+
+        // check with our eperson submitter
+        authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassurancesources"))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$._embedded.qualityassurancesources", contains(
+                matchQASourceEntry("coar-notify", 3))))
+            .andExpect(jsonPath("$.page.size", is(20)))
+            .andExpect(jsonPath("$.page.totalElements", is(1)));
+    }
+
+    @Test
+    public void testFindAllUnauthorized() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/1", "Title 1");
+        createEvent("test-source", "TOPIC/TEST/1", "Title 4");
+
+        context.restoreAuthSystemState();
+
+        getClient().perform(get("/api/integration/qualityassurancesources"))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void testFindOne() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+        Community com = CommunityBuilder.createCommunity(context).withName("Test community").build();
+        Collection col = CollectionBuilder.createCollection(context, com).withName("Test collection").build();
+
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/1", "Title 1");
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/2", "Title 2");
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/2", "Title 3");
+
+        createEvent("test-source", "TOPIC/TEST/1", "Title 4");
+        createEvent("test-source", "TOPIC/TEST/1", "Title 5");
+        context.setCurrentUser(admin);
+        Item target1 = ItemBuilder.createItem(context, col).withTitle("Title 7").build();
+        createEvent(QAEvent.COAR_NOTIFY_SOURCE, "TOPIC", target1);
+        context.setCurrentUser(eperson);
+        createEvent(QAEvent.COAR_NOTIFY_SOURCE, "TOPIC", "Title 8");
+        createEvent(QAEvent.COAR_NOTIFY_SOURCE, "TOPIC", "Title 9");
+        context.setCurrentUser(null);
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassurancesources/openaire"))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$", matchQASourceEntry(QAEvent.OPENAIRE_SOURCE, 3)));
+
+        getClient(authToken).perform(get("/api/integration/qualityassurancesources/coar-notify"))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$", matchQASourceEntry("coar-notify", 3)));
+
+
+        getClient(authToken).perform(get("/api/integration/qualityassurancesources/test-source"))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$", matchQASourceEntry("test-source", 2)));
+
+        getClient(authToken).perform(get("/api/integration/qualityassurancesources/test-source-2"))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$", matchQASourceEntry("test-source-2", 0)));
+
+        getClient(authToken).perform(get("/api/integration/qualityassurancesources/unknown-test-source"))
+            .andExpect(status().isNotFound());
+
+        authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassurancesources/openaire"))
+            .andExpect(status().isForbidden());
+        getClient(authToken).perform(get("/api/integration/qualityassurancesources/unknown-test-source"))
+            .andExpect(status().isForbidden());
+        // the eperson will see only 2 events in coar-notify as 1 is related to an item was submitted by other
+        getClient(authToken).perform(get("/api/integration/qualityassurancesources/coar-notify"))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$", matchQASourceEntry("coar-notify", 2)));
+
+
+    }
+
+    @Test
+    public void testFindOneForbidden() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/1", "Title 1");
+        createEvent("test-source", "TOPIC/TEST/1", "Title 4");
+
+        context.restoreAuthSystemState();
+
+        String token = getAuthToken(eperson.getEmail(), password);
+        getClient(token).perform(get("/api/integration/qualityassurancesources/openaire"))
+            .andExpect(status().isForbidden());
+
+    }
+
+    @Test
+    public void testFindOneUnauthorized() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/1", "Title 1");
+        createEvent("test-source", "TOPIC/TEST/1", "Title 4");
+
+        context.restoreAuthSystemState();
+
+        getClient().perform(get("/api/integration/qualityassurancesources/openaire"))
+            .andExpect(status().isUnauthorized());
+
+    }
+
+    @Test
+    public void testFindAllByTarget() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+        Community com = CommunityBuilder.createCommunity(context).withName("Test community").build();
+        Collection col = CollectionBuilder.createCollection(context, com).withName("Test collection").build();
+        Item target1 = ItemBuilder.createItem(context, col).withTitle("Test item1").build();
+        Item target2 = ItemBuilder.createItem(context, col).withTitle("Test item2").build();
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/1", target1);
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/2", target1);
+        createEvent("test-source", "TOPIC/TEST/1", target1);
+        createEvent("test-source", "TOPIC/TEST/1", target2);
+
+        context.setCurrentUser(eperson);
+        Item target3 = ItemBuilder.createItem(context, col).withTitle("Test item3").build();
+        context.setCurrentUser(null);
+        createEvent(QAEvent.COAR_NOTIFY_SOURCE, "TOPIC", target3);
+        createEvent(QAEvent.COAR_NOTIFY_SOURCE, "TOPIC2", target3);
+        createEvent(QAEvent.COAR_NOTIFY_SOURCE, "TOPIC", target2);
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+                .perform(get("/api/integration/qualityassurancesources/search/byTarget").param("target",
+                        target1.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.qualityassurancesources",
+                        contains(matchQASourceEntry(QAEvent.OPENAIRE_SOURCE + ":" + target1.getID().toString(), 2),
+                                matchQASourceEntry("test-source:" + target1.getID().toString(), 1))))
+                .andExpect(jsonPath("$.page.size", is(20)))
+                .andExpect(jsonPath("$.page.totalElements", is(2)));
+
+        getClient(authToken)
+                .perform(get("/api/integration/qualityassurancesources/search/byTarget").param("target",
+                        target2.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.qualityassurancesources",
+                        contains(
+                                matchQASourceEntry(QAEvent.COAR_NOTIFY_SOURCE + ":" + target2.getID().toString(), 1),
+                                matchQASourceEntry("test-source:" + target2.getID().toString(), 1))))
+                .andExpect(jsonPath("$.page.size", is(20)))
+                .andExpect(jsonPath("$.page.totalElements", is(2)));
+        getClient(authToken)
+                .perform(get("/api/integration/qualityassurancesources/search/byTarget").param("target",
+                        target3.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.qualityassurancesources",
+                    contains(matchQASourceEntry("coar-notify:" + target3.getID().toString(), 2))))
+                .andExpect(jsonPath("$.page.size", is(20)))
+                .andExpect(jsonPath("$.page.totalElements", is(1)));
+
+        // check with our eperson submitter
+        authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken)
+                .perform(get("/api/integration/qualityassurancesources/search/byTarget").param("target",
+                        target1.getID().toString()))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$.page.size", is(20)))
+                .andExpect(jsonPath("$.page.totalElements", is(0)));
+        getClient(authToken)
+                .perform(get("/api/integration/qualityassurancesources/search/byTarget").param("target",
+                        target2.getID().toString()))
+                .andExpect(status().isOk())
+                .andExpect(jsonPath("$.page.size", is(20)))
+                .andExpect(jsonPath("$.page.totalElements", is(1)));
+        getClient(authToken)
+                .perform(get("/api/integration/qualityassurancesources/search/byTarget").param("target",
+                        target3.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.qualityassurancesources",
+                        contains(matchQASourceEntry("coar-notify:" + target3.getID().toString(), 2))))
+                .andExpect(jsonPath("$.page.size", is(20)))
+                .andExpect(jsonPath("$.page.totalElements", is(1)));
+    }
+
+    @Test
+    public void testFindByTargetBadRequest() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+        Community com = CommunityBuilder.createCommunity(context).withName("Test community").build();
+        Collection col = CollectionBuilder.createCollection(context, com).withName("Test collection").build();
+        Item target1 = ItemBuilder.createItem(context, col).withTitle("Test item1").build();
+        Item target2 = ItemBuilder.createItem(context, col).withTitle("Test item2").build();
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/1", target1);
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/2", target1);
+        createEvent("test-source", "TOPIC/TEST/1", target1);
+        createEvent("test-source", "TOPIC/TEST/1", target2);
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken)
+                .perform(get("/api/integration/qualityassurancesources/search/byTarget"))
+                .andExpect(status().isBadRequest());
+    }
+
+
+    @Test
+    public void testFindByTargetUnauthorized() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+        Community com = CommunityBuilder.createCommunity(context).withName("Test community").build();
+        Collection col = CollectionBuilder.createCollection(context, com).withName("Test collection").build();
+        Item target1 = ItemBuilder.createItem(context, col).withTitle("Test item1").build();
+        Item target2 = ItemBuilder.createItem(context, col).withTitle("Test item2").build();
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/1", target1);
+        createEvent(QAEvent.OPENAIRE_SOURCE, "TOPIC/OPENAIRE/2", target1);
+        createEvent("test-source", "TOPIC/TEST/1", target1);
+        createEvent("test-source", "TOPIC/TEST/1", target2);
+
+        context.restoreAuthSystemState();
+
+        getClient()
+                .perform(get("/api/integration/qualityassurancesources/search/byTarget").param("target",
+                        target1.getID().toString()))
+                .andExpect(status().isUnauthorized());
+    }
+
+    private QAEvent createEvent(String source, String topic, String title) {
+        return QAEventBuilder.createTarget(context, target)
+            .withSource(source)
+            .withTopic(topic)
+            .withTitle(title)
+            .build();
+    }
+
+    private QAEvent createEvent(String source, String topic, Item item) {
+        return QAEventBuilder.createTarget(context, item)
+            .withSource(source)
+            .withTopic(topic)
+            .withTitle(item.getName())
+            .build();
+    }
+
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/QATopicRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/QATopicRestRepositoryIT.java
new file mode 100644
index 0000000000..7534df6c96
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/QATopicRestRepositoryIT.java
@@ -0,0 +1,477 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static org.dspace.content.QAEvent.OPENAIRE_SOURCE;
+import static org.dspace.qaevent.service.impl.QAEventServiceImpl.QAEVENTS_SOURCES;
+import static org.hamcrest.Matchers.is;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import java.util.UUID;
+
+import org.dspace.app.rest.matcher.QATopicMatcher;
+import org.dspace.app.rest.repository.QATopicRestRepository;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.QAEventBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Item;
+import org.dspace.content.QAEvent;
+import org.dspace.qaevent.QANotifyPatterns;
+import org.dspace.services.ConfigurationService;
+import org.hamcrest.Matchers;
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Integration tests for {@link QATopicRestRepository}.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class QATopicRestRepositoryIT extends AbstractControllerIntegrationTest {
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+    @Test
+    public void findAllNotImplementedTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/integration/qualityassurancetopics"))
+                             .andExpect(status().isMethodNotAllowed());
+    }
+
+    @Test
+    public void findOneTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        configurationService.setProperty(QAEVENTS_SOURCES, new String[] { OPENAIRE_SOURCE, "test-source" });
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity)
+                                           .withName("Collection 1")
+                                           .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                      .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                      .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}")
+                      .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 2")
+                      .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                      .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144301\"}")
+                      .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 3")
+                      .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_PID)
+                      .withMessage("{\"pids[0].type\":\"pmid\",\"pids[0].value\":\"10.2307/2144302\"}")
+                      .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 4")
+                      .withTopic(org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT)
+                      .withMessage("{\"test\": \"Test...\"}")
+                      .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 4")
+                      .withSource("test-source")
+                      .withTopic("TOPIC/TEST")
+                      .withMessage("{\"abstracts[0]\": \"Descrizione delle caratteristiche...\"}")
+                      .build();
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(
+                              get("/api/integration/qualityassurancetopics/" + OPENAIRE_SOURCE + ":ENRICH!MISSING!PID"))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$", QATopicMatcher.matchQATopicEntry(
+                                                      QANotifyPatterns.TOPIC_ENRICH_MISSING_PID, 2)));
+
+        getClient(adminToken).perform(get("/api/integration/qualityassurancetopics/"
+                                          + OPENAIRE_SOURCE + ":ENRICH!MISSING!ABSTRACT"))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$", QATopicMatcher.matchQATopicEntry(
+                                                      QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 1)));
+
+        getClient(adminToken).perform(get("/api/integration/qualityassurancetopics/test-source:TOPIC!TEST"))
+                             .andExpect(status().isOk())
+                             .andExpect(jsonPath("$",QATopicMatcher.matchQATopicEntry("test-source", "TOPIC/TEST", 1)));
+    }
+
+    @Test
+    public void findOneNotFoundTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        configurationService.setProperty("qaevent.sources",
+                new String[] { QAEvent.OPENAIRE_SOURCE });
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                .withName("Parent Community")
+                .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}").build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        // using a wrong id
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/ENRICH!MISSING!PID"))
+                .andExpect(status().isNotFound());
+        // using a plausible id related to an unknown source
+        getClient(authToken)
+                .perform(get("/api/integration/qualityassurancetopics/unknown-source:ENRICH!MISSING!ABSTRACT"))
+                .andExpect(status().isNotFound());
+        // using a not existing topic
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/openaire:not-existing-topic"))
+                .andExpect(status().isNotFound());
+    }
+
+    @Test
+    public void findOneUnauthorizedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                .withName("Parent Community")
+                .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID).build();
+        context.restoreAuthSystemState();
+        getClient().perform(get("/api/integration/qualityassurancetopics/openaire:ENRICH!MISSING!PID"))
+                .andExpect(status().isUnauthorized());
+        getClient().perform(get("/api/integration/qualityassurancetopics/openaire:ENRICH!MISSING!ABSTRACT"))
+                .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findOneForbiddenTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                .withName("Parent Community")
+                .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID).build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/openaire:ENRICH!MISSING!PID"))
+            .andExpect(status().isForbidden());
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/openaire:ENRICH!MISSING!ABSTRACT"))
+            .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findBySourceTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        configurationService.setProperty(QAEVENTS_SOURCES, new String[] {
+                                         OPENAIRE_SOURCE, "test-source", "test-source-2" });
+
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity)
+                                           .withName("Collection 1")
+                                           .build();
+
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                      .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                      .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}")
+                      .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 2")
+                      .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                      .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144301\"}")
+                      .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 3")
+                      .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_PID)
+                      .withMessage("{\"pids[0].type\":\"pmid\",\"pids[0].value\":\"10.2307/2144302\"}")
+                      .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 4")
+                      .withTopic(org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT)
+                      .withMessage("{\"abstracts[0]\": \"Descrizione delle caratteristiche...\"}")
+                      .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 5")
+                      .withTopic("TEST/TOPIC")
+                      .withSource("test-source")
+                      .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 6")
+                      .withTopic("TEST/TOPIC")
+                      .withSource("test-source")
+                      .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 7")
+                      .withTopic("TEST/TOPIC/2")
+                      .withSource("test-source")
+                      .build();
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/bySource")
+                            .param("source", OPENAIRE_SOURCE))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$._embedded.qualityassurancetopics",
+                Matchers.containsInAnyOrder(
+                    QATopicMatcher.matchQATopicEntry(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID, 2),
+                                QATopicMatcher.matchQATopicEntry(QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT, 1),
+                                QATopicMatcher.matchQATopicEntry(QANotifyPatterns.TOPIC_ENRICH_MORE_PID, 1)
+                                )))
+                            .andExpect(jsonPath("$.page.size", is(20)))
+                            .andExpect(jsonPath("$.page.totalElements", is(3)));
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/bySource")
+                            .param("source", "test-source"))
+                            .andExpect(status().isOk())
+                            .andExpect(content().contentType(contentType))
+                            .andExpect(jsonPath("$._embedded.qualityassurancetopics", Matchers.containsInAnyOrder(
+                                       QATopicMatcher.matchQATopicEntry("test-source", "TEST/TOPIC/2", 1),
+                                       QATopicMatcher.matchQATopicEntry("test-source", "TEST/TOPIC", 2)
+                                       )))
+                            .andExpect(jsonPath("$.page.size", is(20)))
+                            .andExpect(jsonPath("$.page.totalElements", is(2)));
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/bySource")
+                            .param("source", "test-source-2"))
+                            .andExpect(status().isOk())
+                            .andExpect(content().contentType(contentType))
+                            .andExpect(jsonPath("$._embedded.qualityassurancetopics").doesNotExist())
+                            .andExpect(jsonPath("$.page.size", is(20)))
+                            .andExpect(jsonPath("$.page.totalElements", is(0)));
+    }
+
+    @Test
+    public void findBySourcePaginationTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        configurationService.setProperty("qaevent.sources",
+                new String[] { QAEvent.OPENAIRE_SOURCE, "test-source", "test-source-2" });
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                .withName("Parent Community")
+                .build();
+        //create collection
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+            .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+            .withSource(QAEvent.OPENAIRE_SOURCE)
+            .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 2")
+            .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+            .withSource(QAEvent.OPENAIRE_SOURCE)
+            .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144301\"}").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 3")
+            .withTopic(QANotifyPatterns.TOPIC_ENRICH_MORE_PID)
+            .withSource(QAEvent.OPENAIRE_SOURCE)
+            .withMessage("{\"pids[0].type\":\"pmid\",\"pids[0].value\":\"10.2307/2144302\"}").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 4")
+            .withTopic(org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT)
+            .withSource(QAEvent.OPENAIRE_SOURCE)
+            .withMessage(
+                "{\"abstracts[0]\": \"Descrizione delle caratteristiche...\"}")
+            .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 5")
+            .withTopic("TEST/TOPIC")
+            .withSource("test-source")
+            .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 6")
+            .withTopic("TEST/TOPIC")
+            .withSource("test-source")
+            .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom 7")
+            .withTopic("TEST/TOPIC/2")
+            .withSource("test-source")
+            .build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/bySource")
+                    .param("source", QAEvent.OPENAIRE_SOURCE)
+                    .param("size", "2"))
+                .andExpect(status().isOk())
+                .andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.qualityassurancetopics", Matchers.hasSize(2)))
+                .andExpect(jsonPath("$.page.size", is(2))).andExpect(jsonPath("$.page.totalElements", is(3)));
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/bySource")
+                    .param("source", QAEvent.OPENAIRE_SOURCE)
+                    .param("size", "2")
+                    .param("page", "1"))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$._embedded.qualityassurancetopics", Matchers.hasSize(1)))
+            .andExpect(jsonPath("$.page.size", is(2))).andExpect(jsonPath("$.page.totalElements", is(3)));
+       //test unsupported
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/bySource")
+                .param("source", "test-source")
+                .param("size", "2"))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$._embedded").doesNotExist())
+            .andExpect(jsonPath("$.page.size", is(2))).andExpect(jsonPath("$.page.totalElements", is(0)));
+    }
+
+    @Test
+    public void findBySourceUnauthorizedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                         .withName("Parent Community")
+                                         .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity)
+                                           .withName("Collection 1")
+                                           .build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+                      .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+                      .build();
+        context.restoreAuthSystemState();
+
+        getClient().perform(get("/api/integration/qualityassurancetopics/search/bySource")
+                   .param("source", OPENAIRE_SOURCE))
+                   .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findBySourceForbiddenTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context)
+            .withName("Parent Community")
+            .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        QAEventBuilder.createTarget(context, col1, "Science and Freedom")
+            .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID).build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/bySource")
+            .param("source", QAEvent.OPENAIRE_SOURCE))
+            .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findByTargetTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        configurationService.setProperty("qaevent.sources",
+            new String[] { QAEvent.OPENAIRE_SOURCE, "test-source", "test-source-2" });
+        parentCommunity = CommunityBuilder.createCommunity(context)
+            .withName("Parent Community")
+            .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        Item item1 = ItemBuilder.createItem(context, col1).withTitle("Science and Freedom").build();
+        Item item2 = ItemBuilder.createItem(context, col1).withTitle("Science and Freedom 2").build();
+        QAEventBuilder.createTarget(context, item1)
+            .withSource(QAEvent.OPENAIRE_SOURCE)
+            .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+            .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144300\"}").build();
+        QAEventBuilder.createTarget(context, item1)
+            .withSource(QAEvent.OPENAIRE_SOURCE)
+            .withTopic(org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT)
+            .withMessage(
+                "{\"abstracts[0]\": \"Descrizione delle caratteristiche...\"}")
+            .build();
+        QAEventBuilder.createTarget(context, item1)
+            .withTopic("TEST/TOPIC")
+            .withSource("test-source")
+            .build();
+        QAEventBuilder.createTarget(context, item1)
+            .withTopic("TEST/TOPIC/2")
+            .withSource("test-source")
+            .build();
+        QAEventBuilder.createTarget(context, item2)
+            .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+            .withMessage("{\"pids[0].type\":\"doi\",\"pids[0].value\":\"10.2307/2144301\"}").build();
+        QAEventBuilder.createTarget(context, item2)
+            .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID)
+            .withMessage("{\"pids[0].type\":\"pmid\",\"pids[0].value\":\"2144301\"}").build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(admin.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/byTarget")
+                .param("target", item1.getID().toString())
+                .param("source", QAEvent.OPENAIRE_SOURCE))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$._embedded.qualityassurancetopics",
+                        Matchers.containsInAnyOrder(
+                                QATopicMatcher.matchQATopicEntry(QAEvent.OPENAIRE_SOURCE,
+                                    QANotifyPatterns.TOPIC_ENRICH_MISSING_PID,
+                                        item1.getID().toString(), 1),
+                                QATopicMatcher.matchQATopicEntry(QAEvent.OPENAIRE_SOURCE,
+                                    QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT,
+                                    item1.getID().toString(), 1))))
+            .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(2)));
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/byTarget")
+                .param("target", item2.getID().toString())
+                .param("source", QAEvent.OPENAIRE_SOURCE))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$._embedded.qualityassurancetopics",
+                    Matchers.containsInAnyOrder(
+                            QATopicMatcher.matchQATopicEntry(QAEvent.OPENAIRE_SOURCE,
+                                QANotifyPatterns.TOPIC_ENRICH_MISSING_PID,
+                                    item2.getID().toString(), 2))))
+            .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(1)));
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/byTarget")
+            .param("target", UUID.randomUUID().toString())
+            .param("source", QAEvent.OPENAIRE_SOURCE))
+            .andExpect(status().isOk())
+            .andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$._embedded.qualityassurancetopics").doesNotExist())
+            .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(0)));
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/byTarget")
+                .param("target", item2.getID().toString())
+                .param("source", "test-source"))
+                .andExpect(status().isOk())
+                .andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.qualityassurancetopics").doesNotExist())
+                .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(0)));
+
+    }
+
+    @Test
+    public void findByTargetZeroEventsOpenaireTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context)
+            .withName("Parent Community")
+            .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        Item item1 = ItemBuilder.createItem(context, col1).withTitle("Science and Freedom").build();
+        QAEventBuilder.createTarget(context, item1)
+            .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID).build();
+        context.restoreAuthSystemState();
+        getClient().perform(get("/api/integration/qualityassurancetopics/search/byTarget")
+                .param("source", QAEvent.OPENAIRE_SOURCE)
+                .param("target", item1.getID().toString()))
+                .andExpect(jsonPath("$.page.totalElements", is(0)));
+    }
+
+    @Test
+    public void findByTargetZeroEventsAnotherSourceTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context)
+            .withName("Parent Community")
+            .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        Item item1 = ItemBuilder.createItem(context, col1).withTitle("Science and Freedom").build();
+        QAEventBuilder.createTarget(context, item1)
+            .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID).build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/byTarget")
+            .param("target", item1.getID().toString())
+            .param("source", "test-source"))
+            .andExpect(jsonPath("$.page.totalElements", is(0)));
+    }
+
+    @Test
+    public void findByTargetBadRequest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context)
+            .withName("Parent Community")
+            .build();
+        Collection col1 = CollectionBuilder.createCollection(context, parentCommunity).withName("Collection 1").build();
+        Item item1 = ItemBuilder.createItem(context, col1).withTitle("Science and Freedom").build();
+        QAEventBuilder.createTarget(context, item1)
+            .withSource("test-source")
+            .withTopic(QANotifyPatterns.TOPIC_ENRICH_MISSING_PID).build();
+        context.restoreAuthSystemState();
+        String authToken = getAuthToken(eperson.getEmail(), password);
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/byTarget")
+            .param("source", "test-source"))
+            .andExpect(status().isBadRequest());
+        getClient(authToken).perform(get("/api/integration/qualityassurancetopics/search/byTarget")
+                .param("target", item1.getID().toString()))
+                .andExpect(status().isBadRequest());
+    }
+
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/SubmissionCOARNotifyRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/SubmissionCOARNotifyRestRepositoryIT.java
new file mode 100644
index 0000000000..b2d4a06606
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/SubmissionCOARNotifyRestRepositoryIT.java
@@ -0,0 +1,81 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import java.util.List;
+
+import org.dspace.app.rest.matcher.SubmissionCOARNotifyMatcher;
+import org.dspace.app.rest.repository.SubmissionCoarNotifyRestRepository;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.coarnotify.NotifyPattern;
+import org.hamcrest.Matchers;
+import org.junit.Test;
+
+/**
+ * Integration test class for {@link SubmissionCoarNotifyRestRepository}.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class SubmissionCOARNotifyRestRepositoryIT extends AbstractControllerIntegrationTest {
+
+    @Test
+    public void findAllTestUnAuthorized() throws Exception {
+        getClient().perform(get("/api/config/submissioncoarnotifyconfigs"))
+                .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findAllTest() throws Exception {
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+
+        getClient(epersonToken).perform(get("/api/config/submissioncoarnotifyconfigs"))
+                .andExpect(status().isOk())
+                .andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.submissioncoarnotifyconfigs", Matchers.containsInAnyOrder(
+                        SubmissionCOARNotifyMatcher.matchCOARNotifyEntry("coarnotify", List.of(
+                            new NotifyPattern("request-review", true),
+                            new NotifyPattern("request-endorsement", true),
+                            new NotifyPattern("request-ingest", false)))
+                )));
+    }
+
+    @Test
+    public void findOneTestUnAuthorized() throws Exception {
+        getClient().perform(get("/api/config/submissioncoarnotifyconfigs/coarnotify"))
+                .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findOneTestNonExistingCOARNotify() throws Exception {
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+
+        getClient(epersonToken).perform(get("/api/config/submissioncoarnotifyconfigs/non-existing-coar"))
+                .andExpect(status().isNotFound());
+    }
+
+    @Test
+    public void findOneTest() throws Exception {
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+
+        getClient(epersonToken).perform(get("/api/config/submissioncoarnotifyconfigs/coarnotify"))
+                .andExpect(status().isOk())
+                .andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$", Matchers.is(
+                        SubmissionCOARNotifyMatcher.matchCOARNotifyEntry("coarnotify", List.of(
+                            new NotifyPattern("request-review", true),
+                            new NotifyPattern("request-endorsement", true),
+                            new NotifyPattern("request-ingest", false)))
+                )));
+    }
+
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/SubmissionDefinitionsControllerIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/SubmissionDefinitionsControllerIT.java
index babb1fac23..41c8f081b6 100644
--- a/dspace-server-webapp/src/test/java/org/dspace/app/rest/SubmissionDefinitionsControllerIT.java
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/SubmissionDefinitionsControllerIT.java
@@ -205,7 +205,7 @@ public class SubmissionDefinitionsControllerIT extends AbstractControllerIntegra
                    // We expect the content type to be "application/hal+json;charset=UTF-8"
                    .andExpect(content().contentType(contentType))
                    // Match only that a section exists with a submission configuration behind
-                   .andExpect(jsonPath("$._embedded.submissionsections", hasSize(9)))
+                   .andExpect(jsonPath("$._embedded.submissionsections", hasSize(10)))
                    .andExpect(jsonPath("$._embedded.submissionsections",
                                        Matchers.hasItem(
                                            allOf(
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/SuggestionRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/SuggestionRestRepositoryIT.java
new file mode 100644
index 0000000000..a883516adc
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/SuggestionRestRepositoryIT.java
@@ -0,0 +1,475 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.dspace.app.rest.matcher.SuggestionMatcher.matchSuggestion;
+import static org.dspace.builder.SuggestionTargetBuilder.EVIDENCE_MOCK_NAME;
+import static org.dspace.builder.SuggestionTargetBuilder.EVIDENCE_MOCK_NOTE;
+import static org.hamcrest.Matchers.is;
+import static org.springframework.data.rest.webmvc.RestMediaTypes.TEXT_URI_LIST_VALUE;
+import static org.springframework.http.MediaType.parseMediaType;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.delete;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import java.util.Map;
+import java.util.UUID;
+
+import com.fasterxml.jackson.databind.ObjectMapper;
+import org.dspace.app.rest.matcher.MetadataMatcher;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.app.suggestion.MockSuggestionExternalDataSource;
+import org.dspace.app.suggestion.SuggestionTarget;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.SuggestionTargetBuilder;
+import org.dspace.builder.WorkspaceItemBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Item;
+import org.hamcrest.Matchers;
+import org.junit.Before;
+import org.junit.Test;
+import org.springframework.test.web.servlet.MvcResult;
+
+/**
+ * Integration Tests against the /api/integration/suggestions endpoint
+ */
+public class SuggestionRestRepositoryIT extends AbstractControllerIntegrationTest {
+    private Collection colPeople;
+
+    @Override
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        // We turn off the authorization system in order to create the structure as
+        // defined below
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        colPeople = CollectionBuilder.createCollection(context, parentCommunity).withName("People")
+                .withEntityType("Person").build();
+        context.restoreAuthSystemState();
+    }
+
+    @Test
+    public void findAllTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstScopus = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("scopus", 3).build();
+        context.restoreAuthSystemState();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/integration/suggestions"))
+                .andExpect(status().isMethodNotAllowed());
+        String token = getAuthToken(eperson.getEmail(), password);
+        getClient(token).perform(get("/api/integration/suggestions")).andExpect(status().isMethodNotAllowed());
+        getClient().perform(get("/api/integration/suggestions")).andExpect(status().isMethodNotAllowed());
+    }
+
+    @Test
+    public void findByTargetAndSourceTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 31).build();
+        SuggestionTarget targetFirstScopus = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("scopus", 3).build();
+        SuggestionTarget targetSecond = SuggestionTargetBuilder
+                .createTarget(context, colPeople, "Digilio, Giuseppe", eperson).withSuggestionCount("reciter", 11)
+                .build();
+        context.restoreAuthSystemState();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestions/search/findByTargetAndSource").param("source", "scopus")
+                        .param("target", itemFirst.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestions", Matchers.contains(
+                        matchSuggestion("scopus", itemFirst, "Suggestion scopus 1", "1",
+                                100.0, EVIDENCE_MOCK_NAME, 100.0, EVIDENCE_MOCK_NOTE),
+                        matchSuggestion("scopus", itemFirst, "Suggestion scopus 3", "3",
+                                98.0, EVIDENCE_MOCK_NAME, 98.0, EVIDENCE_MOCK_NOTE),
+                        matchSuggestion("scopus", itemFirst, "Suggestion scopus 2", "2",
+                                0.5, EVIDENCE_MOCK_NAME, 0.5, EVIDENCE_MOCK_NOTE))))
+                .andExpect(jsonPath("$._links.self.href", Matchers.allOf(
+                        Matchers.containsString(
+                                "/api/integration/suggestions/search/findByTargetAndSource?"),
+                        Matchers.containsString("source=scopus"),
+                        Matchers.containsString("target=" + itemFirst.getID().toString()))))
+                .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(3)));
+        Item itemSecond = targetSecond.getTarget();
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestions/search/findByTargetAndSource").param("source", "reciter")
+                        .param("target", itemSecond.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestions", Matchers.containsInAnyOrder(
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 1", "1"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 2", "2"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 3", "3"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 4", "4"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 5", "5"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 6", "6"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 7", "7"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 8", "8"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 9", "9"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 10", "10"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 11", "11"))))
+                .andExpect(jsonPath("$._links.self.href", Matchers.allOf(
+                        Matchers.containsString(
+                                "/api/integration/suggestions/search/findByTargetAndSource?"),
+                        Matchers.containsString("source=reciter"),
+                        Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(11)));
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(epersonToken)
+                .perform(get("/api/integration/suggestions/search/findByTargetAndSource").param("source", "reciter")
+                        .param("target", itemSecond.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestions", Matchers.containsInAnyOrder(
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 1", "1"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 2", "2"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 3", "3"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 4", "4"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 5", "5"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 6", "6"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 7", "7"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 8", "8"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 9", "9"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 10", "10"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 11", "11"))))
+                .andExpect(jsonPath("$._links.self.href", Matchers.allOf(
+                        Matchers.containsString(
+                                "/api/integration/suggestions/search/findByTargetAndSource?"),
+                        Matchers.containsString("source=reciter"),
+                        Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(11)));
+    }
+
+    @Test
+    public void findByTargetAndSourcePaginationTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        SuggestionTarget targetSecond = SuggestionTargetBuilder
+                .createTarget(context, colPeople, "Digilio, Giuseppe", eperson).withSuggestionCount("reciter", 11)
+                .build();
+        context.restoreAuthSystemState();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        Item itemSecond = targetSecond.getTarget();
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestions/search/findByTargetAndSource").param("source", "reciter")
+                        .param("size", "5")
+                        .param("target", itemSecond.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestions", Matchers.contains(
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 1", "1"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 3", "3"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 5", "5"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 7", "7"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 9", "9"))))
+                .andExpect(jsonPath("$._links.self.href", Matchers.allOf(
+                        Matchers.containsString(
+                                "/api/integration/suggestions/search/findByTargetAndSource?"),
+                        Matchers.containsString("source=reciter"),
+                        Matchers.containsString("size=5"),
+                        Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.next.href",
+                        Matchers.allOf(
+                                Matchers.containsString(
+                                        "/api/integration/suggestions/search/findByTargetAndSource?"),
+                                Matchers.containsString("source=reciter"),
+                                Matchers.containsString("page=1"),
+                                Matchers.containsString("size=5"),
+                                Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString(
+                                        "/api/integration/suggestions/search/findByTargetAndSource?"),
+                                Matchers.containsString("source=reciter"),
+                                Matchers.containsString("page=2"),
+                                Matchers.containsString("size=5"),
+                                Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString(
+                                        "/api/integration/suggestions/search/findByTargetAndSource?"),
+                                Matchers.containsString("source=reciter"),
+                                Matchers.containsString("page=0"),
+                                Matchers.containsString("size=5"),
+                                Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.prev.href").doesNotExist())
+                .andExpect(jsonPath("$.page.size", is(5))).andExpect(jsonPath("$.page.totalElements", is(11)));
+
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestions/search/findByTargetAndSource").param("source", "reciter")
+                        .param("size", "5")
+                        .param("page", "1")
+                        .param("target", itemSecond.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestions", Matchers.contains(
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 11", "11"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 10", "10"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 8", "8"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 6", "6"),
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 4", "4"))))
+                .andExpect(jsonPath("$._links.self.href", Matchers.allOf(
+                        Matchers.containsString(
+                                "/api/integration/suggestions/search/findByTargetAndSource?"),
+                        Matchers.containsString("source=reciter"),
+                        Matchers.containsString("page=1"),
+                        Matchers.containsString("size=5"),
+                        Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.next.href",
+                        Matchers.allOf(
+                                Matchers.containsString(
+                                        "/api/integration/suggestions/search/findByTargetAndSource?"),
+                                Matchers.containsString("source=reciter"),
+                                Matchers.containsString("page=2"),
+                                Matchers.containsString("size=5"),
+                                Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.prev.href",
+                        Matchers.allOf(
+                                Matchers.containsString(
+                                        "/api/integration/suggestions/search/findByTargetAndSource?"),
+                                Matchers.containsString("source=reciter"),
+                                Matchers.containsString("page=0"),
+                                Matchers.containsString("size=5"),
+                                Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString(
+                                        "/api/integration/suggestions/search/findByTargetAndSource?"),
+                                Matchers.containsString("source=reciter"),
+                                Matchers.containsString("page=2"),
+                                Matchers.containsString("size=5"),
+                                Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString(
+                                        "/api/integration/suggestions/search/findByTargetAndSource?"),
+                                Matchers.containsString("source=reciter"),
+                                Matchers.containsString("page=0"),
+                                Matchers.containsString("size=5"),
+                                Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$.page.size", is(5))).andExpect(jsonPath("$.page.totalElements", is(11)));
+
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestions/search/findByTargetAndSource").param("source", "reciter")
+                        .param("size", "5")
+                        .param("page", "2")
+                        .param("target", itemSecond.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestions", Matchers.contains(
+                        matchSuggestion("reciter", itemSecond, "Suggestion reciter 2", "2"))))
+                .andExpect(jsonPath("$._links.self.href", Matchers.allOf(
+                        Matchers.containsString(
+                                "/api/integration/suggestions/search/findByTargetAndSource?"),
+                        Matchers.containsString("source=reciter"),
+                        Matchers.containsString("page=2"),
+                        Matchers.containsString("size=5"),
+                        Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.prev.href",
+                        Matchers.allOf(
+                                Matchers.containsString(
+                                        "/api/integration/suggestions/search/findByTargetAndSource?"),
+                                Matchers.containsString("source=reciter"),
+                                Matchers.containsString("page=1"),
+                                Matchers.containsString("size=5"),
+                                Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString(
+                                        "/api/integration/suggestions/search/findByTargetAndSource?"),
+                                Matchers.containsString("source=reciter"),
+                                Matchers.containsString("page=2"),
+                                Matchers.containsString("size=5"),
+                                Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString(
+                                        "/api/integration/suggestions/search/findByTargetAndSource?"),
+                                Matchers.containsString("source=reciter"),
+                                Matchers.containsString("page=0"),
+                                Matchers.containsString("size=5"),
+                                Matchers.containsString("target=" + itemSecond.getID().toString()))))
+                .andExpect(jsonPath("$._links.next.href").doesNotExist())
+                .andExpect(jsonPath("$.page.size", is(5))).andExpect(jsonPath("$.page.totalElements", is(11)));
+    }
+
+    @Test
+    public void findByTargetAndSourceNotAdminTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 31).build();
+        SuggestionTarget targetFirstScopus = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("scopus", 3).build();
+        SuggestionTarget targetSecond = SuggestionTargetBuilder
+                .createTarget(context, colPeople, "Digilio, Giuseppe", eperson).withSuggestionCount("reciter", 11)
+                .build();
+        context.restoreAuthSystemState();
+        // anonymous cannot access the suggestions source endpoint
+        getClient()
+                .perform(get("/api/integration/suggestions/search/findByTargetAndSource")
+                        .param("target", UUID.randomUUID().toString()).param("source", "reciter"))
+                .andExpect(status().isUnauthorized());
+        // nor normal user
+        String tokenEperson = getAuthToken(eperson.getEmail(), password);
+        getClient(tokenEperson)
+                .perform(get("/api/integration/suggestions/search/findByTargetAndSource")
+                        .param("target", UUID.randomUUID().toString()).param("source", "reciter"))
+                .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findOneTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 31).build();
+        SuggestionTarget targetFirstScopus = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("scopus", 3).build();
+        //targetSecond refers to eperson
+        SuggestionTarget targetSecond = SuggestionTargetBuilder
+                .createTarget(context, colPeople, "Digilio, Giuseppe", eperson).withSuggestionCount("reciter", 11)
+                .build();
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        String suggestionId = "reciter:" + itemFirst.getID().toString() + ":6";
+        getClient(adminToken).perform(get("/api/integration/suggestions/" + suggestionId)).andExpect(status().isOk())
+                .andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$", matchSuggestion("reciter", itemFirst, "Suggestion reciter 6", "6")))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.endsWith("/api/integration/suggestions/" + suggestionId)));
+        //test targetSecond refers to eperson
+        Item itemSecond = targetSecond.getTarget();
+        String epersonSuggestionId = "reciter:" + itemSecond.getID().toString() + ":2";
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(epersonToken).perform(get("/api/integration/suggestions/" + epersonSuggestionId))
+                .andExpect(status().isOk())
+                .andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$", matchSuggestion("reciter", itemSecond, "Suggestion reciter 2", "2")))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.endsWith("/api/integration/suggestions/" + epersonSuggestionId)));
+    }
+
+    @Test
+    public void findOneNotAdminTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 31).build();
+        SuggestionTarget targetFirstScopus = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("scopus", 3).build();
+        SuggestionTarget targetSecond = SuggestionTargetBuilder
+                .createTarget(context, colPeople, "Digilio, Giuseppe", eperson).withSuggestionCount("reciter", 11)
+                .build();
+        context.restoreAuthSystemState();
+
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+        String suggestionId = "reciter:" + itemFirst.getID().toString() + ":6";
+        getClient(epersonToken).perform(get("/api/integration/suggestions/" + suggestionId))
+                .andExpect(status().isForbidden());
+        getClient(epersonToken).perform(get("/api/integration/suggestions/not-exist"))
+                .andExpect(status().isForbidden());
+        getClient().perform(get("/api/integration/suggestions/" + suggestionId)).andExpect(status().isUnauthorized());
+        getClient().perform(get("/api/integration/suggestions/not-exist")).andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void acceptSuggestionTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Collection colPublications = CollectionBuilder.createCollection(context, parentCommunity)
+                .withName("Publications").build();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 2).build();
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        String suggestionId = "reciter:" + itemFirst.getID().toString() + ":1";
+        // the suggestion is here
+        getClient(adminToken).perform(get("/api/integration/suggestions/" + suggestionId)).andExpect(status().isOk())
+                .andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$", matchSuggestion("reciter", itemFirst, "Suggestion reciter 1", "1")))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.endsWith("/api/integration/suggestions/" + suggestionId)));
+        Integer workspaceItemId = null;
+        try {
+            ObjectMapper mapper = new ObjectMapper();
+            MvcResult mvcResult = getClient(adminToken).perform(
+                    post("/api/submission/workspaceitems?owningCollection=" + colPublications.getID().toString())
+                            .contentType(parseMediaType(TEXT_URI_LIST_VALUE))
+                            .content("http://localhost/api/integration/externalsources/"
+                                    + MockSuggestionExternalDataSource.NAME + "/entryValues/" + suggestionId))
+                    .andExpect(status().isCreated()).andReturn();
+            String content = mvcResult.getResponse().getContentAsString();
+            Map<String,Object> map = mapper.readValue(content, Map.class);
+            workspaceItemId = (Integer) map.get("id");
+            String itemUuidString = String.valueOf(((Map) ((Map) map.get("_embedded")).get("item")).get("uuid"));
+
+            getClient(adminToken).perform(get("/api/submission/workspaceitems/" + workspaceItemId))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$", Matchers.allOf(
+                                hasJsonPath("$.id", is(workspaceItemId)),
+                                hasJsonPath("$.type", is("workspaceitem")),
+                                hasJsonPath("$._embedded.item", Matchers.allOf(
+                                    hasJsonPath("$.id", is(itemUuidString)),
+                                    hasJsonPath("$.uuid", is(itemUuidString)),
+                                    hasJsonPath("$.type", is("item")),
+                                    hasJsonPath("$.metadata", Matchers.allOf(
+                                        MetadataMatcher.matchMetadata("dc.title", "Title Suggestion 1")
+                                    )))))
+                            ));
+
+            getClient(adminToken).perform(get("/api/integration/suggestions/" + suggestionId))
+                    .andExpect(status().isNotFound());
+            // 1 suggestion is still pending
+            getClient(adminToken)
+                .perform(get("/api/integration/suggestions/search/findByTargetAndSource").param("source", "reciter")
+                        .param("target", itemFirst.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestions", Matchers.contains(
+                        matchSuggestion("reciter", itemFirst, "Suggestion reciter 2", "2"))))
+                .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(1)));
+        } finally {
+            if (workspaceItemId != null) {
+                WorkspaceItemBuilder.deleteWorkspaceItem(workspaceItemId);
+            }
+        }
+    }
+
+    @Test
+    public void rejectSuggestionTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Collection colPublications = CollectionBuilder.createCollection(context, parentCommunity)
+                .withName("Publications").build();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 2).build();
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        String suggestionId = "reciter:" + itemFirst.getID().toString() + ":1";
+        // reject the suggestion
+        getClient(adminToken).perform(delete("/api/integration/suggestions/" + suggestionId))
+                       .andExpect(status().isNoContent());
+        getClient(adminToken).perform(get("/api/integration/suggestions/" + suggestionId))
+                .andExpect(status().isNotFound());
+        // 1 suggestion is still pending
+        getClient(adminToken)
+            .perform(get("/api/integration/suggestions/search/findByTargetAndSource").param("source", "reciter")
+                    .param("target", itemFirst.getID().toString()))
+            .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+            .andExpect(jsonPath("$._embedded.suggestions", Matchers.contains(
+                    matchSuggestion("reciter", itemFirst, "Suggestion reciter 2", "2"))))
+            .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(1)));
+    }
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/SuggestionSourceRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/SuggestionSourceRestRepositoryIT.java
new file mode 100644
index 0000000000..30a1779fbd
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/SuggestionSourceRestRepositoryIT.java
@@ -0,0 +1,168 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static org.dspace.app.rest.matcher.SuggestionSourceMatcher.matchSuggestionSource;
+import static org.hamcrest.Matchers.is;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.app.suggestion.SuggestionTarget;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.SuggestionTargetBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Item;
+import org.hamcrest.Matchers;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Integration Tests against the /api/integration/suggestionsources endpoint
+ */
+public class SuggestionSourceRestRepositoryIT extends AbstractControllerIntegrationTest {
+    private Collection colPeople;
+
+    @Override
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        // We turn off the authorization system in order to create the structure as
+        // defined below
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        colPeople = CollectionBuilder.createCollection(context, parentCommunity).withName("People")
+                .withEntityType("Person").build();
+        context.restoreAuthSystemState();
+    }
+
+    /**
+     * Build a list of suggestion target, Bollini, Andrea has suggestion from both
+     * sources, Digilio, Giuseppe only from reciter Test 0, 3, 6 from both sources,
+     * Test 1, 2, 4, 5 only from ReCiter and finally Lombardi, Corrado only from
+     * scopus
+     */
+    private void buildSuggestionTargetsList() {
+        // We turn off the authorization system in order to create the structure as
+        // defined below
+        context.turnOffAuthorisationSystem();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 31).build();
+        SuggestionTarget targetFirstScopus = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("scopus", 3).build();
+        SuggestionTarget targetSecond = SuggestionTargetBuilder
+                .createTarget(context, colPeople, "Digilio, Giuseppe", eperson).withSuggestionCount("reciter", 11)
+                .build();
+        for (int idx = 0; idx < 8; idx++) {
+            Item item = ItemBuilder.createItem(context, colPeople).withTitle("Test " + idx).build();
+            SuggestionTargetBuilder.createTarget(context, item).withSuggestionCount("reciter", idx + 3).build();
+            if (idx % 3 == 0) {
+                SuggestionTargetBuilder.createTarget(context, item).withSuggestionCount("scopus", idx + 7).build();
+            }
+        }
+        Item itemLast = ItemBuilder.createItem(context, colPeople).withTitle("Lombardi, Corrado").build();
+        SuggestionTarget targetLast = SuggestionTargetBuilder.createTarget(context, itemLast)
+                .withSuggestionCount("scopus", 3).build();
+        context.restoreAuthSystemState();
+    }
+
+    @Test
+    public void findAllTest() throws Exception {
+        buildSuggestionTargetsList();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/integration/suggestionsources")).andExpect(status().isOk())
+                .andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestionsources",
+                        Matchers.contains(matchSuggestionSource("reciter", 10), matchSuggestionSource("scopus", 5))))
+                .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(2)));
+    }
+
+    @Test
+    public void findAllPaginationTest() throws Exception {
+        buildSuggestionTargetsList();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/integration/suggestionsources").param("size", "1"))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestionsources",
+                        Matchers.contains(matchSuggestionSource("reciter", 10))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.containsString("/api/integration/suggestionsources")))
+                .andExpect(jsonPath("$._links.next.href",
+                        Matchers.allOf(Matchers.containsString("/api/integration/suggestionsources?"),
+                                Matchers.containsString("page=1"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(Matchers.containsString("/api/integration/suggestionsources?"),
+                                Matchers.containsString("page=1"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(Matchers.containsString("/api/integration/suggestionsources?"),
+                                Matchers.containsString("page=0"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.prev.href").doesNotExist()).andExpect(jsonPath("$.page.size", is(1)))
+                .andExpect(jsonPath("$.page.totalElements", is(2)));
+        getClient(adminToken).perform(get("/api/integration/suggestionsources").param("size", "1").param("page", "1"))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestionsources",
+                        Matchers.contains(matchSuggestionSource("scopus", 5))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.containsString("/api/integration/suggestionsources")))
+                .andExpect(jsonPath("$._links.next.href").doesNotExist())
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(Matchers.containsString("/api/integration/suggestionsources?"),
+                                Matchers.containsString("page=1"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(Matchers.containsString("/api/integration/suggestionsources?"),
+                                Matchers.containsString("page=0"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.prev.href",
+                        Matchers.allOf(Matchers.containsString("/api/integration/suggestionsources?"),
+                                Matchers.containsString("page=0"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$.page.size", is(1))).andExpect(jsonPath("$.page.totalElements", is(2)));
+    }
+
+    @Test
+    public void findAllNotAdminTest() throws Exception {
+        buildSuggestionTargetsList();
+        // anonymous cannot access the suggestions source endpoint
+        getClient().perform(get("/api/integration/suggestionsources")).andExpect(status().isUnauthorized());
+        // nor normal user
+        String tokenEperson = getAuthToken(eperson.getEmail(), password);
+        getClient(tokenEperson).perform(get("/api/integration/suggestionsources")).andExpect(status().isForbidden());
+
+    }
+
+    @Test
+    public void findOneTest() throws Exception {
+        buildSuggestionTargetsList();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/integration/suggestionsources/reciter")).andExpect(status().isOk())
+                .andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$", matchSuggestionSource("reciter", 10))).andExpect(jsonPath("$._links.self.href",
+                        Matchers.endsWith("/api/integration/suggestionsources/reciter")));
+        getClient(adminToken).perform(get("/api/integration/suggestionsources/scopus")).andExpect(status().isOk())
+                .andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$", matchSuggestionSource("scopus", 5))).andExpect(
+                        jsonPath("$._links.self.href", Matchers.endsWith("/api/integration/suggestionsources/scopus")));
+
+    }
+
+    @Test
+    public void findOneNotAdminTest() throws Exception {
+        buildSuggestionTargetsList();
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(epersonToken).perform(get("/api/integration/suggestionsources/reciter"))
+                .andExpect(status().isForbidden());
+        getClient(epersonToken).perform(get("/api/integration/suggestionsources/not-exist"))
+                .andExpect(status().isForbidden());
+        getClient().perform(get("/api/integration/suggestionsources/reciter")).andExpect(status().isUnauthorized());
+        getClient().perform(get("/api/integration/suggestionsources/not-exist")).andExpect(status().isUnauthorized());
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/SuggestionTargetRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/SuggestionTargetRestRepositoryIT.java
new file mode 100644
index 0000000000..21108010f5
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/SuggestionTargetRestRepositoryIT.java
@@ -0,0 +1,597 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest;
+
+import static org.dspace.app.rest.matcher.SuggestionTargetMatcher.matchSuggestionTarget;
+import static org.hamcrest.Matchers.is;
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.content;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import java.util.UUID;
+
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.app.suggestion.SuggestionTarget;
+import org.dspace.builder.CollectionBuilder;
+import org.dspace.builder.CommunityBuilder;
+import org.dspace.builder.EPersonBuilder;
+import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.SuggestionTargetBuilder;
+import org.dspace.content.Collection;
+import org.dspace.content.Item;
+import org.dspace.eperson.EPerson;
+import org.hamcrest.Matchers;
+import org.junit.Before;
+import org.junit.Test;
+
+/**
+ * Integration Tests against the /api/integration/suggestiontargets endpoint
+ */
+public class SuggestionTargetRestRepositoryIT extends AbstractControllerIntegrationTest {
+    private Collection colPeople;
+
+    @Override
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        // We turn off the authorization system in order to create the structure as
+        // defined below
+        context.turnOffAuthorisationSystem();
+        parentCommunity = CommunityBuilder.createCommunity(context).withName("Parent Community").build();
+        colPeople = CollectionBuilder.createCollection(context, parentCommunity).withName("People")
+                .withEntityType("Person").build();
+        context.restoreAuthSystemState();
+    }
+
+    /**
+     * Build a list of suggestion target, Bollini, Andrea has suggestion from both
+     * sources, Digilio, Giuseppe only from reciter Test 0, 3, 6 from both sources,
+     * Test 1, 2, 4, 5 only from ReCiter and finally Lombardi, Corrado only from
+     * scopus
+     */
+    private void buildSuggestionTargetsList() {
+        // We turn off the authorization system in order to create the structure as
+        // defined below
+        context.turnOffAuthorisationSystem();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 31).build();
+        SuggestionTarget targetFirstScopus = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("scopus", 3).build();
+        SuggestionTarget targetSecond = SuggestionTargetBuilder
+                .createTarget(context, colPeople, "Digilio, Giuseppe", eperson).withSuggestionCount("reciter", 11)
+                .build();
+        for (int idx = 0; idx < 8; idx++) {
+            Item item = ItemBuilder.createItem(context, colPeople).withTitle("Test " + idx).build();
+            SuggestionTargetBuilder.createTarget(context, item).withSuggestionCount("reciter", idx + 3).build();
+            if (idx % 3 == 0) {
+                SuggestionTargetBuilder.createTarget(context, item).withSuggestionCount("scopus", idx + 7).build();
+            }
+        }
+        Item itemLast = ItemBuilder.createItem(context, colPeople).withTitle("Lombardi, Corrado").build();
+        SuggestionTarget targetLast = SuggestionTargetBuilder.createTarget(context, itemLast)
+                .withSuggestionCount("scopus", 3).build();
+        context.restoreAuthSystemState();
+    }
+
+    @Test
+    public void findAllTest() throws Exception {
+        buildSuggestionTargetsList();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/integration/suggestiontargets"))
+                .andExpect(status().isMethodNotAllowed());
+        String token = getAuthToken(eperson.getEmail(), password);
+        getClient(token).perform(get("/api/integration/suggestiontargets")).andExpect(status().isMethodNotAllowed());
+        getClient().perform(get("/api/integration/suggestiontargets")).andExpect(status().isMethodNotAllowed());
+    }
+
+    @Test
+    public void findBySourceTest() throws Exception {
+        buildSuggestionTargetsList();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findBySource").param("source", "reciter"))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets", Matchers.contains(
+                        matchSuggestionTarget("Bollini, Andrea", "reciter", 31),
+                        matchSuggestionTarget("Digilio, Giuseppe", "reciter", 11),
+                        matchSuggestionTarget("Test 7", "reciter", 10), matchSuggestionTarget("Test 6", "reciter", 9),
+                        matchSuggestionTarget("Test 5", "reciter", 8), matchSuggestionTarget("Test 4", "reciter", 7),
+                        matchSuggestionTarget("Test 3", "reciter", 6), matchSuggestionTarget("Test 2", "reciter", 5),
+                        matchSuggestionTarget("Test 1", "reciter", 4), matchSuggestionTarget("Test 0", "reciter", 3)
+                        )))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.containsString(
+                                "/api/integration/suggestiontargets/search/findBySource?source=reciter")))
+                .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(10)));
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findBySource").param("source", "scopus"))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets",
+                        Matchers.containsInAnyOrder(
+                                matchSuggestionTarget("Test 6", "scopus", 13),
+                                matchSuggestionTarget("Test 3", "scopus", 10),
+                                matchSuggestionTarget("Test 0", "scopus", 7),
+                                matchSuggestionTarget("Bollini, Andrea", "scopus", 3),
+                                matchSuggestionTarget("Lombardi, Corrado", "scopus", 3))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.containsString(
+                                "/api/integration/suggestiontargets/search/findBySource?source=scopus")))
+                .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(5)));
+    }
+
+    @Test
+    public void findBySourcePaginationTest() throws Exception {
+        buildSuggestionTargetsList();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findBySource")
+                        .param("source", "reciter").param("size", "1"))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets",
+                        Matchers.contains(matchSuggestionTarget("Bollini, Andrea", "reciter", 31))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.next.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=1"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=9"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=0"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.prev.href").doesNotExist()).andExpect(jsonPath("$.page.size", is(1)))
+                .andExpect(jsonPath("$.page.totalElements", is(10)));
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findBySource").param("source", "reciter")
+                        .param("size", "1").param("page", "1"))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets",
+                        Matchers.contains(matchSuggestionTarget("Digilio, Giuseppe", "reciter", 11))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=1"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.next.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=2"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=9"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=0"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.prev.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=0"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$.page.size", is(1))).andExpect(jsonPath("$.page.totalElements", is(10)));
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findBySource").param("source", "reciter")
+                        .param("size", "1").param("page", "9"))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets",
+                        Matchers.contains(matchSuggestionTarget("Test 0", "reciter", 3))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=9"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.next.href").doesNotExist())
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=9"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=0"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.prev.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=reciter"), Matchers.containsString("page=8"),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$.page.size", is(1))).andExpect(jsonPath("$.page.totalElements", is(10)));
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findBySource").param("source", "scopus")
+                        .param("size", "3").param("page", "0"))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets",
+                        Matchers.contains(
+                                matchSuggestionTarget("Test 6", "scopus", 13),
+                                matchSuggestionTarget("Test 3", "scopus", 10),
+                                matchSuggestionTarget("Test 0", "scopus", 7))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=scopus"), Matchers.containsString("page=0"),
+                                Matchers.containsString("size=3"))))
+                .andExpect(jsonPath("$._links.next.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=scopus"), Matchers.containsString("page=1"),
+                                Matchers.containsString("size=3"))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=scopus"), Matchers.containsString("page=1"),
+                                Matchers.containsString("size=3"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=scopus"), Matchers.containsString("page=0"),
+                                Matchers.containsString("size=3"))))
+                .andExpect(jsonPath("$._links.prev.href").doesNotExist()).andExpect(jsonPath("$.page.size", is(3)))
+                .andExpect(jsonPath("$.page.totalElements", is(5)));
+
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findBySource").param("source", "scopus")
+                        .param("size", "3").param("page", "1"))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets", Matchers.iterableWithSize(2)))
+                .andExpect(jsonPath("$._embedded.suggestiontargets",
+                        Matchers.containsInAnyOrder(matchSuggestionTarget("Bollini, Andrea", "scopus", 3),
+                                matchSuggestionTarget("Lombardi, Corrado", "scopus", 3))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=scopus"), Matchers.containsString("page=1"),
+                                Matchers.containsString("size=3"))))
+                .andExpect(jsonPath("$._links.next.href").doesNotExist())
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=scopus"), Matchers.containsString("page=1"),
+                                Matchers.containsString("size=3"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=scopus"), Matchers.containsString("page=0"),
+                                Matchers.containsString("size=3"))))
+                .andExpect(jsonPath("$._links.prev.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findBySource?"),
+                                Matchers.containsString("source=scopus"), Matchers.containsString("page=0"),
+                                Matchers.containsString("size=3"))))
+                .andExpect(jsonPath("$.page.size", is(3))).andExpect(jsonPath("$.page.totalElements", is(5)));
+    }
+
+    @Test
+    public void findBySourceUnAuthenticatedTest() throws Exception {
+        buildSuggestionTargetsList();
+        // anonymous cannot access the suggestions endpoint
+        getClient().perform(get("/api/integration/suggestiontargets/search/findBySource").param("source", "reciter"))
+                .andExpect(status().isUnauthorized());
+        getClient().perform(get("/api/integration/suggestiontargets/search/findBySource").param("source", "not-exist"))
+                .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findBySourceForbiddenTest() throws Exception {
+        buildSuggestionTargetsList();
+        String tokenEperson = getAuthToken(eperson.getEmail(), password);
+        getClient(tokenEperson)
+                .perform(get("/api/integration/suggestiontargets/search/findBySource").param("source", "reciter"))
+                .andExpect(status().isForbidden());
+        getClient(tokenEperson)
+                .perform(get("/api/integration/suggestiontargets/search/findBySource").param("source", "not-exist"))
+                .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findBySourceBadRequestTest() throws Exception {
+        String tokenEperson = getAuthToken(admin.getEmail(), password);
+        getClient(tokenEperson).perform(get("/api/integration/suggestiontargets/search/findBySource"))
+                .andExpect(status().isBadRequest());
+    }
+
+    @Test
+    public void findOneTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        SuggestionTarget target = SuggestionTargetBuilder.createTarget(context, colPeople, "Bollini, Andrea")
+                .withSuggestionCount("scopus", 3).build();
+        SuggestionTarget targetEPerson = SuggestionTargetBuilder
+                .createTarget(context, colPeople, "Digilio, Giuseppe", eperson).withSuggestionCount("reciter", 11)
+                .build();
+        context.restoreAuthSystemState();
+        String uuidStr = target.getID().toString();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/integration/suggestiontargets/" + uuidStr)).andExpect(status().isOk())
+                .andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$", matchSuggestionTarget("Bollini, Andrea", "scopus", 3))).andExpect(jsonPath(
+                        "$._links.self.href", Matchers.endsWith("/api/integration/suggestiontargets/" + uuidStr)));
+        // build a person profile linked to our eperson
+        String uuidStrEpersonProfile = targetEPerson.getID().toString();
+        String tokenEperson = getAuthToken(eperson.getEmail(), password);
+        getClient(tokenEperson).perform(get("/api/integration/suggestiontargets/" + uuidStrEpersonProfile))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$", matchSuggestionTarget("Digilio, Giuseppe", "reciter", 11)))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.endsWith("/api/integration/suggestiontargets/" + uuidStrEpersonProfile)));
+    }
+
+    @Test
+    public void findOneFullProjectionTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        SuggestionTarget target = SuggestionTargetBuilder.createTarget(context, colPeople, "Bollini, Andrea")
+                .withSuggestionCount("scopus", 3).build();
+        SuggestionTarget targetEPerson = SuggestionTargetBuilder
+                .createTarget(context, colPeople, "Digilio, Giuseppe", eperson).withSuggestionCount("reciter", 11)
+                .build();
+        context.restoreAuthSystemState();
+        String uuidStrTarget = target.getID().toString();
+        String uuidStrProfile = target.getTarget().getID().toString();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/" + uuidStrTarget).param("projection", "full"))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$", matchSuggestionTarget("Bollini, Andrea", "scopus", 3)))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.endsWith("/api/integration/suggestiontargets/" + uuidStrTarget)))
+                .andExpect(jsonPath("$._embedded.target.id", Matchers.is(uuidStrProfile)));
+        String uuidStrEpersonTarget = targetEPerson.getID().toString();
+        String uuidStrEpersonProfile = targetEPerson.getTarget().getID().toString();
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(epersonToken)
+                .perform(get("/api/integration/suggestiontargets/" + uuidStrEpersonTarget).param("projection", "full"))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$", matchSuggestionTarget("Digilio, Giuseppe", "reciter", 11)))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.endsWith("/api/integration/suggestiontargets/" + uuidStrEpersonTarget)))
+                .andExpect(jsonPath("$._embedded.target.id", Matchers.is(uuidStrEpersonProfile)));
+    }
+
+    @Test
+    public void findOneUnAuthenticatedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        SuggestionTarget target = SuggestionTargetBuilder.createTarget(context, colPeople, "Bollini, Andrea")
+                .withSuggestionCount("reciter", 31).build();
+        context.restoreAuthSystemState();
+        String uuidStr = target.getID().toString();
+        getClient().perform(get("/api/integration/suggestiontargets/" + uuidStr)).andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findOneForbiddenTest() throws Exception {
+        // build a generic person profile
+        context.turnOffAuthorisationSystem();
+        SuggestionTarget target = SuggestionTargetBuilder.createTarget(context, colPeople, "Bollini, Andrea")
+                .withSuggestionCount("reciter", 31).build();
+        context.restoreAuthSystemState();
+        String uuidStr = target.getID().toString();
+        String tokenEperson = getAuthToken(eperson.getEmail(), password);
+        getClient(tokenEperson).perform(get("/api/integration/suggestiontargets/" + uuidStr))
+                .andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findOneTestWrongID() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken).perform(get("/api/integration/suggestiontargets/not-an-uuid"))
+                .andExpect(status().isNotFound());
+        getClient(adminToken).perform(get("/api/integration/suggestiontargets/" + UUID.randomUUID()))
+                .andExpect(status().isNotFound());
+        getClient(adminToken).perform(get("/api/integration/suggestiontargets/scopus:" + UUID.randomUUID()))
+                .andExpect(status().isNotFound());
+        getClient(adminToken).perform(get("/api/integration/suggestiontargets/invalid:" + UUID.randomUUID()))
+                .andExpect(status().isNotFound());
+
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(epersonToken).perform(get("/api/integration/suggestiontargets/not-an-uuid"))
+                .andExpect(status().isForbidden());
+        getClient(epersonToken).perform(get("/api/integration/suggestiontargets/" + UUID.randomUUID()))
+                .andExpect(status().isForbidden());
+        getClient(epersonToken).perform(get("/api/integration/suggestiontargets/scopus:" + UUID.randomUUID()))
+                .andExpect(status().isForbidden());
+        getClient(epersonToken).perform(get("/api/integration/suggestiontargets/invalid:" + UUID.randomUUID()))
+                .andExpect(status().isForbidden());
+
+        getClient().perform(get("/api/integration/suggestiontargets/not-an-uuid")).andExpect(status().isUnauthorized());
+        getClient().perform(get("/api/integration/suggestiontargets/" + UUID.randomUUID()))
+                .andExpect(status().isUnauthorized());
+        getClient().perform(get("/api/integration/suggestiontargets/scopus:" + UUID.randomUUID()))
+                .andExpect(status().isUnauthorized());
+        getClient().perform(get("/api/integration/suggestiontargets/invalid:" + UUID.randomUUID()))
+                .andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findByTargetTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 31).build();
+        SuggestionTarget targetFirstScopus = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("scopus", 3).build();
+        Item itemLast = ItemBuilder.createItem(context, colPeople).withTitle("Lombardi, Corrado")
+                .withDSpaceObjectOwner(eperson.getFullName(), eperson.getID().toString()).build();
+        SuggestionTarget targetLast = SuggestionTargetBuilder.createTarget(context, itemLast)
+                .withSuggestionCount("scopus", 2).build();
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findByTarget").param("target",
+                        itemFirst.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets",
+                        Matchers.contains(matchSuggestionTarget("Bollini, Andrea", "reciter", 31),
+                                matchSuggestionTarget("Bollini, Andrea", "scopus", 3))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.containsString("/api/integration/suggestiontargets/search/findByTarget?target="
+                                + itemFirst.getID().toString())))
+                .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(2)));
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findByTarget").param("target",
+                        itemLast.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets",
+                        Matchers.contains(matchSuggestionTarget("Lombardi, Corrado", "scopus", 2))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.containsString("/api/integration/suggestiontargets/search/findByTarget?target="
+                                + itemLast.getID().toString())))
+                .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(1)));
+        String epersonToken = getAuthToken(eperson.getEmail(), password);
+        getClient(epersonToken)
+                .perform(get("/api/integration/suggestiontargets/search/findByTarget").param("target",
+                        itemLast.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets",
+                        Matchers.contains(matchSuggestionTarget("Lombardi, Corrado", "scopus", 2))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.containsString("/api/integration/suggestiontargets/search/findByTarget?target="
+                                + itemLast.getID().toString())))
+                .andExpect(jsonPath("$.page.size", is(20))).andExpect(jsonPath("$.page.totalElements", is(1)));
+    }
+
+    @Test
+    public void findByTargetPaginationTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 31).build();
+        SuggestionTarget targetFirstScopus = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("scopus", 3).build();
+        context.restoreAuthSystemState();
+
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findByTarget").param("size", "1")
+                        .param("target", itemFirst.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets",
+                        Matchers.contains(matchSuggestionTarget("Bollini, Andrea", "reciter", 31))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findByTarget?"),
+                                Matchers.containsString("target=" + itemFirst.getID().toString()),
+                                Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.next.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findByTarget?"),
+                                Matchers.containsString("target=" + itemFirst.getID().toString()),
+                                Matchers.containsString("page=1"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findByTarget?"),
+                                Matchers.containsString("target=" + itemFirst.getID().toString()),
+                                Matchers.containsString("page=1"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findByTarget?"),
+                                Matchers.containsString("target=" + itemFirst.getID().toString()),
+                                Matchers.containsString("page=0"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.prev.href").doesNotExist()).andExpect(jsonPath("$.page.size", is(1)))
+                .andExpect(jsonPath("$.page.size", is(1))).andExpect(jsonPath("$.page.totalElements", is(2)));
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findByTarget").param("size", "1")
+                        .param("page", "1").param("target", itemFirst.getID().toString()))
+                .andExpect(status().isOk()).andExpect(content().contentType(contentType))
+                .andExpect(jsonPath("$._embedded.suggestiontargets",
+                        Matchers.contains(matchSuggestionTarget("Bollini, Andrea", "scopus", 3))))
+                .andExpect(jsonPath("$._links.self.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findByTarget?"),
+                                Matchers.containsString("target=" + itemFirst.getID().toString()),
+                                Matchers.containsString("size=1"), Matchers.containsString("page=1"))))
+                .andExpect(jsonPath("$._links.prev.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findByTarget?"),
+                                Matchers.containsString("target=" + itemFirst.getID().toString()),
+                                Matchers.containsString("page=0"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.last.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findByTarget?"),
+                                Matchers.containsString("target=" + itemFirst.getID().toString()),
+                                Matchers.containsString("page=1"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.first.href",
+                        Matchers.allOf(
+                                Matchers.containsString("/api/integration/suggestiontargets/search/findByTarget?"),
+                                Matchers.containsString("target=" + itemFirst.getID().toString()),
+                                Matchers.containsString("page=0"), Matchers.containsString("size=1"))))
+                .andExpect(jsonPath("$._links.next.href").doesNotExist()).andExpect(jsonPath("$.page.size", is(1)))
+                .andExpect(jsonPath("$.page.size", is(1))).andExpect(jsonPath("$.page.totalElements", is(2)));
+    }
+
+    @Test
+    public void findByTargetUnAuthenticatedTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 31).build();
+        SuggestionTarget targetFirstScopus = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("scopus", 3).build();
+        Item itemLast = ItemBuilder.createItem(context, colPeople).withTitle("Lombardi, Corrado")
+                .withDSpaceObjectOwner(eperson.getFullName(), eperson.getID().toString()).build();
+        SuggestionTarget targetLast = SuggestionTargetBuilder.createTarget(context, itemLast)
+                .withSuggestionCount("scopus", 2).build();
+        context.restoreAuthSystemState();
+
+        // anonymous cannot access the suggestions endpoint
+        getClient().perform(get("/api/integration/suggestiontargets/search/findByTarget").param("target",
+                itemFirst.getID().toString())).andExpect(status().isUnauthorized());
+        getClient().perform(get("/api/integration/suggestiontargets/search/findByTarget").param("target",
+                itemLast.getID().toString())).andExpect(status().isUnauthorized());
+    }
+
+    @Test
+    public void findByTargetForbiddenTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+        Item itemFirst = ItemBuilder.createItem(context, colPeople).withTitle("Bollini, Andrea").build();
+        SuggestionTarget targetFirstReciter = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("reciter", 31).build();
+        SuggestionTarget targetFirstScopus = SuggestionTargetBuilder.createTarget(context, itemFirst)
+                .withSuggestionCount("scopus", 3).build();
+        Item itemLast = ItemBuilder.createItem(context, colPeople).withTitle("Lombardi, Corrado")
+                .withDSpaceObjectOwner(eperson.getFullName(), eperson.getID().toString()).build();
+        SuggestionTarget targetLast = SuggestionTargetBuilder.createTarget(context, itemLast)
+                .withSuggestionCount("scopus", 2).build();
+        EPerson anotherEPerson = EPersonBuilder.createEPerson(context).withEmail("another@example.com")
+                .withPassword(password).withNameInMetadata("Test", "Test").build();
+        context.restoreAuthSystemState();
+
+        String tokenAnother = getAuthToken(anotherEPerson.getEmail(), password);
+        getClient(tokenAnother).perform(get("/api/integration/suggestiontargets/search/findByTarget").param("target",
+                itemFirst.getID().toString())).andExpect(status().isForbidden());
+        getClient(tokenAnother).perform(get("/api/integration/suggestiontargets/search/findByTarget").param("target",
+                itemLast.getID().toString())).andExpect(status().isForbidden());
+    }
+
+    @Test
+    public void findByTargetBadRequestTest() throws Exception {
+        String adminToken = getAuthToken(admin.getEmail(), password);
+        getClient(adminToken)
+                .perform(get("/api/integration/suggestiontargets/search/findByTarget").param("target", "not-exist"))
+                .andExpect(status().isBadRequest());
+        getClient(adminToken).perform(get("/api/integration/suggestiontargets/search/findByTarget"))
+                .andExpect(status().isBadRequest());
+        getClient().perform(get("/api/integration/suggestiontargets/search/findByTarget").param("target", "not-exist"))
+                .andExpect(status().isBadRequest());
+    }
+
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/WorkspaceItemRestRepositoryIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/WorkspaceItemRestRepositoryIT.java
index 8b2f3f093a..f2087fa25c 100644
--- a/dspace-server-webapp/src/test/java/org/dspace/app/rest/WorkspaceItemRestRepositoryIT.java
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/WorkspaceItemRestRepositoryIT.java
@@ -52,6 +52,7 @@ import com.fasterxml.jackson.databind.ObjectMapper;
 import com.jayway.jsonpath.matchers.JsonPathMatchers;
 import org.apache.commons.io.IOUtils;
 import org.apache.commons.lang3.time.DateUtils;
+import org.dspace.app.ldn.NotifyServiceEntity;
 import org.dspace.app.rest.matcher.CollectionMatcher;
 import org.dspace.app.rest.matcher.ItemMatcher;
 import org.dspace.app.rest.matcher.MetadataMatcher;
@@ -70,6 +71,8 @@ import org.dspace.builder.EPersonBuilder;
 import org.dspace.builder.EntityTypeBuilder;
 import org.dspace.builder.GroupBuilder;
 import org.dspace.builder.ItemBuilder;
+import org.dspace.builder.NotifyServiceBuilder;
+import org.dspace.builder.NotifyServiceInboundPatternBuilder;
 import org.dspace.builder.RelationshipBuilder;
 import org.dspace.builder.RelationshipTypeBuilder;
 import org.dspace.builder.ResourcePolicyBuilder;
@@ -8601,6 +8604,639 @@ public class WorkspaceItemRestRepositoryIT extends AbstractControllerIntegration
                 .content("/api/submission/workspaceitems/" + workspaceItem.getID())
                 .contentType(textUriContentType))
                 .andExpect(status().isCreated());
+    }
+
+
+    @Test
+    public void testSubmissionWithCOARNotifyServicesSection() throws Exception {
+
+        context.turnOffAuthorisationSystem();
+
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+
+        Collection collection = CollectionBuilder.createCollection(context, parentCommunity)
+                                                 .withName("Collection 1")
+                                                 .build();
+
+        // create three notify services
+        NotifyServiceEntity notifyServiceOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceTwo =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name two")
+                                .withLdnUrl("https://service2.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceThree =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name three")
+                                .withLdnUrl("https://service3.ldn.org/inbox")
+                                .build();
+
+        // append the three services to the workspace item with different patterns
+        WorkspaceItem workspaceItem = WorkspaceItemBuilder.createWorkspaceItem(context, collection)
+                  .withTitle("Workspace Item")
+                  .withIssueDate("2024-10-10")
+                  .withCOARNotifyService(notifyServiceOne, "request-review")
+                  .withCOARNotifyService(notifyServiceTwo, "request-endorsement")
+                  .withCOARNotifyService(notifyServiceThree, "request-endorsement")
+                  .build();
+
+        context.restoreAuthSystemState();
+        String adminToken = getAuthToken(admin.getEmail(), password);
+
+        // check coarnotify section data
+        getClient(adminToken)
+            .perform(get("/api/submission/workspaceitems/" + workspaceItem.getID()))
+            .andExpect(status().isOk())
+            .andExpect(jsonPath("$.sections.coarnotify.request-endorsement", contains(
+                notifyServiceTwo.getID(), notifyServiceThree.getID())))
+            .andExpect(jsonPath("$.sections.coarnotify.request-review", contains(
+                notifyServiceOne.getID())));
+    }
+
+    @Test
+    public void patchCOARNotifyServiceAddTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        //** GIVEN **
+        //1. A community-collection structure with one parent community with sub-community and one collection.
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Community child1 = CommunityBuilder.createSubCommunity(context, parentCommunity)
+                                           .withName("Sub Community")
+                                           .build();
+        Collection col1 = CollectionBuilder.createCollection(context, child1).withName("Collection 1").build();
+
+
+        NotifyServiceEntity notifyServiceOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceTwo =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name two")
+                                .withLdnUrl("https://service2.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceThree =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name three")
+                                .withLdnUrl("https://service3.ldn.org/inbox")
+                                .build();
+
+        WorkspaceItem witem = WorkspaceItemBuilder.createWorkspaceItem(context, col1)
+                                                  .withTitle("Test WorkspaceItem")
+                                                  .withIssueDate("2017-10-17")
+                                                  .withCOARNotifyService(notifyServiceOne, "request-review")
+                                                  .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceOne)
+                                          .withPattern("request-review")
+                                          .withConstraint("itemFilterA")
+                                          .isAutomatic(false)
+                                          .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceTwo)
+                                          .withPattern("request-review")
+                                          .withConstraint("itemFilterA")
+                                          .isAutomatic(false)
+                                          .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceThree)
+                                          .withPattern("request-review")
+                                          .withConstraint("itemFilterA")
+                                          .isAutomatic(false)
+                                          .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+
+        // try to add new service of review pattern to witem
+        List<Operation> addOpts = new ArrayList<Operation>();
+        addOpts.add(new AddOperation("/sections/coarnotify/request-review/-",
+            List.of(notifyServiceTwo.getID(), notifyServiceThree.getID())));
+
+        String patchBody = getPatchContent(addOpts);
+
+        getClient(authToken).perform(patch("/api/submission/workspaceitems/" + witem.getID())
+                                .content(patchBody)
+                                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", hasSize(3)))
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review",contains(
+                                notifyServiceOne.getID(),
+                                notifyServiceTwo.getID(),
+                                notifyServiceThree.getID()
+                            )));
+
+    }
+
+    @Test
+    public void patchCOARNotifyServiceAddWithInCompatibleServicesTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        //** GIVEN **
+        //1. A community-collection structure with one parent community with sub-community and one collection.
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Community child1 = CommunityBuilder.createSubCommunity(context, parentCommunity)
+                                           .withName("Sub Community")
+                                           .build();
+        Collection col1 = CollectionBuilder.createCollection(context, child1).withName("Collection 1").build();
+
+
+        NotifyServiceEntity notifyServiceOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceTwo =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name two")
+                                .withLdnUrl("https://service2.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceThree =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name three")
+                                .withLdnUrl("https://service3.ldn.org/inbox")
+                                .build();
+
+        WorkspaceItem witem = WorkspaceItemBuilder.createWorkspaceItem(context, col1)
+                                                  .withTitle("Test WorkspaceItem")
+                                                  .withIssueDate("2017-10-17")
+                                                  .withCOARNotifyService(notifyServiceOne, "request-review")
+                                                  .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+
+        // check the coar notify services of witem
+        getClient(authToken).perform(get("/api/submission/workspaceitems/" + witem.getID()))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", hasSize(1)))
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", contains(
+                                notifyServiceOne.getID()
+                            )));
+
+        // try to add new service of review pattern to witem
+        List<Operation> addOpts = new ArrayList<Operation>();
+        addOpts.add(new AddOperation("/sections/coarnotify/request-review/-",
+            List.of(notifyServiceTwo.getID(), notifyServiceThree.getID())));
+
+        String patchBody = getPatchContent(addOpts);
+
+        getClient(authToken).perform(patch("/api/submission/workspaceitems/" + witem.getID())
+                                .content(patchBody)
+                                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isUnprocessableEntity());
+
+    }
+
+    @Test
+    public void patchCOARNotifyServiceAddWithInvalidPatternTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        //** GIVEN **
+        //1. A community-collection structure with one parent community with sub-community and one collection.
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Community child1 = CommunityBuilder.createSubCommunity(context, parentCommunity)
+                                           .withName("Sub Community")
+                                           .build();
+        Collection col1 = CollectionBuilder.createCollection(context, child1).withName("Collection 1").build();
+
+
+        NotifyServiceEntity notifyServiceOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        WorkspaceItem witem = WorkspaceItemBuilder.createWorkspaceItem(context, col1)
+                                                  .withTitle("Test WorkspaceItem")
+                                                  .withIssueDate("2017-10-17")
+                                                  .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+
+        // try to add new service of unknown pattern to witem
+        List<Operation> addOpts = new ArrayList<Operation>();
+        addOpts.add(new AddOperation("/sections/coarnotify/unknown/-", List.of(notifyServiceOne.getID())));
+
+        String patchBody = getPatchContent(addOpts);
+
+        getClient(authToken).perform(patch("/api/submission/workspaceitems/" + witem.getID())
+                                .content(patchBody)
+                                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isUnprocessableEntity());
+
+    }
+
+    @Test
+    public void patchCOARNotifyServiceAddWithInvalidServiceIdTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        //** GIVEN **
+        //1. A community-collection structure with one parent community with sub-community and one collection.
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Community child1 = CommunityBuilder.createSubCommunity(context, parentCommunity)
+                                           .withName("Sub Community")
+                                           .build();
+        Collection col1 = CollectionBuilder.createCollection(context, child1).withName("Collection 1").build();
+
+
+        NotifyServiceEntity notifyServiceOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        WorkspaceItem witem = WorkspaceItemBuilder.createWorkspaceItem(context, col1)
+                                                  .withTitle("Test WorkspaceItem")
+                                                  .withIssueDate("2017-10-17")
+                                                  .withCOARNotifyService(notifyServiceOne, "request-review")
+                                                  .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+
+        // check the coar notify services of witem
+        getClient(authToken).perform(get("/api/submission/workspaceitems/" + witem.getID()))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", contains(
+                                notifyServiceOne.getID()
+                            )));
+
+        // try to add new service of review pattern to witem but service not exist
+        List<Operation> addOpts = new ArrayList<Operation>();
+        addOpts.add(new AddOperation("/sections/coarnotify/request-review/-", List.of("123456789")));
+
+        String patchBody = getPatchContent(addOpts);
+
+        getClient(authToken).perform(patch("/api/submission/workspaceitems/" + witem.getID())
+                                .content(patchBody)
+                                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isUnprocessableEntity());
+
+    }
+
+    @Test
+    public void patchCOARNotifyServiceReplaceTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        //** GIVEN **
+        //1. A community-collection structure with one parent community with sub-community and one collection.
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Community child1 = CommunityBuilder.createSubCommunity(context, parentCommunity)
+                                           .withName("Sub Community")
+                                           .build();
+        Collection col1 = CollectionBuilder.createCollection(context, child1).withName("Collection 1").build();
+
+
+        NotifyServiceEntity notifyServiceOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceTwo =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name two")
+                                .withLdnUrl("https://service2.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceThree =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name three")
+                                .withLdnUrl("https://service3.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceOne)
+                                          .withPattern("request-review")
+                                          .withConstraint("itemFilterA")
+                                          .isAutomatic(false)
+                                          .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceTwo)
+                                          .withPattern("request-review")
+                                          .withConstraint("demo_filter")
+                                          .isAutomatic(false)
+                                          .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceThree)
+                                          .withPattern("request-review")
+                                          .withConstraint("demo_filter")
+                                          .isAutomatic(false)
+                                          .build();
+
+        WorkspaceItem witem = WorkspaceItemBuilder.createWorkspaceItem(context, col1)
+                                                  .withTitle("Test WorkspaceItem")
+                                                  .withIssueDate("2017-10-17")
+                                                  .withCOARNotifyService(notifyServiceOne, "request-review")
+                                                  .withCOARNotifyService(notifyServiceTwo, "request-review")
+                                                  .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+
+        // check the coar notify services of witem
+        getClient(authToken).perform(get("/api/submission/workspaceitems/" + witem.getID()))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", hasSize(2)))
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", contains(
+                                notifyServiceOne.getID(),
+                                notifyServiceTwo.getID())));
+
+        // try to replace the notifyServiceOne of witem with notifyServiceThree of review pattern
+        List<Operation> replaceOpts = new ArrayList<Operation>();
+        replaceOpts.add(new ReplaceOperation("/sections/coarnotify/request-review/0", notifyServiceThree.getID()));
+
+        String patchBody = getPatchContent(replaceOpts);
+
+        getClient(authToken).perform(patch("/api/submission/workspaceitems/" + witem.getID())
+                                .content(patchBody)
+                                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", hasSize(2)))
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", contains(
+                                notifyServiceThree.getID(), notifyServiceTwo.getID()
+                            )));
+
+    }
+
+    @Test
+    public void patchCOARNotifyServiceReplaceWithInCompatibleServicesTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        //** GIVEN **
+        //1. A community-collection structure with one parent community with sub-community and one collection.
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Community child1 = CommunityBuilder.createSubCommunity(context, parentCommunity)
+                                           .withName("Sub Community")
+                                           .build();
+        Collection col1 = CollectionBuilder.createCollection(context, child1).withName("Collection 1").build();
+
+
+        NotifyServiceEntity notifyServiceOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceTwo =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name two")
+                                .withLdnUrl("https://service2.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceThree =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name three")
+                                .withLdnUrl("https://service3.ldn.org/inbox")
+                                .build();
+
+        WorkspaceItem witem = WorkspaceItemBuilder.createWorkspaceItem(context, col1)
+                                                  .withTitle("Test WorkspaceItem")
+                                                  .withIssueDate("2017-10-17")
+                                                  .withCOARNotifyService(notifyServiceOne, "request-review")
+                                                  .withCOARNotifyService(notifyServiceTwo, "request-review")
+                                                  .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+
+        // check the coar notify services of witem
+        getClient(authToken).perform(get("/api/submission/workspaceitems/" + witem.getID()))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", hasSize(2)))
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", contains(
+                                notifyServiceOne.getID(),
+                                notifyServiceTwo.getID())));
+
+        // try to replace the notifyServiceOne of witem with notifyServiceThree of review pattern
+        List<Operation> replaceOpts = new ArrayList<Operation>();
+        replaceOpts.add(new ReplaceOperation("/sections/coarnotify/request-review/0", notifyServiceThree.getID()));
+
+        String patchBody = getPatchContent(replaceOpts);
+
+        getClient(authToken).perform(patch("/api/submission/workspaceitems/" + witem.getID())
+                                .content(patchBody)
+                                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isUnprocessableEntity());
+
+    }
+
+    @Test
+    public void patchCOARNotifyServiceRemoveTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        //** GIVEN **
+        //1. A community-collection structure with one parent community with sub-community and one collection.
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Community child1 = CommunityBuilder.createSubCommunity(context, parentCommunity)
+                                           .withName("Sub Community")
+                                           .build();
+        Collection col1 = CollectionBuilder.createCollection(context, child1).withName("Collection 1").build();
 
+
+        NotifyServiceEntity notifyServiceOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceTwo =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name two")
+                                .withLdnUrl("https://service2.ldn.org/inbox")
+                                .build();
+
+        WorkspaceItem witem = WorkspaceItemBuilder.createWorkspaceItem(context, col1)
+                                                  .withTitle("Test WorkspaceItem")
+                                                  .withIssueDate("2017-10-17")
+                                                  .withCOARNotifyService(notifyServiceOne, "request-review")
+                                                  .withCOARNotifyService(notifyServiceTwo, "request-review")
+                                                  .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+
+        // check the coar notify services of witem
+        getClient(authToken).perform(get("/api/submission/workspaceitems/" + witem.getID()))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", hasSize(2)))
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", contains(
+                                notifyServiceOne.getID(), notifyServiceTwo.getID()
+                            )));
+
+        // try to remove the notifyServiceOne of witem
+        List<Operation> removeOpts = new ArrayList<Operation>();
+        removeOpts.add(new RemoveOperation("/sections/coarnotify/request-review/0"));
+
+        String patchBody = getPatchContent(removeOpts);
+
+        getClient(authToken).perform(patch("/api/submission/workspaceitems/" + witem.getID())
+                                .content(patchBody)
+                                .contentType(MediaType.APPLICATION_JSON_PATCH_JSON))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", hasSize(1)))
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review",contains(
+                                notifyServiceTwo.getID())));
+
+    }
+
+    @Test
+    public void submissionCOARNotifyServicesSectionWithValidationErrorsTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        //** GIVEN **
+        //1. A community-collection structure with one parent community with sub-community and one collection.
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Community child1 = CommunityBuilder.createSubCommunity(context, parentCommunity)
+                                           .withName("Sub Community")
+                                           .build();
+        Collection col1 = CollectionBuilder.createCollection(context, child1).withName("Collection 1").build();
+
+
+        NotifyServiceEntity notifyServiceOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceTwo =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name two")
+                                .withLdnUrl("https://service2.ldn.org/inbox")
+                                .build();
+
+        NotifyServiceEntity notifyServiceThree =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context).withName("service name three")
+                                .withLdnUrl("https://service3.ldn.org/inbox")
+                                .build();
+
+        WorkspaceItem witem = WorkspaceItemBuilder.createWorkspaceItem(context, col1)
+                                                  .withTitle("Test WorkspaceItem")
+                                                  .withIssueDate("2017-10-17")
+                                                  .withType("Journal Article")
+                                                  .withCOARNotifyService(notifyServiceOne, "request-endorsement")
+                                                  .withCOARNotifyService(notifyServiceTwo, "request-review")
+                                                  .withCOARNotifyService(notifyServiceThree, "request-review")
+                                                  .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceOne)
+                                          .withPattern("request-endorsement")
+                                          .withConstraint("fakeFilterA")
+                                          .isAutomatic(false)
+                                          .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceTwo)
+                                          .withPattern("request-review")
+                                          .withConstraint("type_filter")
+                                          .isAutomatic(false)
+                                          .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceThree)
+                                          .withPattern("request-review")
+                                          .withConstraint("fakeFilterA")
+                                          .isAutomatic(false)
+                                          .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+
+        // check the coar notify services of witem also check the errors
+        getClient(authToken).perform(get("/api/submission/workspaceitems/" + witem.getID()))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", hasSize(2)))
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", contains(
+                                notifyServiceTwo.getID(),
+                                notifyServiceThree.getID())))
+                            .andExpect(jsonPath("$.sections.coarnotify.request-endorsement", hasSize(1)))
+                            .andExpect(jsonPath("$.sections.coarnotify.request-endorsement", contains(
+                                notifyServiceOne.getID())))
+                            .andExpect(jsonPath("$.errors[?(@.message=='error.validation.coarnotify.invalidfilter')]",
+                                Matchers.contains(
+                                    hasJsonPath("$.paths", Matchers.containsInAnyOrder(
+                                        "/sections/coarnotify/request-review/1",
+                                        "/sections/coarnotify/request-endorsement/0")))));
+
+    }
+
+    @Test
+    public void submissionCOARNotifyServicesSectionWithoutValidationErrorsTest() throws Exception {
+        context.turnOffAuthorisationSystem();
+
+        //** GIVEN **
+        //1. A community-collection structure with one parent community with sub-community and one collection.
+        parentCommunity = CommunityBuilder.createCommunity(context)
+                                          .withName("Parent Community")
+                                          .build();
+        Community child1 = CommunityBuilder.createSubCommunity(context, parentCommunity)
+                                           .withName("Sub Community")
+                                           .build();
+        Collection col1 = CollectionBuilder.createCollection(context, child1).withName("Collection 1").build();
+
+
+        NotifyServiceEntity notifyServiceOne =
+            NotifyServiceBuilder.createNotifyServiceBuilder(context)
+                                .withName("service name one")
+                                .withLdnUrl("https://service.ldn.org/inbox")
+                                .build();
+
+        WorkspaceItem witem = WorkspaceItemBuilder.createWorkspaceItem(context, col1)
+                                                  .withTitle("Test WorkspaceItem")
+                                                  .withIssueDate("2017-10-17")
+                                                  .withType("Journal Article")
+                                                  .withCOARNotifyService(notifyServiceOne, "request-review")
+                                                  .withCOARNotifyService(notifyServiceOne, "request-endorsement")
+                                                  .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceOne)
+                                          .withPattern("request-endorsement")
+                                          .withConstraint("type_filter")
+                                          .isAutomatic(false)
+                                          .build();
+
+        NotifyServiceInboundPatternBuilder.createNotifyServiceInboundPatternBuilder(context, notifyServiceOne)
+                                          .withPattern("request-review")
+                                          .withConstraint("type_filter")
+                                          .isAutomatic(false)
+                                          .build();
+
+        context.restoreAuthSystemState();
+
+        String authToken = getAuthToken(eperson.getEmail(), password);
+
+        // check the coar notify services of witem also check the errors
+        getClient(authToken).perform(get("/api/submission/workspaceitems/" + witem.getID()))
+                            .andExpect(status().isOk())
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review", hasSize(1)))
+                            .andExpect(jsonPath("$.sections.coarnotify.request-review",
+                                contains(notifyServiceOne.getID())))
+                            .andExpect(jsonPath(
+                                "$.errors[?(@.message=='error.validation.coarnotify.invalidfilter')]")
+                                    .doesNotExist());
     }
 }
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/QAAuthorizationFeatureIT.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/QAAuthorizationFeatureIT.java
new file mode 100644
index 0000000000..f3e508485a
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/authorization/QAAuthorizationFeatureIT.java
@@ -0,0 +1,84 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.authorization;
+
+import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.jsonPath;
+import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.status;
+
+import org.dspace.app.rest.authorization.impl.QAAuthorizationFeature;
+import org.dspace.app.rest.converter.SiteConverter;
+import org.dspace.app.rest.matcher.AuthorizationMatcher;
+import org.dspace.app.rest.model.SiteRest;
+import org.dspace.app.rest.projection.DefaultProjection;
+import org.dspace.app.rest.test.AbstractControllerIntegrationTest;
+import org.dspace.content.Site;
+import org.dspace.content.service.SiteService;
+import org.dspace.services.ConfigurationService;
+import org.hamcrest.Matchers;
+import org.junit.Before;
+import org.junit.Test;
+import org.springframework.beans.factory.annotation.Autowired;
+
+/**
+ * Test suite for the Quality Assurance Authorization feature
+ * 
+ * @author Francesco Bacchelli (francesco.bacchelli at 4science.it)
+ *
+ */
+public class QAAuthorizationFeatureIT extends AbstractControllerIntegrationTest {
+
+    @Autowired
+    private AuthorizationFeatureService authorizationFeatureService;
+
+    @Autowired
+    private SiteService siteService;
+
+    @Autowired
+    private SiteConverter siteConverter;
+
+    @Autowired
+    private ConfigurationService configurationService;
+
+
+    private AuthorizationFeature qaAuthorizationFeature;
+
+    @Override
+    @Before
+    public void setUp() throws Exception {
+        super.setUp();
+        context.turnOffAuthorisationSystem();
+        qaAuthorizationFeature = authorizationFeatureService.find(QAAuthorizationFeature.NAME);
+        context.restoreAuthSystemState();
+    }
+
+    @Test
+    public void testQAAuthorizationSuccess() throws Exception {
+        configurationService.setProperty("qaevents.enabled", true);
+        Site site = siteService.findSite(context);
+        SiteRest siteRest = siteConverter.convert(site, DefaultProjection.DEFAULT);
+        String tokenAdmin = getAuthToken(admin.getEmail(), password);
+        Authorization authAdminSite = new Authorization(admin, qaAuthorizationFeature, siteRest);
+
+        getClient(tokenAdmin).perform(get("/api/authz/authorizations/" + authAdminSite.getID()))
+                   .andExpect(jsonPath("$", Matchers.is(
+                              AuthorizationMatcher.matchAuthorization(authAdminSite))));
+    }
+
+    @Test
+    public void testQAAuthorizationFail() throws Exception {
+        configurationService.setProperty("qaevents.enabled", false);
+        Site site = siteService.findSite(context);
+        SiteRest siteRest = siteConverter.convert(site, DefaultProjection.DEFAULT);
+        String tokenAdmin = getAuthToken(admin.getEmail(), password);
+        Authorization authAdminSite = new Authorization(admin, qaAuthorizationFeature, siteRest);
+
+        getClient(tokenAdmin).perform(get("/api/authz/authorizations/" + authAdminSite.getID()))
+            .andExpect(status().isNotFound());
+    }
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/FacetEntryMatcher.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/FacetEntryMatcher.java
index 6483758802..cc15700b92 100644
--- a/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/FacetEntryMatcher.java
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/FacetEntryMatcher.java
@@ -169,4 +169,75 @@ public class FacetEntryMatcher {
             hasJsonPath("$._links", matchNextLink(hasNext, "api/discover/facets/entityType"))
         );
     }
+
+    public static Matcher<? super Object> relatedItemFacet(boolean b) {
+        return allOf(
+            hasJsonPath("$.name", is("relateditem")),
+            hasJsonPath("$.facetType", is("text")),
+            hasJsonPath("$.facetLimit", any(Integer.class)),
+            hasJsonPath("$._links.self.href", containsString("api/discover/facets/relateditem")),
+            hasJsonPath("$._links", matchNextLink(b, "api/discover/facets/relateditem"))
+        );
+    }
+
+    public static Matcher<? super Object> originFacet(boolean b) {
+        return allOf(
+            hasJsonPath("$.name", is("origin")),
+            hasJsonPath("$.facetType", is("text")),
+            hasJsonPath("$.facetLimit", any(Integer.class)),
+            hasJsonPath("$._links.self.href", containsString("api/discover/facets/origin")),
+            hasJsonPath("$._links", matchNextLink(b, "api/discover/facets/origin"))
+        );
+    }
+
+    public static Matcher<? super Object> targetFacet(boolean b) {
+        return allOf(
+            hasJsonPath("$.name", is("target")),
+            hasJsonPath("$.facetType", is("text")),
+            hasJsonPath("$.facetLimit", any(Integer.class)),
+            hasJsonPath("$._links.self.href", containsString("api/discover/facets/target")),
+            hasJsonPath("$._links", matchNextLink(b, "api/discover/facets/target"))
+        );
+    }
+
+    public static Matcher<? super Object> queueStatusFacet(boolean b) {
+        return allOf(
+            hasJsonPath("$.name", is("queue_status")),
+            hasJsonPath("$.facetType", is("text")),
+            hasJsonPath("$.facetLimit", any(Integer.class)),
+            hasJsonPath("$._links.self.href", containsString("api/discover/facets/queue_status")),
+            hasJsonPath("$._links", matchNextLink(b, "api/discover/facets/queue_status"))
+        );
+    }
+
+    public static Matcher<? super Object> activityStreamTypeFacet(boolean b) {
+        return allOf(
+            hasJsonPath("$.name", is("activity_stream_type")),
+            hasJsonPath("$.facetType", is("text")),
+            hasJsonPath("$.facetLimit", any(Integer.class)),
+            hasJsonPath("$._links.self.href", containsString("api/discover/facets/activity_stream_type")),
+            hasJsonPath("$._links", matchNextLink(b, "api/discover/facets/activity_stream_type"))
+        );
+    }
+
+    public static Matcher<? super Object> coarNotifyTypeFacet(boolean b) {
+        return allOf(
+            hasJsonPath("$.name", is("coar_notify_type")),
+            hasJsonPath("$.facetType", is("text")),
+            hasJsonPath("$.facetLimit", any(Integer.class)),
+            hasJsonPath("$._links.self.href", containsString("api/discover/facets/coar_notify_type")),
+            hasJsonPath("$._links", matchNextLink(b, "api/discover/facets/coar_notify_type"))
+        );
+    }
+
+    public static Matcher<? super Object> notificationTypeFacet(boolean b) {
+        return allOf(
+            hasJsonPath("$.name", is("notification_type")),
+            hasJsonPath("$.facetType", is("text")),
+            hasJsonPath("$.facetLimit", any(Integer.class)),
+            hasJsonPath("$._links.self.href", containsString("api/discover/facets/notification_type")),
+            hasJsonPath("$._links", matchNextLink(b, "api/discover/facets/notification_type"))
+        );
+    }
+
 }
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/NotifyServiceMatcher.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/NotifyServiceMatcher.java
new file mode 100644
index 0000000000..377ed043e8
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/NotifyServiceMatcher.java
@@ -0,0 +1,132 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.matcher;
+
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.dspace.app.rest.test.AbstractControllerIntegrationTest.REST_SERVER_URL;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.containsString;
+import static org.hamcrest.Matchers.endsWith;
+import static org.hamcrest.Matchers.is;
+import static org.hamcrest.Matchers.startsWith;
+
+import org.hamcrest.Matcher;
+
+/**
+ * Class to match JSON NotifyServiceEntity in ITs
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ */
+public class NotifyServiceMatcher {
+
+    private NotifyServiceMatcher() { }
+
+    public static Matcher<? super Object> matchNotifyService(String name, String description, String url,
+                                                             String ldnUrl) {
+        return allOf(
+            hasJsonPath("$.name", is(name)),
+            hasJsonPath("$.description", is(description)),
+            hasJsonPath("$.url", is(url)),
+            hasJsonPath("$.ldnUrl", is(ldnUrl)),
+            hasJsonPath("$._links.self.href", containsString("/api/ldn/ldnservices/"))
+        );
+    }
+
+    public static Matcher<? super Object> matchNotifyServiceWithoutLinks(
+        String name, String description, String url, String ldnUrl) {
+        return allOf(
+            hasJsonPath("$.name", is(name)),
+            hasJsonPath("$.description", is(description)),
+            hasJsonPath("$.url", is(url)),
+            hasJsonPath("$.ldnUrl", is(ldnUrl))
+        );
+    }
+
+    public static Matcher<? super Object> matchNotifyService(String name, String description, String url,
+                                                             String ldnUrl, boolean enabled) {
+        return allOf(
+            hasJsonPath("$.name", is(name)),
+            hasJsonPath("$.description", is(description)),
+            hasJsonPath("$.url", is(url)),
+            hasJsonPath("$.ldnUrl", is(ldnUrl)),
+            hasJsonPath("$.enabled", is(enabled)),
+            hasJsonPath("$._links.self.href", containsString("/api/ldn/ldnservices/"))
+        );
+    }
+
+    public static Matcher<? super Object> matchNotifyService(String name, String description, String url,
+                                                             String ldnUrl, boolean enabled,
+                                                             String lowerIp, String upperIp) {
+        return allOf(
+            hasJsonPath("$.name", is(name)),
+            hasJsonPath("$.description", is(description)),
+            hasJsonPath("$.url", is(url)),
+            hasJsonPath("$.ldnUrl", is(ldnUrl)),
+            hasJsonPath("$.enabled", is(enabled)),
+            hasJsonPath("$.lowerIp", is(lowerIp)),
+            hasJsonPath("$.upperIp", is(upperIp)),
+            hasJsonPath("$._links.self.href", containsString("/api/ldn/ldnservices/"))
+        );
+    }
+
+    public static Matcher<? super Object> matchNotifyService(int id, String name, String description,
+                                                             String url, String ldnUrl) {
+        return allOf(
+            hasJsonPath("$.id", is(id)),
+            matchNotifyService(name, description, url, ldnUrl),
+            hasJsonPath("$._links.self.href", startsWith(REST_SERVER_URL)),
+            hasJsonPath("$._links.self.href", endsWith("/api/ldn/ldnservices/" + id))
+        );
+    }
+
+    public static Matcher<? super Object> matchNotifyService(int id, String name, String description,
+                                                             String url, String ldnUrl, boolean enabled) {
+        return allOf(
+            hasJsonPath("$.id", is(id)),
+            matchNotifyService(name, description, url, ldnUrl, enabled),
+            hasJsonPath("$._links.self.href", startsWith(REST_SERVER_URL)),
+            hasJsonPath("$._links.self.href", endsWith("/api/ldn/ldnservices/" + id))
+        );
+    }
+
+    public static Matcher<? super Object> matchNotifyService(int id, String name, String description,
+                                                             String url, String ldnUrl, boolean enabled,
+                                                             String lowerIp, String upperIp) {
+        return allOf(
+            hasJsonPath("$.id", is(id)),
+            matchNotifyService(name, description, url, ldnUrl, enabled, lowerIp, upperIp),
+            hasJsonPath("$._links.self.href", startsWith(REST_SERVER_URL)),
+            hasJsonPath("$._links.self.href", endsWith("/api/ldn/ldnservices/" + id))
+        );
+    }
+
+    public static Matcher<? super Object> matchNotifyServiceWithoutLinks(
+        int id, String name, String description, String url, String ldnUrl) {
+        return allOf(
+            hasJsonPath("$.id", is(id)),
+            matchNotifyServiceWithoutLinks(name, description, url, ldnUrl)
+        );
+    }
+
+    public static Matcher<? super Object> matchNotifyServicePattern(String pattern, String constraint) {
+        return allOf(
+            hasJsonPath("$.pattern", is(pattern)),
+            hasJsonPath("$.constraint", is(constraint))
+        );
+    }
+
+    public static Matcher<? super Object> matchNotifyServicePattern(String pattern,
+                                                                    String constraint,
+                                                                    Boolean automatic) {
+        return allOf(
+            matchNotifyServicePattern(pattern, constraint),
+            hasJsonPath("$.automatic", is(automatic))
+        );
+    }
+
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/QAEventMatcher.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/QAEventMatcher.java
new file mode 100644
index 0000000000..8eb569468d
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/QAEventMatcher.java
@@ -0,0 +1,173 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.matcher;
+
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.emptyOrNullString;
+import static org.hamcrest.Matchers.is;
+
+import java.text.DecimalFormat;
+import java.text.DecimalFormatSymbols;
+import java.util.Locale;
+
+import com.fasterxml.jackson.core.JsonProcessingException;
+import com.fasterxml.jackson.databind.ObjectMapper;
+import com.fasterxml.jackson.databind.json.JsonMapper;
+import org.apache.commons.lang3.StringUtils;
+import org.dspace.app.rest.model.hateoas.QAEventResource;
+import org.dspace.content.QAEvent;
+import org.dspace.qaevent.service.dto.NotifyMessageDTO;
+import org.dspace.qaevent.service.dto.OpenaireMessageDTO;
+import org.dspace.qaevent.service.dto.QAMessageDTO;
+import org.hamcrest.Matcher;
+import org.hamcrest.Matchers;
+import org.hamcrest.core.IsAnything;
+
+
+/**
+ * Matcher related to {@link QAEventResource}.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class QAEventMatcher {
+
+    private QAEventMatcher() {
+    }
+
+    public static Matcher<? super Object> matchQAEventFullEntry(QAEvent event) {
+        return allOf(
+                matchQAEventEntry(event),
+                hasJsonPath("$._embedded.topic.name", is(event.getTopic())),
+                hasJsonPath("$._embedded.target.id", is(event.getTarget())),
+                event.getRelated() != null ?
+                        hasJsonPath("$._embedded.related.id", is(event.getRelated())) :
+                        hasJsonPath("$._embedded.related", is(emptyOrNullString()))
+                );
+    }
+
+    public static Matcher<? super Object> matchQAEventEntry(QAEvent event) {
+        try {
+            ObjectMapper jsonMapper = new JsonMapper();
+            DecimalFormat decimalFormat = new DecimalFormat("0.000", new DecimalFormatSymbols(Locale.ENGLISH));
+            return allOf(hasJsonPath("$.id", is(event.getEventId())),
+                    hasJsonPath("$.originalId", is(event.getOriginalId())),
+                    hasJsonPath("$.title", is(event.getTitle())),
+                    hasJsonPath("$.trust", is(decimalFormat.format(event.getTrust()))),
+                    hasJsonPath("$.status", Matchers.equalToIgnoringCase(event.getStatus())),
+                    hasJsonPath("$.message",
+                            matchMessage(event.getTopic(), jsonMapper.readValue(event.getMessage(),
+                                OpenaireMessageDTO.class))),
+                    hasJsonPath("$._links.target.href", Matchers.endsWith(event.getEventId() + "/target")),
+                    hasJsonPath("$._links.related.href", Matchers.endsWith(event.getEventId() + "/related")),
+                    hasJsonPath("$._links.topic.href", Matchers.endsWith(event.getEventId() + "/topic")),
+                    hasJsonPath("$.type", is("qualityassuranceevent")));
+        } catch (JsonProcessingException e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+
+    public static Matcher<? super Object> matchQAEventNotifyEntry(QAEvent event) {
+        try {
+            ObjectMapper jsonMapper = new JsonMapper();
+            return allOf(hasJsonPath("$.id", is(event.getEventId())),
+                    hasJsonPath("$.originalId", is(event.getOriginalId())),
+                    hasJsonPath("$.title", is(event.getTitle())),
+                    hasJsonPath("$.trust", is(new DecimalFormat("0.000").format(event.getTrust()))),
+                    hasJsonPath("$.status", Matchers.equalToIgnoringCase(event.getStatus())),
+                    hasJsonPath("$.message",
+                            matchMessage(event.getTopic(), jsonMapper.readValue(event.getMessage(),
+                                NotifyMessageDTO.class))),
+                    hasJsonPath("$._links.target.href", Matchers.endsWith(event.getEventId() + "/target")),
+                    hasJsonPath("$._links.related.href", Matchers.endsWith(event.getEventId() + "/related")),
+                    hasJsonPath("$._links.topic.href", Matchers.endsWith(event.getEventId() + "/topic")),
+                    hasJsonPath("$.type", is("qualityassuranceevent")));
+        } catch (JsonProcessingException e) {
+            throw new RuntimeException(e);
+        }
+    }
+    private static Matcher<? super Object> matchMessage(String topic, QAMessageDTO message) {
+        if (message instanceof OpenaireMessageDTO) {
+            OpenaireMessageDTO oadto = (OpenaireMessageDTO) message;
+            if (StringUtils.endsWith(topic, "/ABSTRACT")) {
+                return allOf(hasJsonPath("$.abstract", is(oadto.getAbstracts())));
+            } else if (StringUtils.endsWith(topic, "/PID")) {
+                return allOf(
+                        hasJsonPath("$.value", is(oadto.getValue())),
+                        hasJsonPath("$.type", is(oadto.getType())),
+                        hasJsonPath("$.pidHref", is(calculateOpenairePidHref(oadto.getType(), oadto.getValue()))));
+            } else if (StringUtils.endsWith(topic, "/PROJECT")) {
+                return allOf(
+                        hasJsonPath("$.openaireId", is(oadto.getOpenaireId())),
+                        hasJsonPath("$.acronym", is(oadto.getAcronym())),
+                        hasJsonPath("$.code", is(oadto.getCode())),
+                        hasJsonPath("$.funder", is(oadto.getFunder())),
+                        hasJsonPath("$.fundingProgram", is(oadto.getFundingProgram())),
+                        hasJsonPath("$.jurisdiction", is(oadto.getJurisdiction())),
+                        hasJsonPath("$.title", is(oadto.getTitle())));
+            }
+        } else if (message instanceof NotifyMessageDTO) {
+            NotifyMessageDTO notifyDTO = (NotifyMessageDTO) message;
+            if (StringUtils.endsWith(topic, "/REVIEW")) {
+                return allOf(
+                            hasJsonPath("$.serviceName", is(notifyDTO.getServiceName())),
+                            hasJsonPath("$.serviceId", is(notifyDTO.getServiceId())),
+                            hasJsonPath("$.href", is(notifyDTO.getHref())),
+                            hasJsonPath("$.relationship", is(notifyDTO.getRelationship()))
+                );
+            } else if (StringUtils.endsWith(topic, "/ENDORSEMENT")) {
+                return allOf(
+                    hasJsonPath("$.serviceName", is(notifyDTO.getServiceName())),
+                    hasJsonPath("$.serviceId", is(notifyDTO.getServiceId())),
+                    hasJsonPath("$.href", is(notifyDTO.getHref())),
+                    hasJsonPath("$.relationship", is(notifyDTO.getRelationship()))
+                );
+            }
+        }
+        return IsAnything.anything();
+    }
+
+    private static String calculateOpenairePidHref(String type, String value) {
+        if (type == null) {
+            return null;
+        }
+
+        String hrefPrefix = null;
+
+        switch (type) {
+            case "arxiv":
+                hrefPrefix = "https://arxiv.org/abs/";
+                break;
+            case "handle":
+                hrefPrefix = "https://hdl.handle.net/";
+                break;
+            case "urn":
+                hrefPrefix = "";
+                break;
+            case "doi":
+                hrefPrefix = "https://doi.org/";
+                break;
+            case "pmc":
+                hrefPrefix = "https://www.ncbi.nlm.nih.gov/pmc/articles/";
+                break;
+            case "pmid":
+                hrefPrefix = "https://pubmed.ncbi.nlm.nih.gov/";
+                break;
+            case "ncid":
+                hrefPrefix = "https://ci.nii.ac.jp/ncid/";
+                break;
+            default:
+                break;
+        }
+
+        return hrefPrefix != null ? hrefPrefix + value : null;
+
+    }
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/QASourceMatcher.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/QASourceMatcher.java
new file mode 100644
index 0000000000..c0466ee408
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/QASourceMatcher.java
@@ -0,0 +1,43 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.matcher;
+
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.is;
+
+import org.dspace.app.rest.model.hateoas.QASourceResource;
+import org.hamcrest.Matcher;
+
+/**
+ * Matcher related to {@link QASourceResource}.
+ *
+ * @author Luca Giamminonni (luca.giamminonni at 4science.it)
+ *
+ */
+public class QASourceMatcher {
+
+    private QASourceMatcher() { }
+
+    public static Matcher<? super Object> matchQASourceEntry(String key, int totalEvents) {
+        return allOf(
+            hasJsonPath("$.type", is("qualityassurancesource")),
+            hasJsonPath("$.id", is(key)),
+            hasJsonPath("$.totalEvents", is(totalEvents))
+        );
+    }
+
+
+    public static Matcher<? super Object> matchQASourceEntry(String key) {
+        return allOf(
+            hasJsonPath("$.type", is("qualityassurancesource")),
+            hasJsonPath("$.id", is(key))
+        );
+    }
+
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/QATopicMatcher.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/QATopicMatcher.java
new file mode 100644
index 0000000000..c2a2e76d73
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/QATopicMatcher.java
@@ -0,0 +1,64 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.matcher;
+
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.is;
+
+import org.dspace.app.rest.model.hateoas.QATopicResource;
+import org.dspace.content.QAEvent;
+import org.hamcrest.Matcher;
+
+/**
+ * Matcher related to {@link QATopicResource}.
+ *
+ * @author Andrea Bollini (andrea.bollini at 4science.it)
+ *
+ */
+public class QATopicMatcher {
+
+    private QATopicMatcher() { }
+
+    public static Matcher<? super Object> matchQATopicEntry(String topicName, int totalEvents) {
+        return matchQATopicEntry(QAEvent.OPENAIRE_SOURCE, topicName, totalEvents);
+    }
+
+
+    public static Matcher<? super Object> matchQATopicEntry(String topicName) {
+        return matchQATopicEntry(QAEvent.OPENAIRE_SOURCE, topicName);
+    }
+
+    public static Matcher<? super Object> matchQATopicEntry(String source, String topicName, int totalEvents) {
+        return allOf(
+            hasJsonPath("$.type", is("qualityassurancetopic")),
+            hasJsonPath("$.name", is(topicName)),
+            hasJsonPath("$.id", is(source + ":" + topicName.replace("/", "!"))),
+            hasJsonPath("$.totalEvents", is(totalEvents))
+        );
+    }
+
+    public static Matcher<? super Object> matchQATopicEntry(String source, String topicName) {
+        return allOf(
+            hasJsonPath("$.type", is("qualityassurancetopic")),
+            hasJsonPath("$.name", is(topicName)),
+            hasJsonPath("$.id", is(source + ":" + topicName.replace("/", "!")))
+        );
+    }
+
+    public static Matcher<? super Object> matchQATopicEntry(String source, String topicName, String itemUuid,
+           int totalEvents) {
+        return allOf(
+                hasJsonPath("$.type", is("qualityassurancetopic")),
+                hasJsonPath("$.name", is(topicName)),
+                hasJsonPath("$.id", is(source + ":" + topicName.replace("/", "!") + ":" + itemUuid)),
+                hasJsonPath("$.totalEvents", is(totalEvents))
+            );
+    }
+
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SubmissionCOARNotifyMatcher.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SubmissionCOARNotifyMatcher.java
new file mode 100644
index 0000000000..937b414486
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SubmissionCOARNotifyMatcher.java
@@ -0,0 +1,45 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.matcher;
+
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.hamcrest.Matchers.allOf;
+import static org.hamcrest.Matchers.contains;
+import static org.hamcrest.Matchers.is;
+
+import java.util.List;
+
+import org.dspace.coarnotify.NotifyPattern;
+import org.hamcrest.Matcher;
+
+/**
+ * Matcher for the Submission COAR Notify.
+ *
+ * @author Mohamed Eskander (mohamed.eskander at 4science.com)
+ *
+ */
+public class SubmissionCOARNotifyMatcher {
+
+    private SubmissionCOARNotifyMatcher() {
+    }
+
+    public static Matcher<? super Object> matchCOARNotifyEntry(String id, List<NotifyPattern> patterns) {
+        return allOf(
+            hasJsonPath("$.id", is(id)),
+            hasJsonPath(
+                "$.patterns", contains(
+                patterns.stream()
+                        .map(coarPattern ->
+                            allOf(
+                                hasJsonPath("pattern", is(coarPattern.getPattern())),
+                                hasJsonPath("multipleRequest", is(coarPattern.isMultipleRequest()))
+                            ))
+                        .toArray(Matcher[]::new))));
+    }
+
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SuggestionMatcher.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SuggestionMatcher.java
new file mode 100644
index 0000000000..38be403cb2
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SuggestionMatcher.java
@@ -0,0 +1,57 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.matcher;
+
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.hamcrest.Matchers.is;
+
+import org.dspace.content.Item;
+import org.hamcrest.Matcher;
+import org.hamcrest.Matchers;
+
+public class SuggestionMatcher {
+
+    private SuggestionMatcher() { }
+
+    // Matcher for a suggestion
+    public static Matcher<? super Object> matchSuggestion(String source, Item target, String display,
+            String suggestionId) {
+        return Matchers.allOf(
+                hasJsonPath("$.display", is(display)),
+                hasJsonPath("$.source", is(source)),
+                hasJsonPath("$.id", is(source + ":" + target.getID().toString() + ":" + suggestionId)),
+                hasJsonPath("$.metadata['dc.title'][0].value", is("Title Suggestion " + suggestionId )),
+                hasJsonPath("$.metadata['dc.source'][0].value", is("Source 1")),
+                hasJsonPath("$.metadata['dc.source'][1].value", is("Source 2")),
+                hasJsonPath("$.score"),
+                hasJsonPath("$.evidences"),
+                hasJsonPath("$.type", is("suggestion"))
+        );
+    }
+
+    public static Matcher<? super Object> matchSuggestion(String source, Item target, String display,
+            String suggestionId, double score, String evidenceName, double evidenceScore, String evidenceNote) {
+        return Matchers.allOf(
+                hasJsonPath("$.display", is(display)),
+                hasJsonPath("$.source", is(source)),
+                hasJsonPath("$.id", is(source + ":" + target.getID().toString() + ":" + suggestionId)),
+                hasJsonPath("$.metadata['dc.title'][0].value", is("Title Suggestion " + suggestionId )),
+                hasJsonPath("$.metadata['dc.source'][0].value", is("Source 1")),
+                hasJsonPath("$.metadata['dc.source'][1].value", is("Source 2")),
+                hasJsonPath("$.score", is(String.format("%.2f", score))),
+                hasJsonPath("$.evidences." + evidenceName, Matchers.is(
+                        hasJsonPath("$",
+                                Matchers.allOf(
+                                        hasJsonPath("$.score", is(String.format("%.2f", evidenceScore))),
+                                        hasJsonPath("$.notes", is(evidenceNote))))
+                        )),
+                hasJsonPath("$.type", is("suggestion"))
+        );
+    }
+
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SuggestionSourceMatcher.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SuggestionSourceMatcher.java
new file mode 100644
index 0000000000..f9d70cef86
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SuggestionSourceMatcher.java
@@ -0,0 +1,28 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.matcher;
+
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.hamcrest.Matchers.is;
+
+import org.hamcrest.Matcher;
+import org.hamcrest.Matchers;
+
+public class SuggestionSourceMatcher {
+
+    private SuggestionSourceMatcher() { }
+
+    // Matcher for a suggestion target
+    public static Matcher<? super Object> matchSuggestionSource(String name, int total) {
+        return Matchers.allOf(
+                hasJsonPath("$.id", is(name)),
+                hasJsonPath("$.total", is(total)),
+                hasJsonPath("$.type", is("suggestionsource"))
+        );
+    }
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SuggestionTargetMatcher.java b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SuggestionTargetMatcher.java
new file mode 100644
index 0000000000..b88b51020e
--- /dev/null
+++ b/dspace-server-webapp/src/test/java/org/dspace/app/rest/matcher/SuggestionTargetMatcher.java
@@ -0,0 +1,29 @@
+/**
+ * The contents of this file are subject to the license and copyright
+ * detailed in the LICENSE and NOTICE files at the root of the source
+ * tree and available online at
+ *
+ * http://www.dspace.org/license/
+ */
+package org.dspace.app.rest.matcher;
+
+import static com.jayway.jsonpath.matchers.JsonPathMatchers.hasJsonPath;
+import static org.hamcrest.Matchers.is;
+
+import org.hamcrest.Matcher;
+import org.hamcrest.Matchers;
+
+public class SuggestionTargetMatcher {
+
+    private SuggestionTargetMatcher() { }
+
+    // Matcher for a suggestion target
+    public static Matcher<? super Object> matchSuggestionTarget(String name, String source, int total) {
+        return Matchers.allOf(
+                hasJsonPath("$.display", is(name)),
+                hasJsonPath("$.source", is(source)),
+                hasJsonPath("$.total", is(total)),
+                hasJsonPath("$.type", is("suggestiontarget"))
+        );
+    }
+}
diff --git a/dspace-server-webapp/src/test/java/org/dspace/external/provider/impl/MockOpenAIREFundingDataProvider.java b/dspace-server-webapp/src/test/java/org/dspace/external/provider/impl/MockOpenAIREFundingDataProvider.java
index baf1041ab5..ef2a3dadc3 100644
--- a/dspace-server-webapp/src/test/java/org/dspace/external/provider/impl/MockOpenAIREFundingDataProvider.java
+++ b/dspace-server-webapp/src/test/java/org/dspace/external/provider/impl/MockOpenAIREFundingDataProvider.java
@@ -14,7 +14,7 @@ import javax.xml.bind.JAXBException;
 
 import eu.openaire.jaxb.helper.OpenAIREHandler;
 import eu.openaire.jaxb.model.Response;
-import org.dspace.external.OpenAIRERestConnector;
+import org.dspace.external.OpenaireRestConnector;
 import org.mockito.AdditionalMatchers;
 import org.mockito.ArgumentMatchers;
 import org.mockito.Mockito;
@@ -26,10 +26,10 @@ import org.mockito.stubbing.Answer;
  * will be resolved against static test files
  * 
  */
-public class MockOpenAIREFundingDataProvider extends OpenAIREFundingDataProvider {
+public class MockOpenAIREFundingDataProvider extends OpenaireFundingDataProvider {
     @Override
     public void init() throws IOException {
-        OpenAIRERestConnector restConnector = Mockito.mock(OpenAIRERestConnector.class);
+        OpenaireRestConnector restConnector = Mockito.mock(OpenaireRestConnector.class);
 
         when(restConnector.searchProjectByKeywords(ArgumentMatchers.anyInt(), ArgumentMatchers.anyInt(),
                 ArgumentMatchers.startsWith("mushroom"))).thenAnswer(new Answer<Response>() {
diff --git a/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_ack_review_reject.json b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_ack_review_reject.json
new file mode 100644
index 0000000000..2ac1f1a15a
--- /dev/null
+++ b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_ack_review_reject.json
@@ -0,0 +1,34 @@
+{
+  "@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+  ],
+  "actor": {
+    "id": "https://generic-service.com",
+    "name": "Generic Service",
+    "type": "Service"
+  },
+  "context": {
+    "id": "<<object_handle>>",
+    "ietf:cite-as": "https://doi.org/10.4598/12123487",
+    "type": "Document"
+  },
+  "id": "urn:uuid:668f26e0-2c8d-4117-a0d2-ee713523bcb4",
+  "inReplyTo": "<<ldn_offer_review_uuid>>",
+  "object": {
+    "id": "<<object_handle>>",
+    "object": "https://some-organisation.org/resource/0021",
+    "type": "Offer"
+  },
+  "origin": {
+    "id": "https://generic-service.com/system",
+    "inbox": "https://review-service.com/inbox/",
+    "type": "Service"
+  },
+  "target": {
+    "id": "https://some-organisation.org",
+    "inbox": "hop",
+    "type": "Organization"
+  },
+  "type": ["TentativeReject", "coar-notify:ReviewAction"]
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_announce_endorsement.json b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_announce_endorsement.json
new file mode 100644
index 0000000000..ed19159db8
--- /dev/null
+++ b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_announce_endorsement.json
@@ -0,0 +1,49 @@
+{
+	"@context": [
+	   "https://www.w3.org/ns/activitystreams",
+	   "https://purl.org/coar/notify"
+	 ],
+	 "actor": {
+	   "id": "https://overlay-journal.com",
+	   "name": "Overlay Journal",
+	   "type": ["Service"]
+	 }, 
+	 "context": {
+		"id": "<<object>>",
+	   "ietf:cite-as": "https://doi.org/10.5555/12345680",
+	   "type": ["sorg:AboutPage"],
+	   "ietf:item": {
+	     "id": "https://research-organisation.org/repository/preprint/201203/421/content.pdf",
+	     "mediaType": "application/pdf",
+	     "type": [
+	       "Article",
+	       "sorg:ScholarlyArticle"
+	     ]
+	   }
+	 },
+	 "id": "urn:uuid:94ecae35-dcfd-4182-8550-22c7164fe24f",
+	 "object": {
+		"id": "<<object_handle>>",
+		"id_oai": "oai:www.openstarts.units.it:<<object_handle>>",
+	    "id_old": "https://review-service.com/review/geo/202103/0021",
+	   "ietf:cite-as": "https://overlay-journal.com/articles/00001/",
+	   "type": [
+	     "Page",
+	     "sorg:WebPage"
+	   ]
+	 },
+	 "origin": {
+	   "id": "https://overlay-journal.com/system",
+	   "inbox": "https://overlay-journal.com/inbox/",
+	   "type": ["Service"]
+	 },
+	 "target": {
+	   "id": "https://research-organisation.org/repository",
+	   "inbox": "https://research-organisation.org/inbox/",
+	   "type": ["Service"]
+	 },
+	 "type": [
+	   "Announce",
+	   "coar-notify:EndorsementAction"
+	 ]
+ }
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_announce_release.json b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_announce_release.json
new file mode 100644
index 0000000000..6c3dce8c7a
--- /dev/null
+++ b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_announce_release.json
@@ -0,0 +1,49 @@
+{
+  "@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+  ],
+  "actor": {
+    "id": "https://research-organisation.org",
+    "name": "Research Organisation",
+    "type": "Organization"
+  },
+  "context": {
+	"id": "<<object>>",
+    "id_handle": "http://localhost:4000/handle/123456789/1119",
+    "ietf:cite-as": "https://doi.org/10.5555/12345680",
+    "type": "sorg:AboutPage",
+    "ietf:item": {
+      "id": "https://another-research-organisation.org/repository/datasets/item/201203421/data_archive.zip",
+      "mediaType": "application/zip",
+      "type": [
+        "Article",
+        "sorg:Dataset"
+      ]
+    }
+  },
+ "id": "urn:uuid:94ecae35-dcfd-4182-8550-22c7164fe24f",
+  "object": {
+    "oldas:object": "https://another-research-organisation.org/repository/datasets/item/201203421/",
+    "as:object": "newValue",
+    "oldas:relationship": "http://purl.org/vocab/frbr/core#supplement",    
+    "as:relationship": "somethingElse",
+    "as:subject": "<<object_handle>>",    
+	"id": "<<object_handle>>",
+    "type": "Relationship"
+  },
+  "origin": {
+    "id": "https://review-service.com/inbox/about/",
+    "inbox": "https://review-service.com/inbox/",
+    "type": "Service"
+  },
+  "target": {
+    "id": "https://another-research-organisation.org/repository",
+    "inbox": "https://another-research-organisation.org/inbox/",
+    "type": "Service"
+  },
+  "type": [
+    "Announce",
+    "coar-notify:RelationshipAction"
+  ]
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_announce_review.json b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_announce_review.json
new file mode 100644
index 0000000000..db1490f2cc
--- /dev/null
+++ b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_announce_review.json
@@ -0,0 +1,48 @@
+{
+  "@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+  ],
+  "actor": {
+    "id": "https://review-service.com",
+    "name": "Review Service",
+    "type": "Service"
+  },
+  "context": {
+	"id": "<<object>>",
+	"ietf:cite-as": "https://doi.org/10.5555/12345680",
+    "type": "sorg:AboutPage",
+    "ietf:item": {
+      "id": "https://research-organisation.org/repository/preprint/201203/421/content.pdf",
+      "mediaType": "application/pdf",
+      "type": [
+        "Article",
+        "sorg:ScholarlyArticle"
+      ]
+    }
+  },
+  "id": "urn:uuid:2f4ec582-109e-4952-a94a-b7d7615a8c70",
+  "inReplyTo": "urn:uuid:0370c0fb-bb78-4a9b-87f5-bed307a509dd",
+  "object": {
+	"id": "<<object_handle>>",
+    "ietf:cite-as": "https://doi.org/10.3214/987654",
+    "type": [
+      "Document",
+      "sorg:Review"
+    ]
+  },
+  "origin": {
+    "id": "https://review-service.com/system",
+    "inbox": "https://review-service.com/inbox/",
+    "type": "Service"
+  },
+  "target": {
+    "id": "https://generic-service.com/system",
+    "inbox": "https://generic-service.com/system/inbox/",
+    "type": "Service"
+  },
+  "type": [
+    "Announce",
+    "coar-notify:ReviewAction"
+  ]
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_endorsement.json b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_endorsement.json
new file mode 100644
index 0000000000..39f6411a55
--- /dev/null
+++ b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_endorsement.json
@@ -0,0 +1,39 @@
+{
+"@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+],
+"actor": {
+    "id": "https://orcid.org/0000-0002-1825-0097",
+    "name": "Josiah Carberry",
+    "type": ["Person"]
+},
+"id": "123456789",
+"object": {
+    "id": "https://overlay-journal.com/articles/00001/",
+    "ietf:cite-as": "https://doi.org/10.5555/12345680",
+    "type": "sorg:AboutPage",
+    "ietf:item": {
+        "id": "https://research-organisation.org/repository/preprint/201203/421/content.pdf",
+        "mediaType": "application/pdf",
+        "type": [
+          "Article",
+          "sorg:ScholarlyArticle"
+        ]
+	}
+},
+"origin": {
+    "id": "https://research-organisation.org/repository",
+    "inbox": "https://research-organisation.org/inbox/",
+    "type": "Service"
+},
+"target": {
+    "id": "https://overlay-journal.com/system",
+    "inbox": "https://overlay-journal.com/inbox/",
+    "type": "Service"
+},
+"type": [
+    "Offer",
+    "coar-notify:EndorsementAction"
+]
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_endorsement_badrequest.json b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_endorsement_badrequest.json
new file mode 100644
index 0000000000..2371fc54c3
--- /dev/null
+++ b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_endorsement_badrequest.json
@@ -0,0 +1,39 @@
+{
+  "@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+  ],
+  "actor": {
+    "id": "https://orcid.org/0000-0002-1825-0097",
+    "name": "Josiah Carberry",
+    "type": ["Person"]
+  },
+    "id": "123456789",
+	"object": {
+	    "id": "https://overlay-journal.com/articles/00001/",
+	    "ietf:cite-as": "https://doi.org/10.5555/12345680",
+	    "type": ["sorg:AboutPage"],
+	    "ietf:item": {
+	        "id": "https://research-organisation.org/repository/preprint/201203/421/content.pdf",
+	        "mediaType": "application/pdf",
+	        "type": [
+		        "Article",
+		        "sorg:ScholarlyArticle"
+	      ]
+	    }
+	},
+    "origin": {
+    "id": "https://research-organisation.org/repository",
+    "inbox": "https://research-organisation.org/inbox/",
+    "type": ["Service"]
+  },
+    "target": {
+    "id": "https://overlay-journal.com/system",
+    "inbox": "https://overlay-journal.com/inbox/",
+    "type": ["Service"]
+  },
+	"type": [
+	    "Offer",
+	    "coar-notify:EndorsementAction"
+	  ]
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_endorsement_object.json b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_endorsement_object.json
new file mode 100644
index 0000000000..7af079acba
--- /dev/null
+++ b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_endorsement_object.json
@@ -0,0 +1,38 @@
+{
+    "@context": [
+    "https://www.w3.org/ns/activitystreams", "https://purl.org/coar/notify"
+   	],
+    "actor": {
+        "id": "https://orcid.org/0000-0002-1825-0097",
+        "name": "Josiah Carberry",
+        "type": ["Person"]
+   	},
+    "id": "urn:uuid:0370c0fb-bb78-4a9b-87f5-bed307a509dd",
+    "object": {
+        "id": "<<object>>",
+        "ietf:cite-as": "https://doi.org/10.5555/12345680",
+        "type": ["sorg:AboutPage"],
+        "ietf:item": {
+            "id": "https://research-organisation.org/repository/preprint/201203/421/content.pdf",
+            "mediaType": "application/pdf",
+            "type": [
+	            "Article",
+	            "sorg:ScholarlyArticle"
+	        ]
+        }
+    },
+    "origin": {
+	    "id": "https://research-organisation.org/repository",
+	    "inbox": "https://research-organisation.org/inbox/",
+	    "type": ["Service"]
+    },
+    "target": {
+	    "id": "https://overlay-journal.com/system",
+	    "inbox": "https://overlay-journal.com/inbox/",
+	    "type": ["Service"]
+    },
+    "type": [
+        "Offer",
+        "coar-notify:EndorsementAction"
+    ]
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_review.json b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_review.json
new file mode 100644
index 0000000000..9a20adcda5
--- /dev/null
+++ b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_review.json
@@ -0,0 +1,39 @@
+{
+  "@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+  ],
+  "actor": {
+    "id": "https://orcid.org/0000-0002-1825-0097",
+    "name": "Josiah Carberry",
+    "type": "Person"
+  },
+  "id": "urn:uuid:0370c0fb-bb78-4a9b-87f5-bed307a509de",
+  "object": {
+    "id": "<<object_handle>>",
+    "ietf:cite-as": "https://doi.org/10.5555/12345680",
+    "type": "sorg:AboutPage",
+    "ietf:item": {
+      "id": "url.pdf",
+      "mediaType": "applicationpdf",
+      "type": [
+        "Article",
+        "sorg:ScholarlyArticle"
+      ]
+    }
+  },
+  "origin": {
+    "id": "https://research-organisation.org/repository",
+    "inbox": "https://review-service.com/inbox/",
+    "type": "Service"
+  },
+  "target": {
+    "id": "https://review-service.com/system",
+    "inbox": "https://review-service.com/inbox/",
+    "type": "Service"
+  },
+  "type": [
+    "Offer",
+    "coar-notify:ReviewAction"
+  ]
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_review2.json b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_review2.json
new file mode 100644
index 0000000000..973ea946f6
--- /dev/null
+++ b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_review2.json
@@ -0,0 +1,39 @@
+{
+  "@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+  ],
+  "actor": {
+    "id": "https://orcid.org/0000-0002-1825-0097",
+    "name": "Josiah Carberry",
+    "type": "Person"
+  },
+  "id": "urn:uuid:0370c0fb-bb78-4a9b-87f5-bed307a509df",
+  "object": {
+    "id": "<<object_handle>>",
+    "ietf:cite-as": "https://doi.org/10.5555/12345680",
+    "type": "sorg:AboutPage",
+    "ietf:item": {
+      "id": "url.pdf",
+      "mediaType": "applicationpdf",
+      "type": [
+        "Article",
+        "sorg:ScholarlyArticle"
+      ]
+    }
+  },
+  "origin": {
+    "id": "https://research-organisation.org/repository",
+    "inbox": "https://review-service.com/inbox/",
+    "type": "Service"
+  },
+  "target": {
+    "id": "https://review-service.com/system",
+    "inbox": "https://review-service.com/inbox/",
+    "type": "Service"
+  },
+  "type": [
+    "Offer",
+    "coar-notify:ReviewAction"
+  ]
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_review3.json b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_review3.json
new file mode 100644
index 0000000000..5b857fa664
--- /dev/null
+++ b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_offer_review3.json
@@ -0,0 +1,39 @@
+{
+  "@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+  ],
+  "actor": {
+    "id": "https://orcid.org/0000-0002-1825-0097",
+    "name": "Josiah Carberry",
+    "type": "Person"
+  },
+  "id": "urn:uuid:0370c0fb-bb78-4a9b-87f5-bed308a509da",
+  "object": {
+    "id": "<<object_handle>>",
+    "ietf:cite-as": "https://doi.org/10.5555/12345680",
+    "type": "sorg:AboutPage",
+    "ietf:item": {
+      "id": "url.pdf",
+      "mediaType": "applicationpdf",
+      "type": [
+        "Article",
+        "sorg:ScholarlyArticle"
+      ]
+    }
+  },
+  "origin": {
+    "id": "https://research-organisation.org/repository",
+    "inbox": "https://review-service.com/inbox/",
+    "type": "Service"
+  },
+  "target": {
+    "id": "https://review-service.com/system",
+    "inbox": "https://review-service.com/inbox/",
+    "type": "Service"
+  },
+  "type": [
+    "Offer",
+    "coar-notify:ReviewAction"
+  ]
+}
\ No newline at end of file
diff --git a/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_origin_inbox_unregistered.json b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_origin_inbox_unregistered.json
new file mode 100644
index 0000000000..fdeb340fd2
--- /dev/null
+++ b/dspace-server-webapp/src/test/resources/org/dspace/app/rest/ldn_origin_inbox_unregistered.json
@@ -0,0 +1,49 @@
+{
+	"@context": [
+	   "https://www.w3.org/ns/activitystreams",
+	   "https://purl.org/coar/notify"
+	 ],
+	 "actor": {
+	   "id": "https://overlay-journal.com",
+	   "name": "Overlay Journal",
+	   "type": ["Service"]
+	 }, 
+	 "context": {
+		"id": "<<object>>",
+	   "ietf:cite-as": "https://doi.org/10.5555/12345680",
+	   "type": ["sorg:AboutPage"],
+	   "ietf:item": {
+	     "id": "https://research-organisation.org/repository/preprint/201203/421/content.pdf",
+	     "mediaType": "application/pdf",
+	     "type": [
+	       "Article",
+	       "sorg:ScholarlyArticle"
+	     ]
+	   }
+	 },
+	 "id": "urn:uuid:94ecae35-dcfd-4182-8550-22c7164fe23f",
+	 "object": {
+		"id": "<<object_handle>>",
+		"id_oai": "oai:www.openstarts.units.it:<<object_handle>>",
+	    "id_old": "https://review-service.com/review/geo/202103/0021",
+	   "ietf:cite-as": "https://overlay-journal.com/articles/00001/",
+	   "type": [
+	     "Page",
+	     "sorg:WebPage"
+	   ]
+	 },
+	 "origin": {
+	   "id": "https://overlay-journal.com/system",
+	   "inbox": "https://letsfake.it/inbox/",
+	   "type": ["Service"]
+	 },
+	 "target": {
+	   "id": "https://research-organisation.org/repository",
+	   "inbox": "https://research-organisation.org/inbox/",
+	   "type": ["Service"]
+	 },
+	 "type": [
+	   "Announce",
+	   "coar-notify:EndorsementAction"
+	 ]
+ }
\ No newline at end of file
diff --git a/dspace/config/crosswalks/oai/transformers/openaire4.xsl b/dspace/config/crosswalks/oai/transformers/openaire4.xsl
index cece890450..8ac703609d 100644
--- a/dspace/config/crosswalks/oai/transformers/openaire4.xsl
+++ b/dspace/config/crosswalks/oai/transformers/openaire4.xsl
@@ -1,5 +1,5 @@
 <?xml version="1.0" encoding="UTF-8"?>
-<!-- Following OpenAIRE Guidelines 4 -->
+<!-- Following Openaire Guidelines 4 -->
 <xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform"
     xmlns:doc="http://www.lyncode.com/xoai">
     <xsl:output indent="yes" method="xml" omit-xml-declaration="yes"/>
@@ -12,7 +12,7 @@
 
     <!-- 
         Formatting dc.date.issued
-        based on what OpenAIRE4 specifies for issued dates 
+        based on what Openaire4 specifies for issued dates 
         https://openaire-guidelines-for-literature-repository-managers.readthedocs.io/en/v4.0.0/field_publicationdate.html
     -->
     <xsl:template
diff --git a/dspace/config/dspace.cfg b/dspace/config/dspace.cfg
index d38ffd6433..d6ae12b151 100644
--- a/dspace/config/dspace.cfg
+++ b/dspace/config/dspace.cfg
@@ -780,7 +780,7 @@ event.dispatcher.default.class = org.dspace.event.BasicDispatcher
 # Add rdf here, if you are using dspace-rdf to export your repository content as RDF.
 # Add iiif here, if you are using dspace-iiif.
 # Add orcidqueue here, if the integration with ORCID is configured and wish to enable the synchronization queue functionality
-event.dispatcher.default.consumers = versioning, discovery, eperson, submissionconfig
+event.dispatcher.default.consumers = versioning, discovery, eperson, submissionconfig, qaeventsdelete, ldnmessage
 
 # The noindex dispatcher will not create search or browse indexes (useful for batch item imports)
 event.dispatcher.noindex.class = org.dspace.event.BasicDispatcher
@@ -788,7 +788,7 @@ event.dispatcher.noindex.consumers = eperson
 
 # consumer to maintain the discovery index
 event.consumer.discovery.class = org.dspace.discovery.IndexEventConsumer
-event.consumer.discovery.filters = Community|Collection|Item|Bundle|Site+Add|Create|Modify|Modify_Metadata|Delete|Remove
+event.consumer.discovery.filters = Community|Collection|Item|Bundle|Site|LDN_MESSAGE+Add|Create|Modify|Modify_Metadata|Delete|Remove
 
 # consumer related to EPerson changes
 event.consumer.eperson.class = org.dspace.eperson.EPersonConsumer
@@ -806,6 +806,10 @@ event.consumer.rdf.filters = Community|Collection|Item|Bundle|Bitstream|Site+Add
 #event.consumer.test.class = org.dspace.event.TestConsumer
 #event.consumer.test.filters = All+All
 
+# qaevents consumer to delete events related to deleted items
+event.consumer.qaeventsdelete.class = org.dspace.qaevent.QAEventsDeleteCascadeConsumer
+event.consumer.qaeventsdelete.filters = Item+Delete
+
 # consumer to maintain versions
 event.consumer.versioning.class = org.dspace.versioning.VersioningConsumer
 event.consumer.versioning.filters = Item+Install
@@ -822,6 +826,10 @@ event.consumer.iiif.filters = Item+Modify:Item+Modify_Metadata:Item+Delete:Item+
 event.consumer.orcidqueue.class = org.dspace.orcid.consumer.OrcidQueueConsumer
 event.consumer.orcidqueue.filters = Item+Install|Modify|Modify_Metadata|Delete|Remove
 
+# consumer to store LDN Messages
+event.consumer.ldnmessage.class = org.dspace.app.ldn.LDNMessageConsumer
+event.consumer.ldnmessage.filters = Item+Install
+
 # item submission config reload consumer
 event.consumer.submissionconfig.class = org.dspace.submit.consumer.SubmissionConfigConsumer
 event.consumer.submissionconfig.filters = Collection+Modify_Metadata
@@ -928,7 +936,8 @@ registry.metadata.load = schema-publicationVolume-types.xml
 registry.metadata.load = openaire4-types.xml
 registry.metadata.load = dspace-types.xml
 registry.metadata.load = iiif-types.xml
-
+registry.metadata.load = datacite-types.xml
+registry.metadata.load = coar-types.xml
 
 #---------------------------------------------------------------#
 #-----------------UI-Related CONFIGURATIONS---------------------#
@@ -1085,7 +1094,6 @@ webui.preview.brand.fontpoint = 12
 # Solr:
 # ItemCountDAO.class = org.dspace.browse.ItemCountDAOSolr
 
-
 ###### Browse Configuration ######
 #
 # Define the DAO class to use this must meet your storage choice for
@@ -1646,6 +1654,7 @@ include = ${module_dir}/irus-statistics.cfg
 include = ${module_dir}/oai.cfg
 include = ${module_dir}/openaire-client.cfg
 include = ${module_dir}/orcid.cfg
+include = ${module_dir}/qaevents.cfg
 include = ${module_dir}/rdf.cfg
 include = ${module_dir}/rest.cfg
 include = ${module_dir}/iiif.cfg
@@ -1655,6 +1664,7 @@ include = ${module_dir}/solrauthority.cfg
 include = ${module_dir}/researcher-profile.cfg
 include = ${module_dir}/spring.cfg
 include = ${module_dir}/submission-curation.cfg
+include = ${module_dir}/suggestion.cfg
 include = ${module_dir}/sword-client.cfg
 include = ${module_dir}/sword-server.cfg
 include = ${module_dir}/swordv2-server.cfg
@@ -1663,3 +1673,4 @@ include = ${module_dir}/usage-statistics.cfg
 include = ${module_dir}/versioning.cfg
 include = ${module_dir}/workflow.cfg
 include = ${module_dir}/external-providers.cfg
+include = ${module_dir}/ldn.cfg
diff --git a/dspace/config/emails/coar_notify_accepted b/dspace/config/emails/coar_notify_accepted
new file mode 100644
index 0000000000..78ab0da07d
--- /dev/null
+++ b/dspace/config/emails/coar_notify_accepted
@@ -0,0 +1,27 @@
+## Notification email sent when a request to review an item has been accepted by the service
+##
+## Parameters: {0} Service Name
+##             {1} Item Name
+##             {2} Service URL
+##             {3} Item URL
+##             {4} Submitter's Name
+##             {5} Date of the received LDN notification
+##
+##
+#set($subject = "DSpace: The Service ${params[0]} has accepted to review the Item ""${params[1]}""")
+
+An acceptance notification has been received by the service: ${params[0]}
+for the Item: ${params[1]}
+
+Here is a more detailed report:
+Item: ${params[1]}
+Item URL: ${params[3]}
+Submitted by: ${params[4]}
+
+Has a new status: ONGOING REVIEW
+
+By Service: ${params[0]}
+Service URL: ${params[2]}
+Date: ${params[5]}
+
+The ${config.get('dspace.name')} Team
diff --git a/dspace/config/emails/coar_notify_endorsed b/dspace/config/emails/coar_notify_endorsed
new file mode 100644
index 0000000000..aaf06b3efd
--- /dev/null
+++ b/dspace/config/emails/coar_notify_endorsed
@@ -0,0 +1,27 @@
+## Notification email sent when an item has been endorsed by a service
+##
+## Parameters: {0} Service Name
+##             {1} Item Name
+##             {2} Service URL
+##             {3} Item URL
+##             {4} Submitter's Name
+##             {5} Date of the received LDN notification
+##
+##
+#set($subject = "DSpace: The Service ${params[0]} has endorsed the Item ""${params[1]}""")
+
+An endorsement announce notification has been received by the service: ${params[0]}
+for the Item: ${params[1]}
+
+Here is a more detailed report:
+Item: ${params[1]}
+Item URL: ${params[3]}
+Submitted by: ${params[4]}
+
+Has a new status: ENDORSED
+
+By Service: ${params[0]}
+Service URL: ${params[2]}
+Date: ${params[5]}
+
+The ${config.get('dspace.name')} Team
diff --git a/dspace/config/emails/coar_notify_rejected b/dspace/config/emails/coar_notify_rejected
new file mode 100644
index 0000000000..ddba3366ba
--- /dev/null
+++ b/dspace/config/emails/coar_notify_rejected
@@ -0,0 +1,27 @@
+## Notification email sent when a request to review an item has been rejected by the service
+##
+## Parameters: {0} Service Name
+##             {1} Item Name
+##             {2} Service URL
+##             {3} Item URL
+##             {4} Submitter's Name
+##             {5} Date of the received LDN notification
+##
+##
+#set($subject = "DSpace: The Service ${params[0]} has refused to review the Item ""${params[1]}""")
+
+A rejection notification has been received by the service: ${params[0]}
+for the Item: ${params[1]}
+
+Here is a more detailed report:
+Item: ${params[1]}
+Item URL: ${params[3]}
+Submitted by: ${params[4]}
+
+Has a new update: REJECTED REVIEW REQUEST
+
+By Service: ${params[0]}
+Service URL: ${params[2]}
+Date: ${params[5]}
+
+The ${config.get('dspace.name')} Team
diff --git a/dspace/config/emails/coar_notify_relationship b/dspace/config/emails/coar_notify_relationship
new file mode 100644
index 0000000000..7a8782b5e9
--- /dev/null
+++ b/dspace/config/emails/coar_notify_relationship
@@ -0,0 +1,29 @@
+## Notification email sent that a resource has been related by a service
+##
+## Parameters: {0} Service Name
+##             {1} Item Name
+##             {2} Service URL
+##             {3} Item URL
+##             {4} Submitter's Name
+##             {5} Date of the received LDN notification
+##             {6} LDN notification
+##             {7} Item
+##
+##
+#set($subject = "DSpace: The Service ${params[0]} has related a Resource ""${params[6].object.subject}""")
+
+A relationship announce notification has been received relating to the Item: ${params[1]}
+
+Here is a more detailed report:
+Item: ${params[1]}
+Item URL: ${params[3]}
+Submitted by: ${params[4]}
+Linked Resource URL: ${params[6].object.subject}
+
+Has a new status: RELATED
+
+By Service: ${params[0]}
+Service URL: ${params[2]}
+Date: ${params[5]}
+
+The ${config.get('dspace.name')} Team
diff --git a/dspace/config/emails/coar_notify_reviewed b/dspace/config/emails/coar_notify_reviewed
new file mode 100644
index 0000000000..c25dd9b51d
--- /dev/null
+++ b/dspace/config/emails/coar_notify_reviewed
@@ -0,0 +1,27 @@
+## Notification email sent when an item has been reviewed by a service
+##
+## Parameters: {0} Service Name
+##             {1} Item Name
+##             {2} Service URL
+##             {3} Item URL
+##             {4} Submitter's Name
+##             {5} Date of the received LDN notification
+##
+##
+#set($subject = "DSpace: The Service ${params[0]} has reviewed the Item ""${params[1]}""")
+
+A review announce notification has been received by the service: ${params[0]}
+for the Item: ${params[1]}
+
+Here is a more detailed report:
+Item: ${params[1]}
+Item URL: ${params[3]}
+Submitted by: ${params[4]}
+
+Has a new status: REVIEWED
+
+By Service: ${params[0]}
+Service URL: ${params[2]}
+Date: ${params[5]}
+
+The ${config.get('dspace.name')} Team
diff --git a/dspace/config/emails/qaevent_admin_notification b/dspace/config/emails/qaevent_admin_notification
new file mode 100644
index 0000000000..6c75f89a8f
--- /dev/null
+++ b/dspace/config/emails/qaevent_admin_notification
@@ -0,0 +1,13 @@
+## E-mail sent to notify Administrator of new Withdrawn/Reinstate request
+##
+## Parameters: {0} Type of request 'topic'
+##             {1} resource id
+##             {2} reason
+##
+#set($subject = "Notification about ${params[0]} Request")
+
+Item Details:
+
+Type of request: ${params[0]}
+Relatem to item: ${params[1]}
+Reason: ${params[2]}
\ No newline at end of file
diff --git a/dspace/config/hibernate.cfg.xml b/dspace/config/hibernate.cfg.xml
index 3cc0623c34..6cc1020c47 100644
--- a/dspace/config/hibernate.cfg.xml
+++ b/dspace/config/hibernate.cfg.xml
@@ -62,6 +62,8 @@
         <mapping class="org.dspace.content.Site"/>
         <mapping class="org.dspace.content.WorkspaceItem"/>
 
+        <mapping class="org.dspace.content.QAEventProcessed" />
+
         <mapping class="org.dspace.eperson.EPerson"/>
         <mapping class="org.dspace.eperson.Group"/>
         <mapping class="org.dspace.eperson.Group2GroupCache"/>
@@ -96,5 +98,11 @@
 
         <mapping class="org.dspace.supervision.SupervisionOrder"/>
 
+        <mapping class="org.dspace.app.ldn.NotifyServiceEntity"/>
+        <mapping class="org.dspace.app.ldn.NotifyServiceInboundPattern"/>
+
+        <mapping class="org.dspace.app.ldn.LDNMessageEntity"/>
+        <mapping class="org.dspace.app.ldn.NotifyPatternToTrigger"/>
+
     </session-factory>
 </hibernate-configuration>
diff --git a/dspace/config/item-submission.xml b/dspace/config/item-submission.xml
index 1060a33031..1c14df273c 100644
--- a/dspace/config/item-submission.xml
+++ b/dspace/config/item-submission.xml
@@ -185,28 +185,28 @@
             <type>extract</type>
         </step-definition>
 
-        <!-- OpenAIRE submission steps/forms -->
-        <step-definition id="openAIREProjectForm" mandatory="true">
+        <!-- Openaire submission steps/forms -->
+        <step-definition id="openaireProjectForm" mandatory="true">
             <heading>submit.progressbar.describe.stepone</heading>
             <processing-class>org.dspace.app.rest.submit.step.DescribeStep</processing-class>
             <type>submission-form</type>
         </step-definition>
-        <step-definition id="openAIREPersonForm" mandatory="true">
+        <step-definition id="openairePersonForm" mandatory="true">
             <heading>submit.progressbar.describe.stepone</heading>
             <processing-class>org.dspace.app.rest.submit.step.DescribeStep</processing-class>
             <type>submission-form</type>
         </step-definition>
-        <step-definition id="openAIREOrganizationForm" mandatory="true">
+        <step-definition id="openaireOrganizationForm" mandatory="true">
             <heading>submit.progressbar.describe.stepone</heading>
             <processing-class>org.dspace.app.rest.submit.step.DescribeStep</processing-class>
             <type>submission-form</type>
         </step-definition>
-        <step-definition id="openAIREPublicationPageoneForm" mandatory="true">
+        <step-definition id="openairePublicationPageoneForm" mandatory="true">
             <heading>submit.progressbar.describe.stepone</heading>
             <processing-class>org.dspace.app.rest.submit.step.DescribeStep</processing-class>
             <type>submission-form</type>
         </step-definition>
-        <step-definition id="openAIREPublicationPagetwoForm" mandatory="true">
+        <step-definition id="openairePublicationPagetwoForm" mandatory="true">
             <heading>submit.progressbar.describe.stepone</heading>
             <processing-class>org.dspace.app.rest.submit.step.DescribeStep</processing-class>
             <type>submission-form</type>
@@ -231,6 +231,13 @@
             <processing-class>org.dspace.app.rest.submit.step.ShowIdentifiersStep</processing-class>
             <type>identifiers</type>
         </step-definition>
+
+        <step-definition id="coarnotify">
+            <heading>submit.progressbar.coarnotify</heading>
+            <processing-class>org.dspace.app.rest.submit.step.NotifyStep</processing-class>
+            <type>coarnotify</type>
+        </step-definition>
+
     </step-definitions>
 
     <!-- The submission-definitions map lays out the detailed definition of -->
@@ -268,6 +275,9 @@
             <!-- Uncomment this step to show when appropriate publisher policies retrieved from SHERPA/RoMEO -->
             <!-- <step id="sherpaPolicies"/> -->
 
+            <!--Step will be COAR Notify services to the item -->
+            <!-- <step id="coarnotify"/> -->
+
             <!--Step will be to Upload the item -->
             <step id="upload"/>
 
@@ -361,13 +371,13 @@
             <step id="license"/>
         </submission-process>
 
-        <!-- OpenAIRE submission processes -->
-        <submission-process name="openAIREPublicationSubmission">
+        <!-- Openaire submission processes -->
+        <submission-process name="openairePublicationSubmission">
             <step id="collection"/>
 
             <!--Step will be to Describe the item. -->
-            <step id="openAIREPublicationPageoneForm"/>
-            <step id="openAIREPublicationPagetwoForm"/>
+            <step id="openairePublicationPageoneForm"/>
+            <step id="openairePublicationPagetwoForm"/>
 
             <!--Step will be to Upload the item -->
             <!-- step id="upload-with-embargo"/-->
@@ -376,17 +386,17 @@
             <!--Step will be to Sign off on the License -->
             <step id="license"/>
         </submission-process>
-        <submission-process name="openAIREPersonSubmission">
+        <submission-process name="openairePersonSubmission">
             <step id="collection"/>
-            <step id="openAIREPersonForm"/>
+            <step id="openairePersonForm"/>
         </submission-process>
-        <submission-process name="openAIREProjectSubmission">
+        <submission-process name="openaireProjectSubmission">
             <step id="collection"/>
-            <step id="openAIREProjectForm"/>
+            <step id="openaireProjectForm"/>
         </submission-process>
-        <submission-process name="openAIREOrganizationSubmission">
+        <submission-process name="openaireOrganizationSubmission">
             <step id="collection"/>
-            <step id="openAIREOrganizationForm"/>
+            <step id="openaireOrganizationForm"/>
         </submission-process>
     </submission-definitions>
 
diff --git a/dspace/config/ldn/announce-relationship b/dspace/config/ldn/announce-relationship
new file mode 100644
index 0000000000..205a61adb4
--- /dev/null
+++ b/dspace/config/ldn/announce-relationship
@@ -0,0 +1,62 @@
+## generate LDN message json when request-review of an item
+##
+## Parameters: {0} config 'dspace.ui.url'
+##             {1} config 'ldn.notify.inbox'
+##             {2} config 'dspace.name'
+##             {3} Notify Service url
+##             {4} Notify Service ldnUrl
+##             {5} 'dspace.ui.url'/handle/xxxx/yyy
+##             {6} metadata value of 'dc.identifier.uri'
+##             {7} the url to the primary bitstream or the first bitstream in the ORIGINAL bundle if there is no primary bitstream. The url is 'dspace.ui.url'/bitstreams/:uuid/download
+##             {8} the bitstream  MimeType or get User Format MimeType if getFormat is 'Unknown'
+##             {9} id of the created LDNMessage
+##            {10} uri of the related resource
+##            {11} relationship type, i.e. http://purl.org/vocab/frbr/core#supplement
+##            {12} urn:uuid of the relation (randomly generated)
+
+{
+  "@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+  ],
+  "actor": {
+    "id": "${params[0]}",
+    "name": "${params[2]}",
+    "type": "Service"
+  },
+  "context": {
+    "id": "${params[5]}",
+    "ietf:cite-as": "${params[6]}",
+    "ietf:item": {
+      "id": "${params[7]}",
+      "mediaType": "${params[8]}",
+      "type": [
+        "Article",
+        "sorg:ScholarlyArticle"
+      ]
+    },
+    "type": "sorg:AboutPage"
+  },
+  "id": "${params[9]}",
+  "object": {
+    "as:object": "${params[10]}",
+    "as:relationship": "${params[11]}",
+    "as:subject": "${params[5]}",
+    "id": "${params[12]}",
+    "type": "Relationship"
+  },
+  "origin": {
+    "id": "${params[0]}",
+    "inbox": "${params[1]}",
+    "type": "Service"
+  },
+  "target": {
+    "id": "${params[3]}",
+    "inbox": "${params[4]}",
+    "type": "Service"
+  },
+  "type": [
+    "Announce",
+    "coar-notify:RelationshipAction"
+  ]
+}
\ No newline at end of file
diff --git a/dspace/config/ldn/request-endorsement b/dspace/config/ldn/request-endorsement
new file mode 100644
index 0000000000..443a702915
--- /dev/null
+++ b/dspace/config/ldn/request-endorsement
@@ -0,0 +1,52 @@
+## generate LDN message json when request-endorsement of an item
+##
+## Parameters: {0} config 'dspace.ui.url'
+##             {1} config 'ldn.notify.inbox'
+##             {2} config 'dspace.name'
+##             {3} Notify Service url
+##             {4} Notify Service ldnUrl
+##             {5} 'dspace.ui.url'/handle/xxxx/yyy
+##             {6} metadata value of 'dc.identifier.uri'
+##             {7} the url to the primary bitstream or the first bitstream in the ORIGINAL bundle if there is no primary bitstream. The url is 'dspace.ui.url'/bitstreams/:uuid/download
+##             {8} the bitstream  MimeType or get User Format MimeType if getFormat is 'Unknown'
+##             {9} id of the created LDNMessage
+
+{
+  "@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+  ],
+  "actor": {
+    "id": "${params[0]}",
+    "name": "${params[2]}",
+    "type": "Service"
+  },
+  "id": "${params[9]}",
+  "object": {
+    "id": "${params[5]}",
+    "ietf:cite-as": "${params[6]}",
+    "type": "sorg:AboutPage",
+    "ietf:item": {
+      "id": "${params[7]}",
+      "mediaType": "${params[8]}",
+      "type": [
+        "Article",
+        "sorg:ScholarlyArticle"
+      ]
+    }
+  },
+  "origin": {
+    "id": "${params[0]}",
+    "inbox": "${params[1]}",
+    "type": "Service"
+  },
+  "target": {
+    "id": "${params[3]}",
+    "inbox": "${params[4]}",
+    "type": "Service"
+  },
+  "type": [
+    "Offer",
+    "coar-notify:EndorsementAction"
+  ]
+}
\ No newline at end of file
diff --git a/dspace/config/ldn/request-ingest b/dspace/config/ldn/request-ingest
new file mode 100644
index 0000000000..701f3929c8
--- /dev/null
+++ b/dspace/config/ldn/request-ingest
@@ -0,0 +1,52 @@
+## generate LDN message json when request-ingest of an item
+##
+## Parameters: {0} config 'dspace.ui.url'
+##             {1} config 'ldn.notify.inbox'
+##             {2} config 'dspace.name'
+##             {3} Notify Service url
+##             {4} Notify Service ldnUrl
+##             {5} 'dspace.ui.url'/handle/xxxx/yyy
+##             {6} metadata value of 'dc.identifier.uri'
+##             {7} the url to the primary bitstream or the first bitstream in the ORIGINAL bundle if there is no primary bitstream. The url is 'dspace.ui.url'/bitstreams/:uuid/download
+##             {8} the bitstream  MimeType or get User Format MimeType if getFormat is 'Unknown'
+##             {9} id of the created LDNMessage
+
+{
+  "@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+  ],
+  "actor": {
+    "id": "${params[0]}",
+    "name": "${params[2]}",
+    "type": "Service"
+  },
+  "id": "${params[9]}",
+  "object": {
+    "id": "${params[5]}",
+    "ietf:cite-as": "${params[6]}",
+    "type": "sorg:AboutPage",
+    "ietf:item": {
+      "id": "${params[7]}",
+      "mediaType": "${params[8]}",
+      "type": [
+        "Article",
+        "sorg:ScholarlyArticle"
+      ]
+    }
+  },
+  "origin": {
+    "id": "${params[0]}",
+    "inbox": "${params[1]}",
+    "type": "Service"
+  },
+  "target": {
+    "id": "${params[3]}",
+    "inbox": "${params[4]}",
+    "type": "Service"
+  },
+  "type": [
+    "Offer",
+    "coar-notify:IngestAction"
+  ]
+}
\ No newline at end of file
diff --git a/dspace/config/ldn/request-review b/dspace/config/ldn/request-review
new file mode 100644
index 0000000000..01f177b6cc
--- /dev/null
+++ b/dspace/config/ldn/request-review
@@ -0,0 +1,52 @@
+## generate LDN message json when request-review of an item
+##
+## Parameters: {0} config 'dspace.ui.url'
+##             {1} config 'ldn.notify.inbox'
+##             {2} config 'dspace.name'
+##             {3} Notify Service url
+##             {4} Notify Service ldnUrl
+##             {5} 'dspace.ui.url'/handle/xxxx/yyy
+##             {6} metadata value of 'dc.identifier.uri'
+##             {7} the url to the primary bitstream or the first bitstream in the ORIGINAL bundle if there is no primary bitstream. The url is 'dspace.ui.url'/bitstreams/:uuid/download
+##             {8} the bitstream  MimeType or get User Format MimeType if getFormat is 'Unknown'
+##             {9} id of the created LDNMessage
+
+{
+  "@context": [
+    "https://www.w3.org/ns/activitystreams",
+    "https://purl.org/coar/notify"
+  ],
+  "actor": {
+    "id": "${params[0]}",
+    "name": "${params[2]}",
+    "type": "Service"
+  },
+  "id": "${params[9]}",
+  "object": {
+    "id": "${params[5]}",
+    "ietf:cite-as": "${params[6]}",
+    "type": "sorg:AboutPage",
+    "ietf:item": {
+      "id": "${params[7]}",
+      "mediaType": "${params[8]}",
+      "type": [
+        "Article",
+        "sorg:ScholarlyArticle"
+      ]
+    }
+  },
+  "origin": {
+    "id": "${params[0]}",
+    "inbox": "${params[1]}",
+    "type": "Service"
+  },
+  "target": {
+    "id": "${params[3]}",
+    "inbox": "${params[4]}",
+    "type": "Service"
+  },
+  "type": [
+    "Offer",
+    "coar-notify:ReviewAction"
+  ]
+}
\ No newline at end of file
diff --git a/dspace/config/local.cfg.EXAMPLE b/dspace/config/local.cfg.EXAMPLE
index 7176ed275a..239e0f4757 100644
--- a/dspace/config/local.cfg.EXAMPLE
+++ b/dspace/config/local.cfg.EXAMPLE
@@ -240,4 +240,9 @@ db.schema = public
 #spring.servlet.multipart.max-file-size = 512MB
 
 # Maximum size of a multipart request (i.e. max total size of all files in one request)
-#spring.servlet.multipart.max-request-size = 512MB
\ No newline at end of file
+#spring.servlet.multipart.max-request-size = 512MB
+
+########################
+#  LDN INBOX SETTINGS  #
+########################
+ldn.enabled = true
diff --git a/dspace/config/modules/ldn.cfg b/dspace/config/modules/ldn.cfg
new file mode 100644
index 0000000000..4979d265cc
--- /dev/null
+++ b/dspace/config/modules/ldn.cfg
@@ -0,0 +1,54 @@
+#---------------------------------------------------------------#
+#---------------COAR NOTIFY LDN CONFIGURATION-------------------#
+#---------------------------------------------------------------#
+#     Configuration properties used  by Coar Notify and ldn     #
+#---------------------------------------------------------------#
+
+
+# check on the IP number on incoming LDN Messages against the IP Range configured
+# on the Notify Service known and found as the message sender
+# ldn.ip-range.enabled = false
+
+#### LDN CONFIGURATION ####
+# To enable the LDN service, set to true.
+ldn.enabled = true
+
+#LDN message inbox endpoint
+ldn.notify.inbox = ${dspace.server.url}/ldn/inbox
+
+# List the external services IDs for review/endorsement
+# These IDs needs to be configured in the input-form.xml as well
+# These IDs must contain only the hostname and the resource path 
+# Do not include any protocol
+# Each IDs must match with the ID returned by the external service 
+# in the JSON-LD Actor field
+#service.service-id.ldn = 
+
+# LDN Queue extractor elaborates LDN Message entities of the queue
+ldn.queue.extractor.cron = 0/20 * * * * ?
+
+# LDN Queue timeout checks LDN Message Entities relation with the queue
+ldn.queue.timeout.checker.cron = 0 0 */1 * * ? 
+
+# LDN Queue extractor elaborates LDN Message entities with max_attempts < than ldn.processor.max.attempts
+ldn.processor.max.attempts = 5
+
+# LDN Queue extractor sets LDN Message Entity queue_timeout property every time it tryies a new elaboration
+# of the message. LDN Message with a future queue_timeout is not elaborated. This property is used to calculateas:
+# a new timeout, such as: new_timeout = now + ldn.processor.queue.msg.timeout (in minutes)
+ldn.processor.queue.msg.timeout = 60
+
+# Blocks the storage of incoming LDN messages with unknown Notify Service (origin)
+ldn.notify.inbox.block-untrusted = true
+
+# Blocks the storage of incoming LDN messages with known Notify Service (origin)
+# and out-of-range IP
+ldn.notify.inbox.block-untrusted-ip = true
+
+# this is the medatada used to retrieve the relation with external items when sending relationship requests
+#ldn.notify.relation.metadata = dc.relation
+
+
+# EMAIL CONFIGURATION
+
+ldn.notification.email = ${mail.admin}
diff --git a/dspace/config/modules/openaire-client.cfg b/dspace/config/modules/openaire-client.cfg
index ded99d0120..26d36fa816 100644
--- a/dspace/config/modules/openaire-client.cfg
+++ b/dspace/config/modules/openaire-client.cfg
@@ -16,20 +16,22 @@
 # The accessToken it only has a validity of one hour
 # For more details about the token, please check: https://develop.openaire.eu/personalToken.html
 #
-# the current OpenAIRE Rest client implementation uses basic authentication
+# the current Openaire Rest client implementation uses basic authentication
 # Described here: https://develop.openaire.eu/basic.html
 #
 # ---- Token usage required definitions ----
 # you can override this settings in your local.cfg file - can be true/false
 openaire.token.enabled = false
 
-# URL of the OpenAIRE authentication and authorization service 
+# URL of the Openaire authentication and authorization service 
 openaire.token.url = https://aai.openaire.eu/oidc/token
 
-# you will be required to register at OpenAIRE (https://services.openaire.eu/uoa-user-management/registeredServices) 
+# you will be required to register at Openaire (https://services.openaire.eu/uoa-user-management/registeredServices) 
 # and create your service in order to get the following data:
 openaire.token.clientId = CLIENT_ID_HERE
 openaire.token.clientSecret = CLIENT_SECRET_HERE
 
-# URL of OpenAIRE Rest API
-openaire.api.url = https://api.openaire.eu
\ No newline at end of file
+# URL of Openaire Rest API
+openaire.api.url = https://api.openaire.eu
+
+openaire.base.url = http://api.openaire.eu/search/publications
\ No newline at end of file
diff --git a/dspace/config/modules/qaevents.cfg b/dspace/config/modules/qaevents.cfg
new file mode 100644
index 0000000000..a29a3e29f3
--- /dev/null
+++ b/dspace/config/modules/qaevents.cfg
@@ -0,0 +1,54 @@
+#---------------------------------------------------------------#
+#------- Quality Assurance Broker Events CONFIGURATIONS --------#
+#---------------------------------------------------------------#
+# Configuration properties used by data correction service      #
+#---------------------------------------------------------------#
+# Quality Assurance enable property, false by default
+qaevents.enabled = true
+qaevents.solr.server = ${solr.server}/${solr.multicorePrefix}qaevent
+# A POST to these url(s) will be done to notify oaire of decision taken for each qaevents
+# qaevents.openaire.acknowledge-url = https://beta.api-broker.openaire.eu/feedback/events
+
+# The list of the supported events incoming from openaire (see also dspace/config/spring/api/qaevents.xml)
+# add missing abstract suggestion
+qaevents.openaire.import.topic = ENRICH/MISSING/ABSTRACT
+# add missing publication id suggestion
+qaevents.openaire.import.topic = ENRICH/MISSING/PID
+# add more publication id suggestion
+qaevents.openaire.import.topic = ENRICH/MORE/PID
+# add missing project suggestion
+qaevents.openaire.import.topic = ENRICH/MISSING/PROJECT
+# add more project suggestion
+qaevents.openaire.import.topic = ENRICH/MORE/PROJECT
+# add more review
+qaevents.openaire.import.topic = ENRICH/MORE/REVIEW
+# add more endorsement
+qaevents.openaire.import.topic = ENRICH/MORE/ENDORSEMENT
+# add more release/relationship
+qaevents.openaire.import.topic = ENRICH/MORE/LINK
+
+# The list of the supported pid href for the OPENAIRE events
+qaevents.openaire.pid-href-prefix.arxiv = https://arxiv.org/abs/
+qaevents.openaire.pid-href-prefix.handle = https://hdl.handle.net/
+qaevents.openaire.pid-href-prefix.urn = 
+qaevents.openaire.pid-href-prefix.doi = https://doi.org/
+qaevents.openaire.pid-href-prefix.pmc = https://www.ncbi.nlm.nih.gov/pmc/articles/
+qaevents.openaire.pid-href-prefix.pmid = https://pubmed.ncbi.nlm.nih.gov/
+qaevents.openaire.pid-href-prefix.ncid = https://ci.nii.ac.jp/ncid/
+
+# The URI used by the OPENAIRE broker client to import QA events
+qaevents.openaire.broker-url = http://api.openaire.eu/broker
+
+###### QAEvent source Configuration ######
+qaevents.sources = openaire, DSpaceUsers, coar-notify
+
+### Withdrawal&Reinstate correction Group ###
+# Members of this group enabled to make requests for the Withdrawn or Reinstate of an item.
+# By default this property is empty, so only Administrators will see the button to make these requests.
+# If you want to allow all authenticated users to have this feature,
+# you can configure this setting to use the Anonymous group.
+qaevents.withdraw-reinstate.group =
+
+# Withdrawal&Reinstate email to notify the system administrator about a new
+# Quality Assurance (QA) request event.
+qaevents.mail.notification = ${mail.admin}
diff --git a/dspace/config/modules/rest.cfg b/dspace/config/modules/rest.cfg
index 537eedbd08..3829498525 100644
--- a/dspace/config/modules/rest.cfg
+++ b/dspace/config/modules/rest.cfg
@@ -54,6 +54,8 @@ rest.properties.exposed = google.recaptcha.mode
 rest.properties.exposed = cc.license.jurisdiction
 rest.properties.exposed = identifiers.item-status.register-doi
 rest.properties.exposed = authentication-password.domain.valid
+rest.properties.exposed = ldn.enabled
+rest.properties.exposed = ldn.notify.inbox
 rest.properties.exposed = handle.canonical.prefix
 
 #---------------------------------------------------------------#
diff --git a/dspace/config/modules/suggestion.cfg b/dspace/config/modules/suggestion.cfg
new file mode 100644
index 0000000000..0792c46ebf
--- /dev/null
+++ b/dspace/config/modules/suggestion.cfg
@@ -0,0 +1,7 @@
+#---------------------------------------------------------------#
+#-------------------Suggestion CONFIGURATIONS-------------------#
+#---------------------------------------------------------------#
+# Configuration properties used by publication claim            #
+#  (suggestion) service                                         #
+#---------------------------------------------------------------#
+suggestion.solr.server = ${solr.server}/${solr.multicorePrefix}suggestion
diff --git a/dspace/config/registries/coar-types.xml b/dspace/config/registries/coar-types.xml
new file mode 100644
index 0000000000..39c78e8f8c
--- /dev/null
+++ b/dspace/config/registries/coar-types.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE dspace-dc-types SYSTEM "dspace-dc-types.dtd">
+
+<!--
+  This document was based on the OpenAIRE4 Guidelines for Literature Repositories
+  https://openaire-guidelines-for-literature-repository-managers.readthedocs.io/en/v4.0.0/index.html
+  -->
+  
+<dspace-dc-types>
+    <dspace-header>
+        <title>COAR fields definition</title>
+    </dspace-header>
+    
+    <dc-schema>
+        <name>coar</name>
+        <namespace>http://dspace.org/coar</namespace>
+    </dc-schema>
+    
+    <dc-type>
+        <schema>coar</schema>
+        <element>notify</element>
+        <qualifier>review</qualifier>
+        <scope_note>Reviewed by</scope_note>
+    </dc-type>
+    
+    <dc-type>
+        <schema>coar</schema>
+        <element>notify</element>
+        <qualifier>endorsement</qualifier>
+        <scope_note>Endorsement</scope_note>
+    </dc-type>
+    
+    <dc-type>
+        <schema>coar</schema>
+        <element>notify</element>
+        <qualifier>examination</qualifier>
+        <scope_note>Examination</scope_note>
+    </dc-type>
+    
+    <dc-type>
+        <schema>coar</schema>
+        <element>notify</element>
+        <qualifier>refused</qualifier>
+        <scope_note>Refused by</scope_note>
+    </dc-type>
+    
+    <dc-type>
+        <schema>coar</schema>
+        <element>notify</element>
+        <qualifier>release</qualifier>
+        <scope_note>Released by</scope_note>
+    </dc-type>
+
+    <dc-type>
+        <schema>coar</schema>
+        <element>notify</element>
+        <qualifier>endorsedBy</qualifier>
+        <scope_note>Endorsed by</scope_note>
+    </dc-type>
+
+</dspace-dc-types>
diff --git a/dspace/config/registries/datacite-types.xml b/dspace/config/registries/datacite-types.xml
new file mode 100644
index 0000000000..b415ff0d2b
--- /dev/null
+++ b/dspace/config/registries/datacite-types.xml
@@ -0,0 +1,57 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!DOCTYPE dspace-dc-types SYSTEM "dspace-dc-types.dtd">
+
+<!--
+  This document was based on the OpenAIRE4 Guidelines for Literature Repositories
+  https://openaire-guidelines-for-literature-repository-managers.readthedocs.io/en/v4.0.0/index.html
+  -->
+  
+<dspace-dc-types>
+    <dspace-header>
+        <title>OpenAIRE4 Datacite fields definition</title>
+    </dspace-header>
+    
+    <dc-schema>
+        <name>datacite</name>
+        <namespace>http://datacite.org/schema/kernel-4</namespace>
+    </dc-schema>
+
+    <!--
+      OpenAIRE4 Guidelines
+      21 - Geolocation -->	
+    <dc-type>
+        <schema>datacite</schema>
+        <element>geoLocation</element>
+        <scope_note>Spatial region or named place where the data was gathered or about which the data is focused.</scope_note>
+    </dc-type>
+        
+    <!-- specific type required by OpenAIRE4 Guidelines -->
+    <dc-type>
+        <schema>datacite</schema>
+        <element>subject</element>
+        <qualifier>fos</qualifier>
+        <scope_note>Fields of Science and Technology - OECD</scope_note>
+    </dc-type>
+    
+    <dc-type>
+        <schema>datacite</schema>
+        <element>relation</element>
+        <qualifier>isReviewedBy</qualifier>
+        <scope_note>Reviewd by</scope_note>
+    </dc-type>    
+    
+    <dc-type>
+        <schema>datacite</schema>
+        <element>relation</element>
+    	<qualifier>isReferencedBy</qualifier>
+		<scope_note>Referenced by</scope_note>
+	</dc-type>	
+	
+    <dc-type>
+        <schema>datacite</schema>
+        <element>relation</element>
+    	<qualifier>isSupplementedBy</qualifier>
+		<scope_note>Supplemented by</scope_note>
+	</dc-type>
+
+</dspace-dc-types>
diff --git a/dspace/config/registries/dublin-core-types.xml b/dspace/config/registries/dublin-core-types.xml
index d0f340f89c..9a4aefb3ff 100644
--- a/dspace/config/registries/dublin-core-types.xml
+++ b/dspace/config/registries/dublin-core-types.xml
@@ -265,6 +265,7 @@
     <schema>dc</schema>
     <element>identifier</element>
     <qualifier>doi</qualifier>
+    <scope_note>The doi identifier minted by this repository.</scope_note>
   </dc-type>
   
   <dc-type>
diff --git a/dspace/config/registries/openaire4-types.xml b/dspace/config/registries/openaire4-types.xml
index b3290ac120..e47e06e0ae 100644
--- a/dspace/config/registries/openaire4-types.xml
+++ b/dspace/config/registries/openaire4-types.xml
@@ -2,24 +2,19 @@
 <!DOCTYPE dspace-dc-types SYSTEM "dspace-dc-types.dtd">
 
 <!--
-  This document was based on the OpenAIRE4 Guidelines for Literature Repositories
+  This document was based on the Openaire4 Guidelines for Literature Repositories
   https://openaire-guidelines-for-literature-repository-managers.readthedocs.io/en/v4.0.0/index.html
   -->
   
 <dspace-dc-types>
     <dspace-header>
-        <title>OpenAIRE4 fields definition</title>
+        <title>Openaire4 fields definition</title>
     </dspace-header>
 
     <dc-schema>
         <name>oaire</name>
         <namespace>http://namespace.openaire.eu/schema/oaire/</namespace>
     </dc-schema>
-    
-    <dc-schema>
-        <name>datacite</name>
-        <namespace>http://datacite.org/schema/kernel-4</namespace>
-    </dc-schema>
 	
     <dc-type>
         <schema>oaire</schema>
@@ -107,21 +102,4 @@
         <scope_note>The date when the conference took place. This property is considered to be part of the bibliographic citation. Recommended best practice for encoding the date value is defined in a profile of ISO 8601 [W3CDTF] and follows the YYYY-MM-DD format.</scope_note>
     </dc-type>
 
-    <!--
-      OpenAIRE4 Guidelines
-      21 - Geolocation -->	
-    <dc-type>
-        <schema>datacite</schema>
-        <element>geoLocation</element>
-        <scope_note>Spatial region or named place where the data was gathered or about which the data is focused.</scope_note>
-    </dc-type>
-        
-    <!-- specific type required by OpenAIRE4 Guidelines -->
-    <dc-type>
-        <schema>datacite</schema>
-        <element>subject</element>
-        <qualifier>fos</qualifier>
-        <scope_note>Fields of Science and Technology - OECD</scope_note>
-    </dc-type>
-
 </dspace-dc-types>
diff --git a/dspace/config/registries/relationship-formats.xml b/dspace/config/registries/relationship-formats.xml
index f2f50182fa..53d15d4d43 100644
--- a/dspace/config/registries/relationship-formats.xml
+++ b/dspace/config/registries/relationship-formats.xml
@@ -237,7 +237,7 @@
         <scope_note>Contains all uuids of PUBLICATIONS which link to the current ISSUE via a "latest" relationship. In other words, this stores all relationships pointing to the current ISSUE from any PUBLICATION, implying that the ISSUE is marked as "latest". Internally used by DSpace to support versioning. Do not manually add, remove or edit values.</scope_note>
     </dc-type>
 
-    <!-- OpenAIRE4 Guidelines - required relationships -->
+    <!-- Openaire4 Guidelines - required relationships -->
 
     <dc-type>
         <schema>relation</schema>
diff --git a/dspace/config/registries/schema-organization-types.xml b/dspace/config/registries/schema-organization-types.xml
index 91ee203ae9..0b31851078 100644
--- a/dspace/config/registries/schema-organization-types.xml
+++ b/dspace/config/registries/schema-organization-types.xml
@@ -42,10 +42,10 @@
         </scope_note>
     </dc-type>
     
-    <!-- OpenAIRE4 Guidelines -->
+    <!-- Openaire4 Guidelines -->
     <!-- 2.2.2.1. Attribute nameType (R) -->
     <!-- and 3.2.6. Subproperty nameIdentifier (R) -->
-    <!-- specific type required by OpenAIRE4 Guidelines -->  
+    <!-- specific type required by Openaire4 Guidelines -->  
     
     <dc-type>
         <schema>organization</schema>
diff --git a/dspace/config/registries/schema-person-types.xml b/dspace/config/registries/schema-person-types.xml
index 3a8f79732d..0a40060e51 100644
--- a/dspace/config/registries/schema-person-types.xml
+++ b/dspace/config/registries/schema-person-types.xml
@@ -17,7 +17,7 @@
     -->
 
     <!--
-	  OpenAIRE4 Guidelines	
+	  Openaire4 Guidelines	
       2.2.3. Subproperty givenName (R)
       The personal or first name of the author. -->
     <dc-type>
@@ -29,7 +29,7 @@
     </dc-type>
 	
     <!--
-	  OpenAIRE4 Guidelines
+	  Openaire4 Guidelines
       2.2.4. Subproperty familyName (R)
       The surname or last name of the author. -->
     <dc-type>
@@ -74,7 +74,7 @@
     </dc-type>
 	
     <!--
-      OpenAIRE4 Guidelines
+      Openaire4 Guidelines
       2.2.6. Subproperty affiliation (R)
       The organizational or institutional affiliation of the creator (occurrence: 0-n). -->
     <dc-type>
@@ -84,10 +84,10 @@
         <scope_note>The organizational or institutional affiliation of the creator</scope_note>
     </dc-type>
     
-    <!-- OpenAIRE4 Guidelines -->
+    <!-- Openaire4 Guidelines -->
     <!-- 2.2.2.1. Attribute nameType (R) -->
     <!-- and 3.2.6. Subproperty nameIdentifier (R) -->
-    <!-- specific type required by OpenAIRE4 Guidelines -->  
+    <!-- specific type required by Openaire4 Guidelines -->  
     <dc-type>
         <schema>person</schema>
         <element>identifier</element>
diff --git a/dspace/config/registries/schema-project-types.xml b/dspace/config/registries/schema-project-types.xml
index c2f844d2b2..4da07b6a79 100644
--- a/dspace/config/registries/schema-project-types.xml
+++ b/dspace/config/registries/schema-project-types.xml
@@ -18,7 +18,7 @@
     -->
 	
 	<!--
-	  OpenAIRE4 Guidelines
+	  Openaire4 Guidelines
       4.2.2. Subproperty funderName (M)
       Name of the funding provider (occurrence: 1). Mandatory if FundingReference is used. -->
     <dc-type>
@@ -29,7 +29,7 @@
     </dc-type>
 	
 	<!--
-	  OpenAIRE4 Guidelines
+	  Openaire4 Guidelines
       4.2.3. Subproperty funderIdentifier (R)
       Unique identifier of the funding entity (occurrence: 0-1). 
     -->
diff --git a/dspace/config/spring/api/core-dao-services.xml b/dspace/config/spring/api/core-dao-services.xml
index bc62a71c03..54cfb2df34 100644
--- a/dspace/config/spring/api/core-dao-services.xml
+++ b/dspace/config/spring/api/core-dao-services.xml
@@ -69,5 +69,10 @@
 
     <bean class="org.dspace.supervision.dao.impl.SupervisionOrderDaoImpl"/>
 
+    <bean class="org.dspace.app.ldn.dao.impl.NotifyServiceDaoImpl"/>
+    <bean class="org.dspace.app.ldn.dao.impl.NotifyServiceInboundPatternDaoImpl"/>
+    <bean class="org.dspace.app.ldn.dao.impl.LDNMessageDaoImpl"/>
+    <bean class="org.dspace.app.ldn.dao.impl.NotifyPatternToTriggerDaoImpl"/>
+
 
 </beans>
diff --git a/dspace/config/spring/api/core-factory-services.xml b/dspace/config/spring/api/core-factory-services.xml
index acfa0efe6d..2c6e60fc1c 100644
--- a/dspace/config/spring/api/core-factory-services.xml
+++ b/dspace/config/spring/api/core-factory-services.xml
@@ -57,6 +57,10 @@
 
     <bean id="supervisionOrderServiceFactory" class="org.dspace.supervision.factory.SupervisionOrderServiceFactoryImpl"/>
 
+    <bean id="notifyServiceFactory" class="org.dspace.app.ldn.factory.NotifyServiceFactoryImpl"/>
+    
+    <bean id="ldnMessageServiceFactory" class="org.dspace.app.ldn.factory.LDNMessageServiceFactoryImpl"/>
+
     <bean id="submissionServiceFactory" class="org.dspace.submit.factory.SubmissionServiceFactoryImpl"/>
 
 </beans>
diff --git a/dspace/config/spring/api/core-services.xml b/dspace/config/spring/api/core-services.xml
index a13b1bb867..21f41434d8 100644
--- a/dspace/config/spring/api/core-services.xml
+++ b/dspace/config/spring/api/core-services.xml
@@ -142,6 +142,7 @@
     <bean class="org.dspace.discovery.indexobject.WorkflowItemIndexFactoryImpl" autowire-candidate="true"/>
     <bean class="org.dspace.discovery.indexobject.WorkspaceItemIndexFactoryImpl" autowire-candidate="true"/>
     <bean class="org.dspace.discovery.indexobject.MetadataFieldIndexFactoryImpl" autowire-candidate="true"/>
+    <bean class="org.dspace.discovery.indexobject.LDNMessageEntityIndexFactoryImpl" autowire-candidate="true"/>
 
     <!-- OIDC Authentication -->
     <bean class="org.dspace.authenticate.OidcAuthenticationBean" id="oidcAuthentication"/>
@@ -152,8 +153,12 @@
 
     <bean class="org.dspace.supervision.SupervisionOrderServiceImpl"/>
 
+    <bean class="org.dspace.content.ItemFilterServiceImpl"/>
+
     <!-- Submission Config Service -->
     <bean class="org.dspace.submit.service.SubmissionConfigServiceImpl"/>
 
+    <bean class="org.dspace.correctiontype.service.impl.CorrectionTypeServiceImpl"/>
+
 </beans>
 
diff --git a/dspace/config/spring/api/correction-types.xml b/dspace/config/spring/api/correction-types.xml
new file mode 100644
index 0000000000..b79e2408d8
--- /dev/null
+++ b/dspace/config/spring/api/correction-types.xml
@@ -0,0 +1,17 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<beans xmlns="http://www.springframework.org/schema/beans" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+       xmlns:util="http://www.springframework.org/schema/util"
+       xsi:schemaLocation="http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"
+       default-lazy-init="true">
+
+    <bean id="withdrawnRequest" class="org.dspace.correctiontype.WithdrawnCorrectionType" >
+        <property name="id" value="request-withdrawn"/>
+        <property name="topic" value="REQUEST/WITHDRAWN"/>
+    </bean>
+
+    <bean id="reinstateRequest" class="org.dspace.correctiontype.ReinstateCorrectionType" >
+        <property name="id" value="request-reinstate"/>
+        <property name="topic" value="REQUEST/REINSTATE"/>
+    </bean>
+
+</beans>
diff --git a/dspace/config/spring/api/discovery.xml b/dspace/config/spring/api/discovery.xml
index fb25f11598..79dda8dcb3 100644
--- a/dspace/config/spring/api/discovery.xml
+++ b/dspace/config/spring/api/discovery.xml
@@ -110,9 +110,24 @@
 
                 <!-- search for an entity that can be a Person or an OrgUnit -->
                 <entry key="personOrOrgunit" value-ref="personOrOrgunit"/>
-                <!-- OpenAIRE4 guidelines - search for an OrgUnit that have a specific dc.type=FundingOrganization -->
-                <entry key="openAIREFundingAgency" value-ref="openAIREFundingAgency"/>
+                <!-- Openaire4 guidelines - search for an OrgUnit that have a specific dc.type=FundingOrganization -->
+                <entry key="openaireFundingAgency" value-ref="openaireFundingAgency"/>
                 <entry key="eperson_claims" value-ref="eperson_claims"/>
+                <!-- COAR NOTIFY LDN MESSAGES configuration -->
+                <entry key="NOTIFY.incoming" value-ref="NOTIFY.incoming"/>
+                <entry key="NOTIFY.outgoing" value-ref="NOTIFY.outgoing"/>
+                <!-- COAR NOTIFY LDN MESSAGES incoming configuration -->
+                <entry key="NOTIFY.incoming.accepted" value-ref="NOTIFY.incoming.accepted"/>
+                <entry key="NOTIFY.incoming.processed" value-ref="NOTIFY.incoming.processed"/>
+                <entry key="NOTIFY.incoming.failure" value-ref="NOTIFY.incoming.failure"/>
+                <entry key="NOTIFY.incoming.untrusted" value-ref="NOTIFY.incoming.untrusted"/>
+                <entry key="NOTIFY.incoming.involvedItems" value-ref="NOTIFY.incoming.involvedItems"/>
+                <!-- COAR NOTIFY LDN MESSAGES outgoing configuration -->
+                <entry key="NOTIFY.outgoing.delivered" value-ref="NOTIFY.outgoing.delivered"/>
+                <entry key="NOTIFY.outgoing.queued" value-ref="NOTIFY.outgoing.queued"/>
+                <entry key="NOTIFY.outgoing.queued_for_retry" value-ref="NOTIFY.outgoing.queued_for_retry"/>
+                <entry key="NOTIFY.outgoing.failure" value-ref="NOTIFY.outgoing.failure"/>
+                <entry key="NOTIFY.outgoing.involvedItems" value-ref="NOTIFY.outgoing.involvedItems"/>
             </map>
         </property>
         <property name="toIgnoreMetadataFields">
@@ -585,6 +600,7 @@
     <!--The configuration settings for discovery of withdrawn and undiscoverable items (admin only) and regular items-->
     <bean id="administrativeView" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype">
         <property name="id" value="administrativeView"/>
+        <property name="indexAlways" value="true"/>
         <property name="sidebarFacets">
             <list>
                 <ref bean="searchFilterDiscoverable" />
@@ -594,6 +610,9 @@
                 <ref bean="searchFilterIssued" />
                 <ref bean="searchFilterContentInOriginalBundle"/>
                 <ref bean="searchFilterEntityType"/>
+                <ref bean="searchFilterNotifyRelation" />
+                <ref bean="searchFilterNotifyEndorsement" />
+                <ref bean="searchFilterNotifyReview" />
             </list>
         </property>
         <!-- Set TagCloud configuration per discovery configuration -->
@@ -616,6 +635,9 @@
                 <ref bean="searchFilterIsOrgUnitOfPublicationRelation"/>
                 <ref bean="searchFilterIsPublicationOfJournalIssueRelation"/>
                 <ref bean="searchFilterIsJournalOfPublicationRelation"/>
+                <ref bean="searchFilterNotifyRelation" />
+                <ref bean="searchFilterNotifyEndorsement" />
+                <ref bean="searchFilterNotifyReview" />
             </list>
         </property>
         <!--The sort filters for the discovery search-->
@@ -2027,7 +2049,7 @@
         <property name="spellCheckEnabled" value="true"/>
     </bean>
 
-    <bean id="openAIREFundingAgency" class="org.dspace.discovery.configuration.DiscoveryConfiguration"
+    <bean id="openaireFundingAgency" class="org.dspace.discovery.configuration.DiscoveryConfiguration"
           scope="prototype">
         <property name="id" value="fundingAgency"/>
         <property name="indexAlways" value="true"/>
@@ -2120,6 +2142,61 @@
     </bean>
 
 
+    <bean id="ldnMessageEntityBaseConfig"
+        class="org.dspace.discovery.configuration.DiscoveryConfiguration"
+        scope="prototype">
+        <property name="id" value="ldnMessages" />
+        <!--Which sidebar facets are to be displayed -->
+        <property name="sidebarFacets">
+            <list>
+            	<ref bean="searchFilterNotifyRelatedItem" />
+            	<ref bean="searchFilterNotifyLdnService" />
+            	<ref bean="searchFilterNotifyQueueStatus" />
+            	<ref bean="searchFilterNotifyActivityStreamType" />
+            	<ref bean="searchFilterNotifyCoarNotifyType" />
+            	<ref bean="searchFilterNotifyLastStartTime" />
+            </list>
+        </property>
+        <!--The search filters which can be used on the discovery search page -->
+        <property name="searchFilters">
+            <list>
+            	<ref bean="searchFilterNotifyRelatedItem" />
+            	<ref bean="searchFilterNotifyOrigin" />
+            	<ref bean="searchFilterNotifyTarget" />
+            	<ref bean="searchFilterNotifyLdnService" />
+            	<ref bean="searchFilterNotifyQueueStatus" />
+            	<ref bean="searchFilterNotifyActivityStreamType" />
+            	<ref bean="searchFilterNotifyCoarNotifyType" />
+            	<ref bean="searchFilterNotifyLastStartTime" />
+            </list>
+        </property>
+        <!--The sort filters for the discovery search-->
+        <property name="searchSortConfiguration">
+            <bean class="org.dspace.discovery.configuration.DiscoverySortConfiguration">
+                <property name="sortFields">
+                    <list>
+                    	<ref bean="sortLastModified"/>
+                    	<ref bean="sortLastModifiedAsc"/>
+                    	<ref bean="sortQueueLastStartTimeDesc"/>
+                    	<ref bean="sortQueueLastStartTimeAsc"/>
+                    	<ref bean="sortQueueAttemptsDesc"/>
+                    	<ref bean="sortQueueAttemptsAsc"/>
+                    </list>
+                </property>
+            </bean>
+        </property>
+        <!--Any default filter queries, these filter queries will be used for all
+            queries done by discovery for this configuration -->
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+            </list>
+        </property>
+        <!--Default result per page  -->
+        <property name="defaultRpp" value="10" />
+    </bean>
+
      <!--TagCloud configuration bean for default discovery configuration-->
     <bean id="defaultTagCloudFacetConfiguration" class="org.dspace.discovery.configuration.TagCloudFacetConfiguration">
         <!-- Actual configuration of the tagcloud (colors, sorting, etc.) -->
@@ -2132,6 +2209,150 @@
         </property>
     </bean>
 
+    <bean id="NOTIFY.incoming" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="ldnMessageEntityBaseConfig">
+        <property name="id" value="NOTIFY.incoming"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_INCOMING}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.incoming.accepted" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="NOTIFY.incoming">
+        <property name="id" value="NOTIFY.incoming.accepted"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_INCOMING}</value>
+                <value>in_reply_to:*</value>
+                <value>activity_stream_type_keyword:Accept</value>
+                <value>queue_status_authority:#{T(org.dspace.app.ldn.LDNMessageEntity).QUEUE_STATUS_PROCESSED}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.incoming.processed" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="NOTIFY.incoming">
+        <property name="id" value="NOTIFY.incoming.processed"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_INCOMING}</value>
+                <value>queue_status_authority:#{T(org.dspace.app.ldn.LDNMessageEntity).QUEUE_STATUS_PROCESSED}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.incoming.failure" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="NOTIFY.incoming">
+        <property name="id" value="NOTIFY.incoming.failure"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_INCOMING}</value>
+                <value>queue_status_authority:#{T(org.dspace.app.ldn.LDNMessageEntity).QUEUE_STATUS_FAILED} OR queue_status_authority:#{T(org.dspace.app.ldn.LDNMessageEntity).QUEUE_STATUS_UNMAPPED_ACTION}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.incoming.untrusted" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="NOTIFY.incoming">
+        <property name="id" value="NOTIFY.incoming.untrusted"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_INCOMING}</value>
+                <value>queue_status_authority:#{T(org.dspace.app.ldn.LDNMessageEntity).QUEUE_STATUS_UNTRUSTED}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.incoming.involvedItems" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="administrativeView">
+        <property name="id" value="NOTIFY.incoming.involvedItems"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:Item</value>
+                <value>{!join from=relateditem_authority to=search.resourceid fromIndex=${solr.multicorePrefix}search}notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_INCOMING}</value>
+                <value>-withdrawn:true AND -discoverable:false</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.outgoing" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="ldnMessageEntityBaseConfig">
+        <property name="id" value="NOTIFY.outgoing"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_OUTGOING}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.outgoing.delivered" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="NOTIFY.outgoing">
+        <property name="id" value="NOTIFY.outgoing.delivered"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_OUTGOING}</value>
+                <value>queue_status_authority:#{T(org.dspace.app.ldn.LDNMessageEntity).QUEUE_STATUS_PROCESSED}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.outgoing.queued" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="NOTIFY.outgoing">
+        <property name="id" value="NOTIFY.outgoing.queued"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_OUTGOING}</value>
+                <value>queue_status_authority:#{T(org.dspace.app.ldn.LDNMessageEntity).QUEUE_STATUS_QUEUED}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.outgoing.queued_for_retry" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="NOTIFY.outgoing">
+        <property name="id" value="NOTIFY.outgoing.queued_for_retry"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_OUTGOING}</value>
+                <value>queue_status_authority:#{T(org.dspace.app.ldn.LDNMessageEntity).QUEUE_STATUS_QUEUED_FOR_RETRY}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.outgoing.failure" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="NOTIFY.outgoing">
+        <property name="id" value="NOTIFY.outgoing.failure"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:LDNMessageEntity</value>
+                <value>notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_OUTGOING}</value>
+                <value>queue_status_authority:#{T(org.dspace.app.ldn.LDNMessageEntity).QUEUE_STATUS_FAILED} OR queue_status_authority:#{T(org.dspace.app.ldn.LDNMessageEntity).QUEUE_STATUS_UNMAPPED_ACTION}</value>
+            </list>
+        </property>
+    </bean>
+
+    <bean id="NOTIFY.outgoing.involvedItems" class="org.dspace.discovery.configuration.DiscoveryConfiguration" scope="prototype" parent="administrativeView">
+        <property name="id" value="NOTIFY.outgoing.involvedItems"/>
+        <property name="defaultFilterQueries">
+            <list>
+                <!--Only find LDNMessageEntity -->
+                <value>search.resourcetype:Item</value>
+                <value>{!join from=relateditem_authority to=search.resourceid fromIndex=${solr.multicorePrefix}search}notification_type_keyword:#{T(org.dspace.app.ldn.LDNMessageEntity).TYPE_OUTGOING}</value>
+                <value>-withdrawn:true AND -discoverable:false</value>
+            </list>
+        </property>
+    </bean>
+
     <bean id="tagCloudConfiguration" class="org.dspace.discovery.configuration.TagCloudConfiguration">
         <!-- Should display the score of each tag next to it? Default: false -->
         <!-- <property name="displayScore" value="true"/> -->
@@ -2848,6 +3069,177 @@
         </property>
     </bean>
 
+    <bean id="searchFilterNotifyRelatedItem" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="relateditem"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyLdnService" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="ldn_service"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyOrigin" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="origin"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyTarget" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="target"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyQueueStatus" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="queue_status"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyActivityStreamType" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="activity_stream_type"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyCoarNotifyType" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="coar_notify_type"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyNotificationType" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="notification_type"/>
+        <property name="metadataFields">
+            <list>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
+    <bean id="searchFilterNotifyRelation" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="notifyRelation"/>
+        <property name="metadataFields">
+            <list>
+                <value>datacite.relation.isReferencedBy</value>
+                <value>datacite.relation.isSupplementedBy</value>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+    </bean>
+
+    <bean id="searchFilterNotifyEndorsement" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="notifyEndorsement"/>
+        <property name="metadataFields">
+            <list>
+                <value>notify.relation.endorsedBy</value>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+    </bean>
+
+    <bean id="searchFilterNotifyReview" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="notifyReview"/>
+        <property name="metadataFields">
+            <list>
+                <value>datacite.relation.isReviewedBy</value>
+            </list>
+        </property>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="true"/>
+        <property name="pageSize" value="10"/>
+    </bean>
+
+    <bean id="searchFilterNotifyLastStartTime" class="org.dspace.discovery.configuration.DiscoverySearchFilterFacet">
+        <property name="indexFieldName" value="queue_last_start_time"/>
+        <property name="metadataFields">
+            <list>
+                <value></value>
+            </list>
+        </property>
+        <property name="type" value="date"/>
+        <property name="facetLimit" value="5"/>
+        <property name="sortOrderSidebar" value="COUNT"/>
+        <property name="sortOrderFilterPage" value="COUNT"/>
+        <property name="isOpenByDefault" value="false"/>
+        <property name="pageSize" value="10"/>
+        <property name="exposeMinAndMaxValue" value="true"/>
+    </bean>
+
     <!--Sort properties-->
     <bean id="sortScore" class="org.dspace.discovery.configuration.DiscoverySortFieldConfiguration">
         <property name="defaultSortOrder" value="desc"/>
@@ -2928,6 +3320,34 @@
         <property name="defaultSortOrder" value="desc"/>
     </bean>
 
+    <bean id="sortLastModifiedAsc" class="org.dspace.discovery.configuration.DiscoverySortFieldConfiguration">
+        <property name="metadataField" value="lastModified" />
+        <property name="type" value="date" />
+        <property name="defaultSortOrder" value="asc"/>
+    </bean>
+
+    <bean id="sortQueueLastStartTimeDesc" class="org.dspace.discovery.configuration.DiscoverySortFieldConfiguration">
+        <property name="metadataField" value="queue_last_start_time" />
+        <property name="type" value="date" />
+        <property name="defaultSortOrder" value="desc"/>
+    </bean>
+
+    <bean id="sortQueueLastStartTimeAsc" class="org.dspace.discovery.configuration.DiscoverySortFieldConfiguration">
+        <property name="metadataField" value="queue_last_start_time" />
+        <property name="type" value="date" />
+        <property name="defaultSortOrder" value="asc"/>
+    </bean>
+
+    <bean id="sortQueueAttemptsDesc" class="org.dspace.discovery.configuration.DiscoverySortFieldConfiguration">
+        <property name="metadataField" value="queue_attempts" />
+        <property name="defaultSortOrder" value="desc"/>
+    </bean>
+
+    <bean id="sortQueueAttemptsAsc" class="org.dspace.discovery.configuration.DiscoverySortFieldConfiguration">
+        <property name="metadataField" value="queue_attempts" />
+        <property name="defaultSortOrder" value="asc"/>
+    </bean>
+
     <bean id="sortTitleAsc" class="org.dspace.discovery.configuration.DiscoverySortFieldConfiguration">
         <property name="metadataField" value="dc.title"/>
         <property name="defaultSortOrder" value="asc"/>
diff --git a/dspace/config/spring/api/external-openaire.xml b/dspace/config/spring/api/external-openaire.xml
index 25a23a1739..f12ff950b8 100644
--- a/dspace/config/spring/api/external-openaire.xml
+++ b/dspace/config/spring/api/external-openaire.xml
@@ -7,24 +7,24 @@
                            http://www.springframework.org/schema/util/spring-util.xsd"
        default-lazy-init="true">
 
-    <bean id="openAIRERestConnector" class="org.dspace.external.OpenAIRERestConnector">
+    <bean id="openaireRestConnector" class="org.dspace.external.OpenaireRestConnector">
         <constructor-arg value="${openaire.api.url:https://api.openaire.eu}"/>
-		<property name="tokenEnabled" value="${openaire.token.enabled:false}"/>
-		<property name="tokenServiceUrl" value="${openaire.token.url:https://aai.openaire.eu/oidc/token}"/>
-		<property name="clientId" value="${openaire.token.clientId}"/>
-		<property name="clientSecret" value="${openaire.token.clientSecret}"/>
+        <property name="tokenEnabled" value="${openaire.token.enabled:false}"/>
+        <property name="tokenServiceUrl" value="${openaire.token.url:https://aai.openaire.eu/oidc/token}"/>
+        <property name="clientId" value="${openaire.token.clientId}"/>
+        <property name="clientSecret" value="${openaire.token.clientSecret}"/>
     </bean>
 
-	<bean class="org.dspace.external.provider.impl.OpenAIREFundingDataProvider" init-method="init">
-		<property name="sourceIdentifier" value="openAIREFunding" />
-		<property name="connector" ref="openAIRERestConnector" />
-		<property name="metadataFields" ref="mapOfmetadata"/>
-		<property name="supportedEntityTypes">
-			<list>
-				<value>Project</value>
-			</list>
-		</property>
-	</bean>
+    <bean class="org.dspace.external.provider.impl.OpenaireFundingDataProvider" init-method="init">
+        <property name="sourceIdentifier" value="openaireFunding" />
+        <property name="connector" ref="openaireRestConnector" />
+        <property name="metadataFields" ref="mapOfmetadata"/>
+        <property name="supportedEntityTypes">
+            <list>
+                <value>Project</value>
+            </list>
+        </property>
+    </bean>
 
     <util:map id="mapOfmetadata"
         map-class="java.util.HashMap" key-type="java.lang.String" value-type="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
@@ -46,7 +46,7 @@
     <bean id="openaireFundingStream" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
         <constructor-arg value="oaire.fundingStream"/>
     </bean>
-    
+
     <bean id="openaireAwardURI" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
         <constructor-arg value="oaire.awardURI"/>
     </bean>
diff --git a/dspace/config/spring/api/external-services.xml b/dspace/config/spring/api/external-services.xml
index 6d7d50c39f..c3ba0bf9cf 100644
--- a/dspace/config/spring/api/external-services.xml
+++ b/dspace/config/spring/api/external-services.xml
@@ -70,6 +70,18 @@
         <constructor-arg value="${orcid.api-url}"/>
     </bean>
 
+    <bean id="openaireLiveImportDataProviderByAuthor" class="org.dspace.external.provider.impl.LiveImportDataProvider">
+        <property name="metadataSource" ref="openaireImportServiceByAuthor"/>
+        <property name="sourceIdentifier" value="openaire"/>
+        <property name="recordIdMetadata" value="dc.identifier.other"/>
+    </bean>
+
+    <bean id="openaireLiveImportDataProviderByTitle" class="org.dspace.external.provider.impl.LiveImportDataProvider">
+        <property name="metadataSource" ref="openaireImportServiceByTitle"/>
+        <property name="sourceIdentifier" value="openaireTitle"/>
+        <property name="recordIdMetadata" value="dc.identifier.other"/>
+    </bean>
+
     <bean id="pubmedLiveImportDataProvider" class="org.dspace.external.provider.impl.LiveImportDataProvider">
         <property name="metadataSource" ref="pubmedImportService"/>
         <property name="sourceIdentifier" value="pubmed"/>
diff --git a/dspace/config/spring/api/identifier-service.xml b/dspace/config/spring/api/identifier-service.xml
index 0c58cc1de9..79e19e879e 100644
--- a/dspace/config/spring/api/identifier-service.xml
+++ b/dspace/config/spring/api/identifier-service.xml
@@ -4,7 +4,7 @@
        xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">
 
-    <!-- Identifier Service Application Interface.  Will be autowired with
+    <!-- Identifier Service Application Interface. Will be autowired with
          any Identifier Providers present in Spring context.
     -->
     <bean id="org.dspace.identifier.service.IdentifierService"
@@ -12,6 +12,13 @@
           autowire="byType"
           scope="singleton"/>
 
+    <!-- If you disable versioning, you need to use the default HandleIdentifierProvider. -->
+    <!--
+    <bean id="org.dspace.identifier.HandleIdentifierProvider" class="org.dspace.identifier.HandleIdentifierProvider" scope="singleton">
+        <property name="configurationService" ref="org.dspace.services.ConfigurationService"/>
+    </bean>
+    -->
+
       <!-- If you enabled versioning, you should use one of the versioned
            handle identifier provider instead of the default one.
            The VersionedHandleIdentifierProvider creates a new versioned
@@ -26,7 +33,7 @@
            a new version is created the previous version gets a new
            handle. This leads to a handle that points always to the
            newest version, but there is no permanent handle, that
-           will always keep pointing to the acutal newest one.
+           will always keep pointing to the actual newest one.
            -->
     <!--
     <bean id="org.dspace.identifier.HandleIdentifierProvider" class="org.dspace.identifier.VersionedHandleIdentifierProviderWithCanonicalHandles" scope="singleton">
diff --git a/dspace/config/spring/api/item-filters.xml b/dspace/config/spring/api/item-filters.xml
index 24c463fb53..677357a93e 100644
--- a/dspace/config/spring/api/item-filters.xml
+++ b/dspace/config/spring/api/item-filters.xml
@@ -286,7 +286,7 @@
         </property>
     </bean>
 
-    <!-- An example of an OpenAIRE compliance filter based on the same rules in xoai.xml
+    <!-- An example of an Openaire compliance filter based on the same rules in xoai.xml
          some sub-statements are defined within this bean, and some are referenced from earlier definitions
     -->
     <bean id="openaire_filter" class="org.dspace.content.logic.DefaultFilter">
@@ -329,7 +329,7 @@
                                 </list>
                             </property>
                         </bean>
-                        <!-- AND the dc.relation is a valid OpenAIRE identifier
+                        <!-- AND the dc.relation is a valid Openaire identifier
                              (starts with "info:eu-repo/grantAgreement/") -->
                         <bean id="has-openaire-relation_condition"
                               class="org.dspace.content.logic.condition.MetadataValueMatchCondition">
@@ -346,4 +346,12 @@
         </property>
     </bean>
 
+    <util:map id="ldnItemFilters" key-type="java.lang.String"
+              value-type="org.dspace.content.logic.LogicalStatement">
+     	<entry key="item-is-public_condition" value-ref="item-is-public_condition"/>
+		<entry key="title-starts-with-pattern_condition" value-ref="title-starts-with-pattern_condition"/>
+		<entry key="type-equals-journal-article_condition" value-ref="type-equals-journal-article_condition"/>
+		<entry key="type-equals-dataset_condition" value-ref="type-equals-dataset_condition"/>
+		<entry key="has-one-bitstream_condition" value-ref="has-one-bitstream_condition"/>
+    </util:map>
 </beans>
diff --git a/dspace/config/spring/api/ldn-coar-notify.xml b/dspace/config/spring/api/ldn-coar-notify.xml
new file mode 100644
index 0000000000..2329925a54
--- /dev/null
+++ b/dspace/config/spring/api/ldn-coar-notify.xml
@@ -0,0 +1,340 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<!-- The contents of this file are subject to the license and copyright detailed 
+    in the LICENSE and NOTICE files at the root of the source tree and available 
+    online at http://www.dspace.org/license/ -->
+<beans xmlns="http://www.springframework.org/schema/beans"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xmlns:context="http://www.springframework.org/schema/context"
+    xmlns:util="http://www.springframework.org/schema/util"
+    xsi:schemaLocation="http://www.springframework.org/schema/beans
+        http://www.springframework.org/schema/beans/spring-beans-3.0.xsd
+        http://www.springframework.org/schema/context
+        http://www.springframework.org/schema/context/spring-context-3.0.xsd
+        http://www.springframework.org/schema/util
+        http://www.springframework.org/schema/util/spring-util-3.0.xsd"
+    default-autowire-candidates="*">
+
+    <context:annotation-config />
+    <!-- allows us to use spring annotations in beans -->
+
+    <bean class="org.dspace.app.ldn.service.impl.NotifyServiceImpl"/>
+    <bean class="org.dspace.app.ldn.service.impl.NotifyServiceInboundPatternServiceImpl"/>
+    <bean class="org.dspace.app.ldn.service.impl.LDNMessageServiceImpl"/>
+    <bean class="org.dspace.app.ldn.service.impl.NotifyPatternToTriggerImpl"/>
+
+    <bean name="ldnRouter" class="org.dspace.app.ldn.LDNRouter">
+        <property name="incomingProcessors">
+            <map key-type="java.util.Set" value-type="org.dspace.app.ldn.LDNProcessor">
+                <entry>
+                    <key>
+                        <set>
+                            <value>Announce</value>
+                            <value>coar-notify:ReviewAction</value>
+                        </set>
+                    </key>
+                    <ref bean="announceReviewAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>Announce</value>
+                            <value>coar-notify:EndorsementAction</value>
+                        </set>
+                    </key>
+                    <ref bean="announceEndorsementAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>Accept</value>
+                            <value>coar-notify:ReviewAction</value>
+                        </set>
+                    </key>
+                    <ref bean="acceptAckAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>TentativeReject</value>
+                            <value>coar-notify:ReviewAction</value>
+                        </set>
+                    </key>
+                    <ref bean="rejectAckAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>Accept</value>
+                            <value>coar-notify:EndorsementAction</value>
+                        </set>
+                    </key>
+                    <ref bean="acceptAckAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>TentativeReject</value>
+                            <value>coar-notify:EndorsementAction</value>
+                        </set>
+                    </key>
+                    <ref bean="rejectAckAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>Accept</value>
+                            <value>coar-notify:IngestAction</value>
+                        </set>
+                    </key>
+                    <ref bean="acceptAckAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>TentativeReject</value>
+                            <value>coar-notify:IngestAction</value>
+                        </set>
+                    </key>
+                    <ref bean="rejectAckAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>Announce</value>
+                            <value>coar-notify:RelationshipAction</value>
+                        </set>
+                    </key>
+                    <ref bean="announceReleaseAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>Offer</value>
+                            <value>coar-notify:ReviewAction</value>
+                        </set>
+                    </key>
+                    <ref bean="offerReviewAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>Offer</value>
+                            <value>coar-notify:IngestAction</value>
+                        </set>
+                    </key>
+                    <ref bean="offerIngestAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>Offer</value>
+                            <value>coar-notify:EndorsementAction</value>
+                        </set>
+                    </key>
+                    <ref bean="offerEndorsementAction" />
+                </entry>
+            </map>
+        </property>
+        <property name="outcomingProcessors">
+            <map key-type="java.util.Set" value-type="org.dspace.app.ldn.LDNProcessor">
+                <entry>
+                    <key>
+                        <set>
+                            <value>Offer</value>
+                            <value>coar-notify:ReviewAction</value>
+                        </set>
+                    </key>
+                    <ref bean="outcomingAnnounceReviewAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>Offer</value>
+                            <value>coar-notify:EndorsementAction</value>
+                        </set>
+                    </key>
+                    <ref bean="outcomingAnnounceEndorsementAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>Offer</value>
+                            <value>coar-notify:IngestAction</value>
+                        </set>
+                    </key>
+                    <ref bean="outcomingAnnounceIngestAction" />
+                </entry>
+                <entry>
+                    <key>
+                        <set>
+                            <value>Announce</value>
+                            <value>coar-notify:RelationshipAction</value>
+                        </set>
+                    </key>
+                    <ref bean="outcomingAnnounceRelationAction" />
+                </entry>
+            </map>
+        </property>
+    </bean>
+
+    <bean name="offerEndorsementAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.LDNEmailAction">
+                    <property name="actionSendFilter" value="${ldn.notification.email}" />
+                    <property name="actionSendEmailTextFile" value="coar_notify_reviewed" />
+                </bean>
+            </list>
+        </property>
+    </bean>
+
+    <bean name="offerIngestAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.LDNEmailAction">
+                    <property name="actionSendFilter" value="${ldn.notification.email}" />
+                    <property name="actionSendEmailTextFile" value="coar_notify_reviewed" />
+                </bean>
+            </list>
+        </property>
+    </bean>
+
+    <bean name="offerReviewAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.LDNEmailAction">
+                    <property name="actionSendFilter" value="${ldn.notification.email}" />
+                    <property name="actionSendEmailTextFile" value="coar_notify_reviewed" />
+                </bean>
+            </list>
+        </property>
+    </bean>
+
+    <bean name="announceReviewAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.LDNEmailAction">
+                    <property name="actionSendFilter" value="${ldn.notification.email}" />
+                    <property name="actionSendEmailTextFile" value="coar_notify_reviewed" />
+                </bean>
+                <bean class="org.dspace.app.ldn.action.LDNCorrectionAction">
+                	<property name="qaEventTopic" value="ENRICH/MORE/REVIEW"/>
+                </bean>
+            </list>
+        </property>
+    </bean>
+
+    <bean name="announceEndorsementAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.LDNEmailAction">
+                    <property name="actionSendFilter" value="${ldn.notification.email}" />
+                    <property name="actionSendEmailTextFile" value="coar_notify_endorsed" />
+                </bean>
+                <bean class="org.dspace.app.ldn.action.LDNCorrectionAction">
+                	<property name="qaEventTopic" value="ENRICH/MORE/ENDORSEMENT"/>
+                </bean>                
+            </list>
+        </property>
+    </bean>
+
+    <bean name="acceptAckAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.LDNEmailAction">
+                    <property name="actionSendFilter" value="${ldn.notification.email}" />
+                    <property name="actionSendEmailTextFile" value="coar_notify_accepted" />
+                </bean>
+            </list>
+        </property>
+    </bean>
+
+    <bean name="rejectAckAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.LDNEmailAction">
+                    <property name="actionSendFilter" value="${ldn.notification.email}" />
+                    <property name="actionSendEmailTextFile" value="coar_notify_rejected" />
+                </bean>
+            </list>
+        </property>
+    </bean>
+
+    <bean name="announceReleaseAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.LDNEmailAction">
+                    <property name="actionSendFilter" value="${ldn.notification.email}" />
+                    <property name="actionSendEmailTextFile" value="coar_notify_relationship" />
+                </bean>
+                <bean class="org.dspace.app.ldn.action.LDNRelationCorrectionAction">
+                	<property name="qaEventTopic" value="ENRICH/MORE/LINK"/>
+                </bean>
+            </list>
+        </property>
+    </bean>
+
+    <bean name="outcomingAnnounceReviewAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.SendLDNMessageAction"/>
+            </list>
+        </property>
+    </bean>
+
+    <bean name="outcomingAnnounceRelationAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.SendLDNMessageAction"/>
+            </list>
+        </property>
+    </bean>
+
+    <bean name="outcomingAnnounceEndorsementAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.SendLDNMessageAction"/>
+            </list>
+        </property>
+    </bean>
+
+    <bean name="outcomingAnnounceIngestAction" class="org.dspace.app.ldn.processor.LDNMetadataProcessor">
+        <property name="actions">
+            <list value-type="org.dspace.app.ldn.action.LDNAction">
+                <bean class="org.dspace.app.ldn.action.SendLDNMessageAction"/>
+            </list>
+        </property>
+    </bean>
+
+    <bean class="org.dspace.coarnotify.SubmissionNotifyServiceImpl"/>
+
+    <bean class="org.dspace.coarnotify.NotifyConfigurationService">
+        <property name="patterns">
+            <map>
+                <entry key="coarnotify">
+                    <list>
+                        <ref bean="requestReview"/>
+                        <ref bean="requestEndorsement"/>
+                        <ref bean="requestIngest" />
+                    </list>
+                </entry>
+            </map>
+        </property>
+    </bean>
+
+    <bean id="requestReview" class="org.dspace.coarnotify.NotifyPattern">
+        <property name="pattern" value="request-review"/>
+        <property name="multipleRequest" value="true"/>
+    </bean>
+
+    <bean id="requestEndorsement" class="org.dspace.coarnotify.NotifyPattern">
+        <property name="pattern" value="request-endorsement"/>
+        <property name="multipleRequest" value="true"/>
+    </bean>
+
+    <bean id="requestIngest" class="org.dspace.coarnotify.NotifyPattern">
+        <property name="pattern" value="request-ingest"/>
+        <property name="multipleRequest" value="false"/>
+    </bean>
+
+</beans>
\ No newline at end of file
diff --git a/dspace/config/spring/api/openaire-integration.xml b/dspace/config/spring/api/openaire-integration.xml
new file mode 100644
index 0000000000..8e4becddc5
--- /dev/null
+++ b/dspace/config/spring/api/openaire-integration.xml
@@ -0,0 +1,227 @@
+<beans xmlns="http://www.springframework.org/schema/beans"
+       xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+       xmlns:context="http://www.springframework.org/schema/context"
+       xmlns:util="http://www.springframework.org/schema/util"
+       xsi:schemaLocation="http://www.springframework.org/schema/beans
+           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
+           http://www.springframework.org/schema/context
+           http://www.springframework.org/schema/context/spring-context-2.5.xsd http://www.springframework.org/schema/util http://www.springframework.org/schema/util/spring-util.xsd"
+       default-autowire-candidates="*Service,*DAO,javax.sql.DataSource">
+
+    <context:annotation-config/>
+    <!-- allows us to use spring annotations in beans -->
+
+    <util:map id="openairePublicationsMetadataFieldMap" key-type="org.dspace.importer.external.metadatamapping.MetadataFieldConfig"
+              value-type="org.dspace.importer.external.metadatamapping.contributor.MetadataContributor">
+        <description>Defines which metadatum is mapped on which metadatum. Note that while the key must be unique it
+            only matters here for postprocessing of the value. The mapped MetadatumContributor has full control over
+            what metadatafield is generated.
+        </description>
+        <entry key-ref="openaire.title" value-ref="openaireTitleContrib"/>
+        <entry key-ref="openaire.summary" value-ref="openaireSummaryContrib"/>
+        <entry key-ref="openaire.published" value-ref="openairePublishedContrib"/>
+        <entry key-ref="openaire.doi" value-ref="openaireDoiContrib"/>
+        <entry key-ref="openaire.journal_ref" value-ref="openaireJournalContrib"/>
+        <entry key-ref="openaire.category.term" value-ref="openaireCategoryTermContrib"/>
+        <entry key-ref="openaire.author.name" value-ref="openaireAuthorContrib"/>
+        <entry key-ref="openaire.identifier.other" value-ref="openaireOtherContrib"/>
+    </util:map>
+
+
+    <bean id="openaireOtherContrib" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaire.identifier.other"/>
+        <property name="query" value="descendant::dri:objIdentifier"/>
+        <property name="prefixToNamespaceMapping" ref="openairePrefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaire.identifier.other" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="dc.identifier.other"/>
+    </bean>
+
+
+    <bean id="openaireTitleContrib" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaire.title"/>
+        <property name="query" value="descendant::oaf:result/title"/>
+        <property name="prefixToNamespaceMapping" ref="openairePrefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaire.title" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="dc.title"/>
+    </bean>
+
+    <bean id="openaireSummaryContrib" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaire.summary"/>
+        <property name="query" value="descendant::oaf:result/description"/>
+        <property name="prefixToNamespaceMapping" ref="openairePrefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaire.summary" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="dc.description.abstract"/>
+    </bean>
+
+    <bean id="openairePublishedContrib" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathDateFormatMetadataContributor">
+        <property name="dateFormatFrom" value="yyyy-MM-dd'T'HH:mm:ss'Z'"/>
+        <property name="dateFormatTo" value="yyyy-MM-dd"></property>
+        <property name="field" ref="openaire.published"/>
+        <property name="query" value="descendant::oaf:result/relevantdate"/>
+        <property name="prefixToNamespaceMapping" ref="openairePrefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaire.published" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="dc.date.issued"/>
+    </bean>
+
+    <bean id="openaireDoiContrib" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaire.doi"/>
+        <property name="query" value="descendant::oaf:result/pid"/>
+        <property name="prefixToNamespaceMapping" ref="openairePrefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaire.doi" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="dc.identifier"/>
+    </bean>
+
+    <bean id="openaireJournalContrib" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaire.journal_ref"/>
+        <property name="query" value="descendant::oaf:result/collectedfrom/@name"/>
+        <property name="prefixToNamespaceMapping" ref="openairePrefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaire.journal_ref" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="dc.source"/>
+    </bean>
+
+
+    <bean id="openaireCategoryTermContrib" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaire.category.term"/>
+        <property name="query" value="descendant::oaf:result/subject"/>
+        <property name="prefixToNamespaceMapping" ref="openairePrefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaire.category.term" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="dc.subject"/>
+    </bean>
+
+    <bean id="openaireAuthorContrib" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaire.author.name"/>
+        <property name="query" value="descendant::oaf:result/creator"/>
+        <property name="prefixToNamespaceMapping" ref="openairePrefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaire.author.name" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="dc.contributor.author"/>
+    </bean>
+
+    <util:map id="openairePrefixToNamespaceMapping" map-class="java.util.HashMap"
+        key-type="java.lang.String" value-type="java.lang.String">
+        <entry key="http://www.driver-repository.eu/namespace/dri" value="dri" />
+        <entry key="http://namespace.openaire.eu/oaf" value="oaf" />
+        <entry key="http://www.w3.org/2001/XMLSchema-instance" value="xsi" />
+    </util:map>
+    
+    <!--
+    <util:map id="openaireProjectsMetadataFieldMap" key-type="org.dspace.importer.external.metadatamapping.MetadataFieldConfig"
+              value-type="org.dspace.importer.external.metadatamapping.contributor.MetadataContributor">
+        <description>Defines which metadatum is mapped on which metadatum. Note that while the key must be unique it
+            only matters here for postprocessing of the value. The mapped MetadatumContributor has full control over
+            what metadatafield is generated.
+        </description>
+        <entry key-ref="openaireFunding.title" value-ref="openaireFundingTitle"/>
+        <entry key-ref="openaireFunding.acronym" value-ref="openaireFundingAcronym"/>
+        <entry key-ref="openaireFunding.code" value-ref="openaireFundingCode"/>
+        <entry key-ref="openaireFunding.startDate" value-ref="openaireFundingStartDate"/>
+        <entry key-ref="openaireFunding.endDate" value-ref="openaireFundingEndDate"/>
+        <entry key-ref="openaireFunding.funder" value-ref="openaireFundingFunder"/>
+        <entry key-ref="openaireFunding.callidentifier" value-ref="openaireFundingCall"/>
+        <entry key-ref="openaireFunding.summary" value-ref="openaireFundingSummary"/>
+        <entry key-ref="openaireFunding.oamandate" value-ref="openaireFundingOAMandate"/>
+    </util:map>
+
+    <bean id="openaireFundingTitle" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaireFunding.title"/>
+        <property name="query" value=".//title"/>
+        <property name="prefixToNamespaceMapping" ref="prefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaireFunding.title" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="dc.title"/>
+    </bean>
+    <bean id="openaireFundingAcronym" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaireFunding.acronym"/>
+        <property name="query" value=".//acronym"/>
+        <property name="prefixToNamespaceMapping" ref="prefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaireFunding.acronym" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="oairecerif.acronym"/>
+    </bean>
+    
+    <bean id="openaireFundingCode" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaireFunding.code"/>
+        <property name="query" value=".//code"/>
+        <property name="prefixToNamespaceMapping" ref="prefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaireFunding.code" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="oairecerif.funding.identifier"/>
+    </bean>
+
+    <bean id="openaireFundingStartDate" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaireFunding.startDate"/>
+        <property name="query" value=".//startdate"/>
+        <property name="prefixToNamespaceMapping" ref="prefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaireFunding.startDate" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="oairecerif.funding.startDate"/>
+    </bean>
+
+    <bean id="openaireFundingEndDate" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaireFunding.endDate"/>
+        <property name="query" value=".//enddate"/>
+        <property name="prefixToNamespaceMapping" ref="prefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaireFunding.endDate" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="oairecerif.funding.endDate"/>
+    </bean>
+    -->
+
+    <!-- <bean id="openaireFundingKeywords" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaireFunding.keywords"/>
+        <property name="query" value=".//keywords"/>
+        <property name="prefixToNamespaceMapping" ref="prefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaireFunding.keywords" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="dc.subject"/>
+    </bean> -->
+<!--
+    <bean id="openaireFundingFunder" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaireFunding.funder"/>
+        <property name="query" value=".//fundingtree/funder/name"/>
+        <property name="prefixToNamespaceMapping" ref="prefixToNamespaceMapping"/>
+    </bean>    
+    <bean id="openaireFunding.funder" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="oairecerif.funder"/>
+    </bean>
+
+    <bean id="openaireFundingCall" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaireFunding.callidentifier"/>
+        <property name="query" value=".//callidentifier"/>
+        <property name="prefixToNamespaceMapping" ref="prefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaireFunding.callidentifier" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="oairecerif.fundingParent"/>
+    </bean>
+
+    <bean id="openaireFundingOAMandate" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaireFunding.oamandate"/>
+        <property name="query" value=".//oamandatepublications"/>
+        <property name="prefixToNamespaceMapping" ref="prefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaireFunding.oamandate" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="oairecerif.oamandate"/>
+    </bean>
+
+    <bean id="openaireFundingSummary" class="org.dspace.importer.external.metadatamapping.contributor.SimpleXpathMetadatumContributor">
+        <property name="field" ref="openaireFunding.summary"/>
+        <property name="query" value=".//summary"/>
+        <property name="prefixToNamespaceMapping" ref="prefixToNamespaceMapping"/>
+    </bean>
+    <bean id="openaireFunding.summary" class="org.dspace.importer.external.metadatamapping.MetadataFieldConfig">
+        <constructor-arg value="dc.description"/>
+    </bean>
+-->
+
+    <bean class="java.lang.Integer" id="maxRetry">
+        <constructor-arg value="3"/>
+    </bean>
+
+</beans>
\ No newline at end of file
diff --git a/dspace/config/spring/api/qaevents.xml b/dspace/config/spring/api/qaevents.xml
new file mode 100644
index 0000000000..74b72af61b
--- /dev/null
+++ b/dspace/config/spring/api/qaevents.xml
@@ -0,0 +1,159 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<beans xmlns="http://www.springframework.org/schema/beans"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xmlns:context="http://www.springframework.org/schema/context"
+    xmlns:util="http://www.springframework.org/schema/util"
+    xsi:schemaLocation="http://www.springframework.org/schema/beans
+           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
+           http://www.springframework.org/schema/context
+           http://www.springframework.org/schema/context/spring-context-2.5.xsd
+           http://www.springframework.org/schema/util
+           http://www.springframework.org/schema/util/spring-util.xsd">
+
+    <context:annotation-config /> <!-- allows us to use spring annotations in beans -->
+
+    <bean id="qaEventsDao" class="org.dspace.qaevent.dao.impl.QAEventsDAOImpl" />
+    
+    <bean id="openaireBrokerClient" class="eu.dnetlib.broker.BrokerClient" />
+    
+    <bean id="openaireClientFactory" class="org.dspace.qaevent.service.impl.OpenaireClientFactoryImpl" />
+ 
+     <bean id="org.dspace.qaevent.service.QAEventActionService" class="org.dspace.qaevent.service.impl.QAEventActionServiceImpl">
+        <property name="topicsToActions">
+            <map>
+            	<!--The key are the TOPIC, the value must be a valid implementation of the org.dspace.qaevent.QAEventAction interface -->
+               <entry value-ref="ProjectLinkedEntityAction">
+                  <key><util:constant static-field="org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MORE_PROJECT"/></key>
+               </entry>
+               <entry value-ref="ProjectLinkedEntityAction">
+                  <key><util:constant static-field="org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_PROJECT"/></key>
+			   </entry>
+               <entry value-ref="AbstractMetadataAction">
+                  <key><util:constant static-field="org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_ABSTRACT"/></key>
+               </entry>
+               <entry value-ref="AddReviewMetadataAction">
+                  <key><util:constant static-field="org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MORE_REVIEW"/></key>
+               </entry>
+               <entry value-ref="AddEndorsedMetadataAction">
+                  <key><util:constant static-field="org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MORE_ENDORSEMENT"/></key>
+               </entry>
+               <entry value-ref="PIDMetadataAction">
+                  <key><util:constant static-field="org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MORE_PID"/></key>
+               </entry>
+               <entry value-ref="PIDMetadataAction">
+                  <key><util:constant static-field="org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MISSING_PID"/></key>
+               </entry>
+               <entry value-ref="RelationMetadataAction">
+                  <key><util:constant static-field="org.dspace.qaevent.QANotifyPatterns.TOPIC_ENRICH_MORE_LINK"/></key>
+               </entry>
+               <entry key="REQUEST/WITHDRAWN" value-ref="WithdrawnRequestAction" />
+               <entry key="REQUEST/REINSTATE" value-ref="ReinstateRequestAction" />
+            </map>
+        </property>
+     </bean>
+     
+     <!-- This action bind the publication to the project, otherwise if the project has not been specified, 
+      create a new project with the available data and then bind it to the publication -->
+     <bean id="ProjectLinkedEntityAction" class="org.dspace.qaevent.action.QAEntityOpenaireMetadataAction">
+        <!-- which metadata will hold the relation between the publication and the project -->
+        <property name="relation" value="isPublicationOfProject" />
+        <!-- the type of local entity used to store the project details -->
+        <property name="entityType" value="Project" />
+        <property name="entityMetadata">
+            <map>
+	<!--The key are the json path of qa message, the value is the metadata in 
+		the linked entity where the information should be stored -->
+               <!--  <entry key="acronym" value="" /> -->
+               <entry key="code" value="dc.identifier" />
+               <!--  <entry key="funder" value="oairecerif.funder" /> -->
+	           <entry key="title" value="dc.title" />
+	           <!--  <entry key="fundingProgram" value="oairecerif.fundingProgram" /> -->
+	           <!--  <entry key="openaireId" value="oairecerif.funding.identifier" /> -->
+            </map>
+        </property>    
+     </bean>
+     <bean id="AbstractMetadataAction" class="org.dspace.qaevent.action.QAOpenaireSimpleMetadataAction">
+        <property name="metadata" value="dc.description.abstract" />
+     </bean>
+     <bean id="AddReviewMetadataAction" class="org.dspace.qaevent.action.QANotifySimpleMetadataAction">
+        <property name="metadata" value="datacite.relation.isReviewedBy" />
+     </bean>
+
+     <bean id="AddEndorsedMetadataAction" class="org.dspace.qaevent.action.QANotifySimpleMetadataAction">
+        <property name="metadata" value="coar.notify.endorsedBy"/>
+     </bean>
+     <!-- Add a new identifier to the given item, using the defined types mapping -->
+     <bean id="PIDMetadataAction" class="org.dspace.qaevent.action.QAOpenaireMetadataMapAction">
+	     <property name="types">
+	         <map>
+	<!--The key are the type of identifier (or subject) reported in the message, the value is the metadata in 
+        the linked entity where the information should be stored -->
+               <entry key="default" value="dc.identifier.other" />
+               <!-- <entry key="doi" value="dc.identifier.doi" />
+               <entry key="pmid" value="dc.identifier.pmid" /> -->
+	         </map>
+	     </property>    
+     </bean>
+
+     <bean id="RelationMetadataAction" class="org.dspace.qaevent.action.QANotifyMetadataMapAction">
+	     <property name="types">
+	         <map>
+               <entry key="default" value="datacite.relation.isReferencedBy" />
+               <entry key="http://purl.org/vocab/frbr/core#supplement" value="datacite.relation.isSupplementedBy" />
+	         </map>
+	     </property>
+     </bean>
+
+    <bean id="submitterQASecurity" class="org.dspace.qaevent.security.UserBasedFilterQASecurity">
+        <property name="filterTemplate">
+            <!-- we need to escape the { as it as a special meaning for the message format -->
+            <!-- argument {0} will be replaced with the uuid of the loggedin user -->
+            <value>'{'!join from=search.resourceid to=resource_uuid fromIndex=${solr.multicorePrefix}search}submitter_authority:{0}</value>
+        </property>
+    </bean>
+    <!--
+        To configure rules to automatic process specific qaevent you must provide a qaAutomaticProcessingMap
+        where the keys are the qaevent source provider name and the value is a reference to a
+        AutomaticProcessingEvaluation implementation. Below you can find an example of configuration defining
+        some thresholds rules for the coar-notify generated QAEvent to be approved, rejected and ignored
+     -->
+    <!--
+    <util:map id="qaAutomaticProcessingMap">
+        <entry key="coar-notify" value-ref="qaScoreEvaluation"/>
+    </util:map>
+
+    <bean id="qaScoreEvaluation" class="org.dspace.qaevent.QAScoreAutomaticProcessingEvaluation">
+        <property name="scoreToReject" value="0.3" />
+        <property name="scoreToIgnore" value="0.5" />
+        <property name="scoreToApprove" value="0.8" />
+        <property name="itemFilterToReject" ref="simple-demo_filter" />
+        <property name="itemFilterToIgnore" ref="simple-demo_filter" />
+        <property name="itemFilterToApprove" ref="simple-demo_filter" />
+    </bean>
+	-->
+
+    <bean id="WithdrawnRequestAction" class="org.dspace.qaevent.action.QAWithdrawnRequestAction" />
+
+    <bean id="ReinstateRequestAction" class="org.dspace.qaevent.action.QAReinstateRequestAction" />
+
+    <bean id="org.dspace.qaevent.service.QAEventSecurityService" class="org.dspace.qaevent.service.impl.QAEventSecurityServiceImpl">
+        <property name="defaultSecurity">
+            <bean class="org.dspace.qaevent.security.AdministratorsOnlyQASecurity" />
+        </property>
+        <property name="qaSecurityConfiguration">
+            <map>
+                <entry key="DSpaceUsers" value-ref="submitterWithdrawnReinstateQASecurity" />
+                <entry key="coar-notify" value-ref="submitterQASecurity" />
+            </map>
+        </property>
+    </bean>
+
+    <bean id="submitterWithdrawnReinstateQASecurity" class="org.dspace.qaevent.security.UserBasedFilterQASecurity">
+        <property name="filterTemplate">
+            <!-- we need to escape the { as it as a special meaning for the message format -->
+            <!-- argument {0} will be replaced with the uuid of the loggedin user -->
+            <value>original_id:{0}</value>
+        </property>
+    </bean>
+
+ </beans>
diff --git a/dspace/config/spring/api/scripts.xml b/dspace/config/spring/api/scripts.xml
index 56eacbfff2..4a372d1c6d 100644
--- a/dspace/config/spring/api/scripts.xml
+++ b/dspace/config/spring/api/scripts.xml
@@ -3,6 +3,12 @@
     xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
     xsi:schemaLocation="http://www.springframework.org/schema/beans
            http://www.springframework.org/schema/beans/spring-beans-2.5.xsd">
+
+    <bean id="import-openaire-events" class="org.dspace.qaevent.script.OpenaireEventsImportCliScriptConfiguration" primary="true">
+        <property name="description" value="Import new Openaire quality assurance broker events"/>
+        <property name="dspaceRunnableClass" value="org.dspace.qaevent.script.OpenaireEventsImportCli"/>
+    </bean>
+
     <bean id="index-discovery" class="org.dspace.discovery.IndexDiscoveryScriptConfiguration">
         <property name="description" value="Update Discovery Solr Search Index"/>
         <property name="dspaceRunnableClass" value="org.dspace.discovery.IndexClient"/>
@@ -91,4 +97,9 @@
         <property name="dspaceRunnableClass" value="org.dspace.app.bulkaccesscontrol.BulkAccessControlCli"/>
     </bean>
 
+    <bean id="import-openaire-suggestions" class="org.dspace.app.suggestion.openaire.PublicationLoaderCliScriptConfiguration">
+       <property name="description" value="Imports suggestions from OpenAIRE for publication claim"/>
+       <property name="dspaceRunnableClass" value="org.dspace.app.suggestion.openaire.PublicationLoaderRunnableCli"/>
+    </bean>
+
 </beans>
diff --git a/dspace/config/spring/api/solr-services.xml b/dspace/config/spring/api/solr-services.xml
index 80e9449d4c..41859af1c4 100644
--- a/dspace/config/spring/api/solr-services.xml
+++ b/dspace/config/spring/api/solr-services.xml
@@ -31,7 +31,13 @@
     <bean id="solrLoggerService" class="org.dspace.statistics.SolrLoggerServiceImpl" lazy-init="true"/>
 
     <bean class="org.dspace.statistics.SolrStatisticsCore" autowire-candidate="true"/>
-    
+
+    <!-- quality assurance broker service -->
+    <bean id="org.dspace.qaevent.service.QAEventService" class="org.dspace.qaevent.service.impl.QAEventServiceImpl" />
+
     <bean class="org.dspace.statistics.GeoIpService" autowire-candidate="true"/>
 
+    <!-- suggestion service for solr providers -->
+    <bean id="org.dspace.app.suggestion.SolrSuggestionStorageService" class="org.dspace.app.suggestion.SolrSuggestionStorageServiceImpl" />
+
 </beans>
diff --git a/dspace/config/spring/api/suggestions.xml b/dspace/config/spring/api/suggestions.xml
new file mode 100644
index 0000000000..85e7949809
--- /dev/null
+++ b/dspace/config/spring/api/suggestions.xml
@@ -0,0 +1,61 @@
+<?xml version="1.0" encoding="UTF-8"?>
+<beans xmlns="http://www.springframework.org/schema/beans"
+    xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
+    xmlns:context="http://www.springframework.org/schema/context"
+    xmlns:util="http://www.springframework.org/schema/util"
+    xsi:schemaLocation="http://www.springframework.org/schema/beans
+           http://www.springframework.org/schema/beans/spring-beans-2.5.xsd
+           http://www.springframework.org/schema/context
+           http://www.springframework.org/schema/context/spring-context-2.5.xsd
+           http://www.springframework.org/schema/util 
+           http://www.springframework.org/schema/util/spring-util-3.0.xsd">
+
+    <context:annotation-config /> <!-- allows us to use spring annotations in beans -->
+
+    <!-- This is defined in the solr-services.xml
+	<bean id="org.dspace.app.nbevent.service.NBEventService" 
+	   class="org.dspace.app.nbevent.service.impl.NBEventServiceImpl" /> -->
+ 
+	 <util:map id="suggestionProviders" map-class="java.util.HashMap" 
+	          key-type="java.lang.String" value-type="org.dspace.app.suggestion.SuggestionProvider">
+	    <entry key="openaire" value-ref="OpenairePublicationLoader" />
+	</util:map>
+
+    <bean id="OpenairePublicationLoader" class="org.dspace.app.suggestion.openaire.PublicationLoader">
+        <property name="sourceName" value="openaire" />
+        <property name="primaryProvider" ref="openaireLiveImportDataProviderByAuthor" />
+        <property name="otherProviders">
+            <list>
+                <ref bean="openaireLiveImportDataProviderByTitle"/>
+            </list>
+        </property>
+        <property name="names">
+            <list>
+                <value>dc.title</value>
+            </list>
+        </property>
+        <property name="pipeline">
+            <list>
+                <bean
+                    class="org.dspace.app.suggestion.openaire.AuthorNamesScorer">
+                    <property name="contributorMetadata">
+                        <list>
+                            <value>dc.contributor.author</value>
+                        </list>
+                    </property>
+                    <property name="names">
+                        <list>
+                            <value>dc.title</value>
+                        </list>
+                    </property>
+                </bean>
+                <bean
+                    class="org.dspace.app.suggestion.openaire.DateScorer">
+                    <property name="birthDateMetadata" value="person.birthDate" />
+                    <property name="publicationDateMetadata" value="dc.date.issued" />
+                </bean>    
+            </list>
+        </property>
+    </bean>
+
+ </beans>
diff --git a/dspace/config/spring/rest/scripts.xml b/dspace/config/spring/rest/scripts.xml
index eda8c579a8..03fe2d01fd 100644
--- a/dspace/config/spring/rest/scripts.xml
+++ b/dspace/config/spring/rest/scripts.xml
@@ -8,6 +8,11 @@
 
     <!-- This primary attribute is present so that we can assure that in the REST layer we'll always use this
         bean if it is present-->
+    <bean id="import-openaire-events" class="org.dspace.qaevent.script.OpenaireEventsImportScriptConfiguration" primary="true">
+        <property name="description" value="Import new openaire quality assurance broker events"/>
+        <property name="dspaceRunnableClass" value="org.dspace.qaevent.script.OpenaireEventsImport"/>
+    </bean>
+
     <bean id="metadata-import" class="org.dspace.app.bulkedit.MetadataImportScriptConfiguration" primary="true">
         <property name="description" value="Import metadata after batch editing" />
         <property name="dspaceRunnableClass" value="org.dspace.app.bulkedit.MetadataImport"/>
diff --git a/dspace/config/submission-forms.xml b/dspace/config/submission-forms.xml
index 39a4778356..d888e0990e 100644
--- a/dspace/config/submission-forms.xml
+++ b/dspace/config/submission-forms.xml
@@ -819,9 +819,9 @@
 
         </form>
 
-        <!-- OpenAIRE specific forms -->
+        <!-- Openaire specific forms -->
 
-        <form name="openAIREPublicationPageoneForm">
+        <form name="openairePublicationPageoneForm">
             <row>
                 <field>
                     <dc-schema>dc</dc-schema>
@@ -1071,7 +1071,7 @@
             </row>
         </form>
 
-        <form name="openAIREPublicationPagetwoForm">
+        <form name="openairePublicationPagetwoForm">
             <row>
                 <field>
                     <dc-schema>dc</dc-schema>
@@ -1129,7 +1129,7 @@
                         <dc-element>relation</dc-element>
                         <input-type>onebox</input-type>
                     </linked-metadata-field>
-                    <externalsources>openAIREFunding</externalsources>
+                    <externalsources>openaireFunding</externalsources>
                     <required></required>
                 </relation-field>
             </row>
@@ -1182,7 +1182,7 @@
             </row>
         </form>
 
-        <form name="openAIREPersonForm">
+        <form name="openairePersonForm">
             <row>
                 <field>
                     <dc-schema>person</dc-schema>
@@ -1246,7 +1246,7 @@
             </row>
         </form>
 
-        <form name="openAIREProjectForm">
+        <form name="openaireProjectForm">
             <row>
                 <field>
                     <dc-schema>dc</dc-schema>
@@ -1269,7 +1269,7 @@
             <row>
                 <relation-field>
                     <relationship-type>isFundingAgencyOfProject</relationship-type>
-                    <search-configuration>openAIREFundingAgency</search-configuration>
+                    <search-configuration>openaireFundingAgency</search-configuration>
                     <repeatable>false</repeatable>
                     <name-variants>false</name-variants>
                     <label>Funding Agency</label>
@@ -1302,7 +1302,7 @@
             </row>
         </form>
 
-        <form name="openAIREOrganizationForm">
+        <form name="openaireOrganizationForm">
             <row>
                 <field>
                     <dc-schema>organization</dc-schema>
@@ -1537,7 +1537,7 @@
             </pair>
         </value-pairs>
 
-        <!-- OpenAIRE specific value pairs -->
+        <!-- Openaire specific value pairs -->
 
         <value-pairs value-pairs-name="openaire_license_types" dc-term="license">
 
@@ -1579,7 +1579,7 @@
 
         </value-pairs>
 
-        <!-- OpenAIRE document types
+        <!-- Openaire document types
              https://openaire-guidelines-for-literature-repository-managers.readthedocs.io/en/v4.0.0/field_publicationtype.html
              Based on COAR Vocabularies -> Controlled Vocabulary for Resource Type Genres (Version 2.0):
              http://vocabularies.coar-repositories.org/documentation/resource_types/
diff --git a/dspace/solr/qaevent/conf/protwords.txt b/dspace/solr/qaevent/conf/protwords.txt
new file mode 100644
index 0000000000..1dfc0abecb
--- /dev/null
+++ b/dspace/solr/qaevent/conf/protwords.txt
@@ -0,0 +1,21 @@
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#-----------------------------------------------------------------------
+# Use a protected word file to protect against the stemmer reducing two
+# unrelated words to the same base word.
+
+# Some non-words that normally won't be encountered,
+# just to test that they won't be stemmed.
+dontstems
+zwhacky
+
diff --git a/dspace/solr/qaevent/conf/schema.xml b/dspace/solr/qaevent/conf/schema.xml
new file mode 100644
index 0000000000..4bcadcd5a1
--- /dev/null
+++ b/dspace/solr/qaevent/conf/schema.xml
@@ -0,0 +1,226 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+
+<!--
+    This is the DSpace "qaevent" core, which stores the events coming from the Quality Assurance Broker.
+-->
+<schema name="qaevent" version="1.5">
+
+  <types>
+    
+    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
+
+    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
+
+    <fieldType name="int" class="solr.IntPointField" omitNorms="true" positionIncrementGap="0" docValues="true"/>
+    <fieldType name="float" class="solr.FloatPointField" omitNorms="true" positionIncrementGap="0" docValues="true"/>
+    <fieldType name="long" class="solr.LongPointField" omitNorms="true" positionIncrementGap="0" docValues="true"/>
+    <fieldType name="double" class="solr.DoublePointField" omitNorms="true" positionIncrementGap="0" docValues="true"/>
+    <fieldType name="date" class="solr.DatePointField" omitNorms="true" positionIncrementGap="0" docValues="true"/>
+
+    <fieldType name="pint" class="solr.IntPointField" omitNorms="true" docValues="true"/>
+    <fieldType name="plong" class="solr.LongPointField" omitNorms="true" docValues="true"/>
+    <fieldType name="pfloat" class="solr.FloatPointField" omitNorms="true" docValues="true"/>
+    <fieldType name="pdouble" class="solr.DoublePointField" omitNorms="true" docValues="true"/>
+    <fieldType name="pdate" class="solr.DatePointField" sortMissingLast="true" omitNorms="true" docValues="true"/>
+
+    <fieldType name="sint" class="solr.IntPointField" sortMissingLast="true" omitNorms="true" docValues="true"/>
+    <fieldType name="slong" class="solr.LongPointField" sortMissingLast="true" omitNorms="true" docValues="true"/>
+    <fieldType name="sfloat" class="solr.FloatPointField" sortMissingLast="true" omitNorms="true" docValues="true"/>
+    <fieldType name="sdouble" class="solr.DoublePointField" sortMissingLast="true" omitNorms="true" docValues="true"/>
+
+    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
+
+    <!-- A text field that only splits on whitespace for exact matching of words -->
+    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+      <analyzer>
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      </analyzer>
+    </fieldType>
+
+   	<fieldType name="text" class="solr.TextField" positionIncrementGap="100">
+      <analyzer type="index">
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.StopFilterFactory"
+                ignoreCase="true"
+                words="stopwords.txt"
+                />
+        <filter class="solr.WordDelimiterFilterFactory"
+                generateWordParts="1"
+                generateNumberParts="1"
+                catenateWords="1"
+                catenateNumbers="1"
+                catenateAll="0"
+                splitOnCaseChange="1"/>
+        <filter class="org.apache.lucene.analysis.icu.ICUFoldingFilterFactory"/>
+        <filter class="solr.SnowballPorterFilterFactory" language="English" protected="protwords.txt"/>
+        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+      </analyzer>
+      <analyzer type="query">
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+        <filter class="solr.StopFilterFactory"
+                ignoreCase="true"
+                words="stopwords.txt"
+                />
+        <filter class="solr.WordDelimiterFilterFactory"
+                generateWordParts="1"
+                generateNumberParts="1"
+                catenateWords="0"
+                catenateNumbers="0"
+                catenateAll="0"
+                splitOnCaseChange="1"/>
+        <filter class="org.apache.lucene.analysis.icu.ICUFoldingFilterFactory"/>
+        <filter class="solr.SnowballPorterFilterFactory" language="English" protected="protwords.txt"/>
+        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+      </analyzer>
+    </fieldType>
+
+    <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100" >
+      <analyzer>
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
+        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+        <filter class="solr.WordDelimiterFilterFactory"
+                generateWordParts="0"
+                generateNumberParts="0"
+                catenateWords="1"
+                catenateNumbers="1"
+                catenateAll="0"/>
+        <filter class="solr.LowerCaseFilterFactory"/>
+        <filter class="solr.SnowballPorterFilterFactory" language="English" protected="protwords.txt"/>
+        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+      </analyzer>
+    </fieldType>
+
+    <fieldType name="textgen" class="solr.TextField" positionIncrementGap="100">
+      <analyzer type="index">
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.StopFilterFactory"
+                ignoreCase="true"
+                words="stopwords.txt" />
+        <filter class="solr.WordDelimiterFilterFactory"
+                generateWordParts="1"
+                generateNumberParts="1"
+                catenateWords="1"
+                catenateNumbers="1"
+                catenateAll="0"
+                splitOnCaseChange="0"/>
+        <filter class="solr.LowerCaseFilterFactory"/>
+      </analyzer>
+      <analyzer type="query">
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+        <filter class="solr.StopFilterFactory"
+                ignoreCase="true"
+                words="stopwords.txt"
+                />
+        <filter class="solr.WordDelimiterFilterFactory"
+                generateWordParts="1"
+                generateNumberParts="1"
+                catenateWords="0"
+                catenateNumbers="0"
+                catenateAll="0"
+                splitOnCaseChange="0"/>
+        <filter class="solr.LowerCaseFilterFactory"/>
+      </analyzer>
+    </fieldType>
+
+    <fieldtype name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField" />
+
+    <fieldType name="lowerCaseSort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+      <analyzer>
+        <tokenizer class="solr.KeywordTokenizerFactory"/>
+        <filter class="solr.LowerCaseFilterFactory" />
+        <filter class="solr.TrimFilterFactory" />
+      </analyzer>
+    </fieldType>
+
+    <fieldType name="keywordFilter" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+        <analyzer>
+            <!--Treats the entire field as a single token, regardless of its content-->
+            <tokenizer class="solr.KeywordTokenizerFactory"/>
+
+            <!--<filter class="solr.LowerCaseFilterFactory" />-->
+            <filter class="solr.TrimFilterFactory" />
+        </analyzer>
+    </fieldType>
+
+    <fieldType name="textSpell" class="solr.TextField"
+               positionIncrementGap="100" stored="false" multiValued="true">
+        <analyzer type="index">
+            <tokenizer class="solr.StandardTokenizerFactory"/>
+            <filter class="solr.LowerCaseFilterFactory"/>
+            <filter class="solr.SynonymFilterFactory"
+                    synonyms="synonyms.txt" ignoreCase="true"
+                    expand="true"/>
+            <filter class="solr.StopFilterFactory" ignoreCase="true"
+                    words="stopwords.txt"/>
+            <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+        </analyzer>
+        <analyzer type="query">
+            <tokenizer class="solr.StandardTokenizerFactory"/>
+            <filter class="solr.LowerCaseFilterFactory"/>
+            <filter class="solr.StopFilterFactory" ignoreCase="true"
+                    words="stopwords.txt"/>
+            <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+        </analyzer>
+    </fieldType>
+ </types>
+
+
+ <fields>
+ 
+ 	<field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+
+    <!-- The event source -->
+    <field name="source" type="string" indexed="true" stored="true" omitNorms="true" />
+    <!-- The event id -->
+    <field name="event_id" type="string" indexed="true" stored="true" omitNorms="true" />
+    <!-- The event original id -->
+    <field name="original_id" type="string" indexed="true" stored="true" omitNorms="true" />
+    <!-- The subject title -->
+    <field name="title" type="string" indexed="true" stored="true" omitNorms="true" />
+    <!-- The event topic -->
+	<field name="topic" type="string" indexed="true" stored="true" omitNorms="true" />
+    <!-- The event trust -->
+	<field name="trust" type="double" indexed="true" stored="true" omitNorms="true" />
+    <!-- The event message -->
+	<field name="message" type="string" indexed="true" stored="true" omitNorms="true" />
+    <!-- The uuid of the item related to the event -->
+	<field name="resource_uuid" type="string" indexed="true" stored="true" omitNorms="true" />
+    <!-- The uuid of the second item related to the event-->
+	<field name="related_uuid" type="string" indexed="true" stored="true" omitNorms="true" />
+    <!-- The last update date -->
+	<field name="last_update" type="date" indexed="true" stored="true" omitNorms="true" />
+   	    
+   	<dynamicField name="*_i"  type="int"    indexed="true"  stored="true" multiValued="true" docValues="true"/>
+   	<dynamicField name="*_s"  type="string"  indexed="true"  stored="true" multiValued="true" docValues="true"/>
+   	<dynamicField name="*_l"  type="long"   indexed="true"  stored="true" multiValued="true" docValues="true"/>
+   	<dynamicField name="*_t"  type="text"    indexed="true"  stored="true" multiValued="true" />
+   	<dynamicField name="*_b"  type="boolean" indexed="true"  stored="true" multiValued="true" />
+   	<dynamicField name="*_f"  type="float"  indexed="true"  stored="true" multiValued="true" docValues="true"/>
+   	<dynamicField name="*_d"  type="double" indexed="true"  stored="true" multiValued="true" docValues="true"/>
+   	<dynamicField name="*_dt" type="date" indexed="true"  stored="true" multiValued="true"/>
+   	<dynamicField name="*_signature" type="string" indexed="true" stored="true" omitNorms="true" multiValued="true" docValues="true"/>
+       	
+ </fields>
+
+ <uniqueKey>event_id</uniqueKey>
+ 
+</schema>
diff --git a/dspace/solr/qaevent/conf/solrconfig.xml b/dspace/solr/qaevent/conf/solrconfig.xml
new file mode 100644
index 0000000000..2a5f1ef4e9
--- /dev/null
+++ b/dspace/solr/qaevent/conf/solrconfig.xml
@@ -0,0 +1,127 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+
+<!--
+    DSpace 'qaevent' core.
+
+    For more details about configurations options that may appear in
+    this file, see http://wiki.apache.org/solr/SolrConfigXml.
+-->
+<config>
+    <luceneMatchVersion>8.8.1</luceneMatchVersion>
+    
+    <!-- Include contributed libraries that we use in DSpace. -->
+    <lib dir='${solr.install.dir}/contrib/analysis-extras/lib/'
+         regex='icu4j-.*\.jar'/>
+    <lib dir='${solr.install.dir}/contrib/analysis-extras/lucene-libs/'
+         regex='lucene-analyzers-icu-.*\.jar'/>
+
+    <dataDir>${solr.data.dir:}</dataDir>
+
+    <directoryFactory name="DirectoryFactory"
+                      class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}"/>
+
+    <codecFactory class="solr.SchemaCodecFactory"/>
+
+    <!-- Use classic schema.xml & disallow programmatic changes to schema at runtime -->
+    <schemaFactory class="ClassicIndexSchemaFactory"/>
+
+    <indexConfig>
+        <ramBufferSizeMB>32</ramBufferSizeMB>
+        <maxBufferedDocs>1000</maxBufferedDocs>
+        <lockType>${solr.lock.type:native}</lockType>
+        <!-- Set to true to "write detailed debug information from the indexing process as Solr log messages" -->
+        <infoStream>false</infoStream>
+    </indexConfig>
+
+    <!-- Settings for how updates are done internally -->
+    <updateHandler class="solr.DirectUpdateHandler2">
+        <!-- How often should commits be done automatically -->
+        <autoCommit>
+            <maxDocs>10000</maxDocs> <!--Commit every 10.000 documents-->
+            <maxTime>${solr.autoCommit.maxTime:10000}</maxTime> <!--Default commit every 10 seconds-->
+            <openSearcher>true</openSearcher>
+        </autoCommit>
+
+        <autoSoftCommit>
+            <maxTime>${solr.autoSoftCommit.maxTime:-1}</maxTime>
+        </autoSoftCommit>
+    </updateHandler>
+
+    <!-- Settings for how Solr will process & respond to queries -->
+    <query>
+        <maxBooleanClauses>${solr.max.booleanClauses:1024}</maxBooleanClauses>
+
+        <!-- Cache used by SolrIndexSearcher for filters (DocSets) for
+                 unordered sets of *all* documents that match a query. Caches results of 'fq' search param. -->
+        <filterCache class="solr.search.CaffeineCache"
+                     size="512"
+                     initialSize="512"
+                     autowarmCount="0"/>
+
+        <!-- Caches results of previous searches - ordered lists of document ids
+         (DocList) based on a query, a sort, and the range of documents requested. -->
+        <queryResultCache class="solr.search.CaffeineCache"
+                          size="512"
+                          initialSize="512"
+                          autowarmCount="0"/>
+
+        <!-- Caches Lucene Document objects (the stored fields for each
+         document).  Since Lucene internal document ids are transient,
+         this cache will not be autowarmed. -->
+        <documentCache class="solr.search.CaffeineCache"
+                       size="512"
+                       initialSize="512"
+                       autowarmCount="0"/>
+
+        <enableLazyFieldLoading>true</enableLazyFieldLoading>
+        <queryResultWindowSize>20</queryResultWindowSize>
+        <queryResultMaxDocsCached>200</queryResultMaxDocsCached>
+        <useColdSearcher>false</useColdSearcher>
+        <maxWarmingSearchers>2</maxWarmingSearchers>
+    </query>
+
+    <!-- Controls how the Solr HTTP RequestDispatcher responds to requests -->
+    <requestDispatcher handleSelect="false" >
+        <requestParsers enableRemoteStreaming="true"
+                        multipartUploadLimitInKB="-1"
+                        formdataUploadLimitInKB="-1"
+                        addHttpRequestToContext="false"/>
+
+        <httpCaching never304="true" />
+    </requestDispatcher>
+
+    <!-- Process requests to /select path -->
+    <requestHandler name="/select" class="solr.SearchHandler">
+     <lst name="defaults">
+       <str name="echoParams">explicit</str>
+       <int name="rows">10</int>
+       <str name="df">event_id</str>
+     </lst>
+    </requestHandler>
+
+    <!-- Processes updates to the index -->
+    <requestHandler name="/update" class="solr.UpdateRequestHandler"/>
+
+    <requestHandler name="/update/json" class="solr.UpdateRequestHandler">
+        <lst name="defaults">
+            <str name="stream.contentType">application/json</str>
+        </lst>
+    </requestHandler>
+</config>
+
diff --git a/dspace/solr/qaevent/conf/stopwords.txt b/dspace/solr/qaevent/conf/stopwords.txt
new file mode 100644
index 0000000000..8433c832d2
--- /dev/null
+++ b/dspace/solr/qaevent/conf/stopwords.txt
@@ -0,0 +1,57 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#-----------------------------------------------------------------------
+# a couple of test stopwords to test that the words are really being
+# configured from this file:
+stopworda
+stopwordb
+
+#Standard english stop words taken from Lucene's StopAnalyzer
+an
+and
+are
+as
+at
+be
+but
+by
+for
+if
+in
+into
+is
+it
+no
+not
+of
+on
+or
+s
+such
+t
+that
+the
+their
+then
+there
+these
+they
+this
+to
+was
+will
+with
+
diff --git a/dspace/solr/qaevent/conf/synonyms.txt b/dspace/solr/qaevent/conf/synonyms.txt
new file mode 100644
index 0000000000..b0e31cb7ec
--- /dev/null
+++ b/dspace/solr/qaevent/conf/synonyms.txt
@@ -0,0 +1,31 @@
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#-----------------------------------------------------------------------
+#some test synonym mappings unlikely to appear in real input text
+aaa => aaaa
+bbb => bbbb1 bbbb2
+ccc => cccc1,cccc2
+a\=>a => b\=>b
+a\,a => b\,b
+fooaaa,baraaa,bazaaa
+
+# Some synonym groups specific to this example
+GB,gib,gigabyte,gigabytes
+MB,mib,megabyte,megabytes
+Television, Televisions, TV, TVs
+#notice we use "gib" instead of "GiB" so any WordDelimiterFilter coming
+#after us won't split it into two words.
+
+# Synonym mappings can be used for spelling correction too
+pixima => pixma
+
diff --git a/dspace/solr/qaevent/core.properties b/dspace/solr/qaevent/core.properties
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/dspace/solr/suggestion/conf/protwords.txt b/dspace/solr/suggestion/conf/protwords.txt
new file mode 100644
index 0000000000..1dfc0abecb
--- /dev/null
+++ b/dspace/solr/suggestion/conf/protwords.txt
@@ -0,0 +1,21 @@
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#-----------------------------------------------------------------------
+# Use a protected word file to protect against the stemmer reducing two
+# unrelated words to the same base word.
+
+# Some non-words that normally won't be encountered,
+# just to test that they won't be stemmed.
+dontstems
+zwhacky
+
diff --git a/dspace/solr/suggestion/conf/schema.xml b/dspace/solr/suggestion/conf/schema.xml
new file mode 100644
index 0000000000..dc88df5736
--- /dev/null
+++ b/dspace/solr/suggestion/conf/schema.xml
@@ -0,0 +1,240 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+
+<!--
+    This is the DSpace "suggestion" core, which holds records of each imported
+    item suggestions coming from an external resoure.
+    Each search or view/download event is logged here.
+    See dspace-api:org.dspace.statistics.SolrLoggerServiceImpl.
+
+    You should find the extensively commented example schema distributed with
+    Solr in [Solr]/server/solr/configsets/_default/conf/.
+-->
+<schema name="suggestion" version="1.5">
+
+  <types>
+    
+    <fieldType name="string" class="solr.StrField" sortMissingLast="true" omitNorms="true"/>
+
+    <fieldType name="boolean" class="solr.BoolField" sortMissingLast="true" omitNorms="true"/>
+
+    <fieldType name="int" class="solr.IntPointField" omitNorms="true" positionIncrementGap="0" docValues="true"/>
+    <fieldType name="float" class="solr.FloatPointField" omitNorms="true" positionIncrementGap="0" docValues="true"/>
+    <fieldType name="long" class="solr.LongPointField" omitNorms="true" positionIncrementGap="0" docValues="true"/>
+    <fieldType name="double" class="solr.DoublePointField" omitNorms="true" positionIncrementGap="0" docValues="true"/>
+    <fieldType name="date" class="solr.DatePointField" omitNorms="true" positionIncrementGap="0" docValues="true"/>
+
+    <fieldType name="pint" class="solr.IntPointField" omitNorms="true" docValues="true"/>
+    <fieldType name="plong" class="solr.LongPointField" omitNorms="true" docValues="true"/>
+    <fieldType name="pfloat" class="solr.FloatPointField" omitNorms="true" docValues="true"/>
+    <fieldType name="pdouble" class="solr.DoublePointField" omitNorms="true" docValues="true"/>
+    <fieldType name="pdate" class="solr.DatePointField" sortMissingLast="true" omitNorms="true" docValues="true"/>
+
+    <fieldType name="sint" class="solr.IntPointField" sortMissingLast="true" omitNorms="true" docValues="true"/>
+    <fieldType name="slong" class="solr.LongPointField" sortMissingLast="true" omitNorms="true" docValues="true"/>
+    <fieldType name="sfloat" class="solr.FloatPointField" sortMissingLast="true" omitNorms="true" docValues="true"/>
+    <fieldType name="sdouble" class="solr.DoublePointField" sortMissingLast="true" omitNorms="true" docValues="true"/>
+
+    <fieldType name="random" class="solr.RandomSortField" indexed="true" />
+
+    <!-- A text field that only splits on whitespace for exact matching of words -->
+    <fieldType name="text_ws" class="solr.TextField" positionIncrementGap="100">
+      <analyzer>
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+      </analyzer>
+    </fieldType>
+
+    <!-- A text field that uses WordDelimiterFilter to enable splitting and matching of
+        words on case-change, alpha numeric boundaries, and non-alphanumeric chars,
+        so that a query of "wifi" or "wi fi" could match a document containing "Wi-Fi".
+        Synonyms and stopwords are customized by external files, and stemming is enabled.
+        Duplicate tokens at the same position (which may result from Stemmed Synonyms or
+        WordDelim parts) are removed.
+        -->
+   	<fieldType name="text" class="solr.TextField" positionIncrementGap="100">
+      <analyzer type="index">
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.StopFilterFactory"
+                ignoreCase="true"
+                words="stopwords.txt"
+                />
+        <filter class="solr.WordDelimiterFilterFactory"
+                generateWordParts="1"
+                generateNumberParts="1"
+                catenateWords="1"
+                catenateNumbers="1"
+                catenateAll="0"
+                splitOnCaseChange="1"/>
+        <filter class="org.apache.lucene.analysis.icu.ICUFoldingFilterFactory"/>
+        <filter class="solr.SnowballPorterFilterFactory" language="English" protected="protwords.txt"/>
+        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+      </analyzer>
+      <analyzer type="query">
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+        <filter class="solr.StopFilterFactory"
+                ignoreCase="true"
+                words="stopwords.txt"
+                />
+        <filter class="solr.WordDelimiterFilterFactory"
+                generateWordParts="1"
+                generateNumberParts="1"
+                catenateWords="0"
+                catenateNumbers="0"
+                catenateAll="0"
+                splitOnCaseChange="1"/>
+        <filter class="org.apache.lucene.analysis.icu.ICUFoldingFilterFactory"/>
+        <filter class="solr.SnowballPorterFilterFactory" language="English" protected="protwords.txt"/>
+        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+      </analyzer>
+    </fieldType>
+
+    <!-- Less flexible matching, but less false matches.  Probably not ideal for product names,
+         but may be good for SKUs.  Can insert dashes in the wrong place and still match. -->
+    <fieldType name="textTight" class="solr.TextField" positionIncrementGap="100" >
+      <analyzer>
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="false"/>
+        <filter class="solr.StopFilterFactory" ignoreCase="true" words="stopwords.txt"/>
+        <filter class="solr.WordDelimiterFilterFactory"
+                generateWordParts="0"
+                generateNumberParts="0"
+                catenateWords="1"
+                catenateNumbers="1"
+                catenateAll="0"/>
+        <filter class="solr.LowerCaseFilterFactory"/>
+        <filter class="solr.SnowballPorterFilterFactory" language="English" protected="protwords.txt"/>
+        <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+      </analyzer>
+    </fieldType>
+
+    <!-- A general unstemmed text field - good if one does not know the language of the field -->
+    <fieldType name="textgen" class="solr.TextField" positionIncrementGap="100">
+      <analyzer type="index">
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.StopFilterFactory"
+                ignoreCase="true"
+                words="stopwords.txt" />
+        <filter class="solr.WordDelimiterFilterFactory"
+                generateWordParts="1"
+                generateNumberParts="1"
+                catenateWords="1"
+                catenateNumbers="1"
+                catenateAll="0"
+                splitOnCaseChange="0"/>
+        <filter class="solr.LowerCaseFilterFactory"/>
+      </analyzer>
+      <analyzer type="query">
+        <tokenizer class="solr.WhitespaceTokenizerFactory"/>
+        <filter class="solr.SynonymFilterFactory" synonyms="synonyms.txt" ignoreCase="true" expand="true"/>
+        <filter class="solr.StopFilterFactory"
+                ignoreCase="true"
+                words="stopwords.txt"
+                />
+        <filter class="solr.WordDelimiterFilterFactory"
+                generateWordParts="1"
+                generateNumberParts="1"
+                catenateWords="0"
+                catenateNumbers="0"
+                catenateAll="0"
+                splitOnCaseChange="0"/>
+        <filter class="solr.LowerCaseFilterFactory"/>
+      </analyzer>
+    </fieldType>
+
+    <fieldtype name="ignored" stored="false" indexed="false" multiValued="true" class="solr.StrField" />
+
+    <fieldType name="lowerCaseSort" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+      <analyzer>
+        <tokenizer class="solr.KeywordTokenizerFactory"/>
+        <filter class="solr.LowerCaseFilterFactory" />
+        <filter class="solr.TrimFilterFactory" />
+      </analyzer>
+    </fieldType>
+
+    <fieldType name="keywordFilter" class="solr.TextField" sortMissingLast="true" omitNorms="true">
+        <analyzer>
+            <!--Treats the entire field as a single token, regardless of its content-->
+            <tokenizer class="solr.KeywordTokenizerFactory"/>
+
+            <!--<filter class="solr.LowerCaseFilterFactory" />-->
+            <filter class="solr.TrimFilterFactory" />
+        </analyzer>
+    </fieldType>
+
+    <!--
+     SpellCheck analysis config based off of http://wiki.apache.org/solr/
+     SpellCheckingAnalysis
+     -->
+    <fieldType name="textSpell" class="solr.TextField"
+               positionIncrementGap="100" stored="false" multiValued="true">
+        <analyzer type="index">
+            <tokenizer class="solr.StandardTokenizerFactory"/>
+            <filter class="solr.LowerCaseFilterFactory"/>
+            <filter class="solr.SynonymFilterFactory"
+                    synonyms="synonyms.txt" ignoreCase="true"
+                    expand="true"/>
+            <filter class="solr.StopFilterFactory" ignoreCase="true"
+                    words="stopwords.txt"/>
+            <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+        </analyzer>
+        <analyzer type="query">
+            <tokenizer class="solr.StandardTokenizerFactory"/>
+            <filter class="solr.LowerCaseFilterFactory"/>
+            <filter class="solr.StopFilterFactory" ignoreCase="true"
+                    words="stopwords.txt"/>
+            <filter class="solr.RemoveDuplicatesTokenFilterFactory"/>
+        </analyzer>
+    </fieldType>
+ </types>
+
+
+ <fields>
+ 
+ 	<field name="_version_" type="long" indexed="true" stored="true" multiValued="false"/>
+
+    <field name="source" type="string" indexed="true" stored="true" omitNorms="true" />
+    <field name="suggestion_fullid" type="string" indexed="true" stored="true" omitNorms="true" />
+    <field name="suggestion_id" type="string" indexed="true" stored="true" omitNorms="true" />
+    <field name="target_id" type="string" indexed="true" stored="true" omitNorms="true" />
+    <field name="title" type="string" indexed="true" stored="true" omitNorms="true" />
+    <field name="date" type="string" indexed="true" stored="true" omitNorms="true" />
+    <field name="display" type="string" indexed="true" stored="true" omitNorms="true" />
+    <field name="contributors" type="string" indexed="true" stored="true" omitNorms="true" multiValued="true" />
+    <field name="abstract" type="string" indexed="true" stored="true" omitNorms="true" />
+    <field name="category" type="string" indexed="true" stored="true" omitNorms="true" multiValued="true"/>
+    <field name="external-uri" type="string" indexed="true" stored="true" omitNorms="true" />
+    <field name="processed" type="boolean" indexed="true" stored="true" omitNorms="true" />
+    <field name="trust" type="double" indexed="true" stored="true" omitNorms="true" />
+    <field name="evidences" type="string" indexed="false" stored="true" omitNorms="true" />
+   	    
+   	<dynamicField name="*_i"  type="int"    indexed="true"  stored="true" multiValued="true" docValues="true"/>
+   	<dynamicField name="*_s"  type="string"  indexed="true"  stored="true" multiValued="true" docValues="true"/>
+   	<dynamicField name="*_l"  type="long"   indexed="true"  stored="true" multiValued="true" docValues="true"/>
+   	<dynamicField name="*_t"  type="text"    indexed="true"  stored="true" multiValued="true" />
+   	<dynamicField name="*_b"  type="boolean" indexed="true"  stored="true" multiValued="true" />
+   	<dynamicField name="*_f"  type="float"  indexed="true"  stored="true" multiValued="true" docValues="true"/>
+   	<dynamicField name="*_d"  type="double" indexed="true"  stored="true" multiValued="true" docValues="true"/>
+   	<dynamicField name="*_dt" type="date" indexed="true"  stored="true" multiValued="true"/>
+   	<dynamicField name="*_signature" type="string" indexed="true" stored="true" omitNorms="true" multiValued="true" docValues="true"/>
+       	
+ </fields>
+
+ <uniqueKey>suggestion_fullid</uniqueKey>
+ 
+</schema>
diff --git a/dspace/solr/suggestion/conf/solrconfig.xml b/dspace/solr/suggestion/conf/solrconfig.xml
new file mode 100644
index 0000000000..228b5f545e
--- /dev/null
+++ b/dspace/solr/suggestion/conf/solrconfig.xml
@@ -0,0 +1,131 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+<!--
+ Licensed to the Apache Software Foundation (ASF) under one or more
+ contributor license agreements.  See the NOTICE file distributed with
+ this work for additional information regarding copyright ownership.
+ The ASF licenses this file to You under the Apache License, Version 2.0
+ (the "License"); you may not use this file except in compliance with
+ the License.  You may obtain a copy of the License at
+
+     http://www.apache.org/licenses/LICENSE-2.0
+
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+-->
+
+<!--
+    DSpace 'suggestion' core.
+
+    For more details about configurations options that may appear in
+    this file, see http://wiki.apache.org/solr/SolrConfigXml. 
+-->
+<config>
+    <luceneMatchVersion>8.8.1</luceneMatchVersion>
+    
+    <!-- Include contributed libraries that we use in DSpace. -->
+    <lib dir='${solr.install.dir}/contrib/analysis-extras/lib/'
+         regex='icu4j-.*\.jar'/>
+    <lib dir='${solr.install.dir}/contrib/analysis-extras/lucene-libs/'
+         regex='lucene-analyzers-icu-.*\.jar'/>
+
+    <dataDir>${solr.data.dir:}</dataDir>
+
+    <directoryFactory name="DirectoryFactory"
+                      class="${solr.directoryFactory:solr.NRTCachingDirectoryFactory}"/>
+
+    <codecFactory class="solr.SchemaCodecFactory"/>
+
+    <!-- Use classic schema.xml & disallow programmatic changes to schema at runtime -->
+    <schemaFactory class="ClassicIndexSchemaFactory"/>
+
+    <indexConfig>
+        <ramBufferSizeMB>32</ramBufferSizeMB>
+        <maxBufferedDocs>1000</maxBufferedDocs>
+        <lockType>${solr.lock.type:native}</lockType>
+        <!-- Set to true to "write detailed debug information from the indexing process as Solr log messages" -->
+        <infoStream>false</infoStream>
+    </indexConfig>
+
+    <!-- Settings for how updates are done internally -->
+    <updateHandler class="solr.DirectUpdateHandler2">
+        <!-- How often should commits be done automatically -->
+        <autoCommit>
+            <maxDocs>10000</maxDocs> <!--Commit every 10.000 documents-->
+            <maxTime>${solr.autoCommit.maxTime:10000}</maxTime> <!--Default commit every 10 seconds-->
+            <openSearcher>true</openSearcher>
+        </autoCommit>
+
+        <autoSoftCommit>
+            <maxTime>${solr.autoSoftCommit.maxTime:-1}</maxTime>
+        </autoSoftCommit>
+        
+        <!-- This is required for Atomic Updates -->
+        <updateLog>
+            <str name="dir">${solr.ulog.dir:}</str>
+        </updateLog>
+    </updateHandler>
+
+    <!-- Settings for how Solr will process & respond to queries -->
+    <query>
+        <maxBooleanClauses>${solr.max.booleanClauses:1024}</maxBooleanClauses>
+
+        <!-- Cache used by SolrIndexSearcher for filters (DocSets) for
+                 unordered sets of *all* documents that match a query. Caches results of 'fq' search param. -->
+        <filterCache class="solr.search.CaffeineCache"
+                     size="512"
+                     initialSize="512"
+                     autowarmCount="0"/>
+
+        <!-- Caches results of previous searches - ordered lists of document ids
+         (DocList) based on a query, a sort, and the range of documents requested. -->
+        <queryResultCache class="solr.search.CaffeineCache"
+                          size="512"
+                          initialSize="512"
+                          autowarmCount="0"/>
+
+        <!-- Caches Lucene Document objects (the stored fields for each
+         document).  Since Lucene internal document ids are transient,
+         this cache will not be autowarmed. -->
+        <documentCache class="solr.search.CaffeineCache"
+                       size="512"
+                       initialSize="512"
+                       autowarmCount="0"/>
+
+        <enableLazyFieldLoading>true</enableLazyFieldLoading>
+        <queryResultWindowSize>20</queryResultWindowSize>
+        <queryResultMaxDocsCached>200</queryResultMaxDocsCached>
+        <useColdSearcher>false</useColdSearcher>
+        <maxWarmingSearchers>2</maxWarmingSearchers>
+    </query>
+
+    <!-- Controls how the Solr HTTP RequestDispatcher responds to requests -->
+    <requestDispatcher handleSelect="false" >
+        <requestParsers enableRemoteStreaming="true"
+                        multipartUploadLimitInKB="-1"
+                        formdataUploadLimitInKB="-1"
+                        addHttpRequestToContext="false"/>
+
+        <httpCaching never304="true" />
+    </requestDispatcher>
+
+    <!-- Process requests to /select path -->
+    <requestHandler name="/select" class="solr.SearchHandler">
+     <lst name="defaults">
+       <str name="echoParams">explicit</str>
+       <int name="rows">10</int>
+       <str name="df">suggestion_id</str>
+     </lst>
+    </requestHandler>
+
+    <!-- Processes updates to the index -->
+    <requestHandler name="/update" class="solr.UpdateRequestHandler"/>
+
+    <requestHandler name="/update/json" class="solr.UpdateRequestHandler">
+        <lst name="defaults">
+            <str name="stream.contentType">application/json</str>
+        </lst>
+    </requestHandler>
+</config>
diff --git a/dspace/solr/suggestion/conf/stopwords.txt b/dspace/solr/suggestion/conf/stopwords.txt
new file mode 100644
index 0000000000..8433c832d2
--- /dev/null
+++ b/dspace/solr/suggestion/conf/stopwords.txt
@@ -0,0 +1,57 @@
+# Licensed to the Apache Software Foundation (ASF) under one or more
+# contributor license agreements.  See the NOTICE file distributed with
+# this work for additional information regarding copyright ownership.
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#-----------------------------------------------------------------------
+# a couple of test stopwords to test that the words are really being
+# configured from this file:
+stopworda
+stopwordb
+
+#Standard english stop words taken from Lucene's StopAnalyzer
+an
+and
+are
+as
+at
+be
+but
+by
+for
+if
+in
+into
+is
+it
+no
+not
+of
+on
+or
+s
+such
+t
+that
+the
+their
+then
+there
+these
+they
+this
+to
+was
+will
+with
+
diff --git a/dspace/solr/suggestion/conf/synonyms.txt b/dspace/solr/suggestion/conf/synonyms.txt
new file mode 100644
index 0000000000..b0e31cb7ec
--- /dev/null
+++ b/dspace/solr/suggestion/conf/synonyms.txt
@@ -0,0 +1,31 @@
+# The ASF licenses this file to You under the Apache License, Version 2.0
+# (the "License"); you may not use this file except in compliance with
+# the License.  You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+#-----------------------------------------------------------------------
+#some test synonym mappings unlikely to appear in real input text
+aaa => aaaa
+bbb => bbbb1 bbbb2
+ccc => cccc1,cccc2
+a\=>a => b\=>b
+a\,a => b\,b
+fooaaa,baraaa,bazaaa
+
+# Some synonym groups specific to this example
+GB,gib,gigabyte,gigabytes
+MB,mib,megabyte,megabytes
+Television, Televisions, TV, TVs
+#notice we use "gib" instead of "GiB" so any WordDelimiterFilter coming
+#after us won't split it into two words.
+
+# Synonym mappings can be used for spelling correction too
+pixima => pixma
+
diff --git a/dspace/solr/suggestion/core.properties b/dspace/solr/suggestion/core.properties
new file mode 100644
index 0000000000..e69de29bb2
diff --git a/dspace/src/main/docker/dspace-solr/Dockerfile b/dspace/src/main/docker/dspace-solr/Dockerfile
index 9fe9adf944..187d404382 100644
--- a/dspace/src/main/docker/dspace-solr/Dockerfile
+++ b/dspace/src/main/docker/dspace-solr/Dockerfile
@@ -17,19 +17,25 @@ FROM solr:${SOLR_VERSION}-slim
 ENV AUTHORITY_CONFIGSET_PATH=/opt/solr/server/solr/configsets/authority/conf \
     OAI_CONFIGSET_PATH=/opt/solr/server/solr/configsets/oai/conf \
     SEARCH_CONFIGSET_PATH=/opt/solr/server/solr/configsets/search/conf \
-    STATISTICS_CONFIGSET_PATH=/opt/solr/server/solr/configsets/statistics/conf
+    STATISTICS_CONFIGSET_PATH=/opt/solr/server/solr/configsets/statistics/conf \
+    QAEVENT_CONFIGSET_PATH=/opt/solr/server/solr/configsets/qaevent/conf  \
+    SUGGESTION_CONFIGSET_PATH=/opt/solr/server/solr/configsets/suggestion/conf
 
 USER root
 
 RUN mkdir -p $AUTHORITY_CONFIGSET_PATH && \
     mkdir -p $OAI_CONFIGSET_PATH && \
     mkdir -p $SEARCH_CONFIGSET_PATH && \
-    mkdir -p $STATISTICS_CONFIGSET_PATH
+    mkdir -p $STATISTICS_CONFIGSET_PATH && \
+    mkdir -p $QAEVENT_CONFIGSET_PATH && \
+    mkdir -p $SUGGESTION_CONFIGSET_PATH
 
 COPY dspace/solr/authority/conf/* $AUTHORITY_CONFIGSET_PATH/
 COPY dspace/solr/oai/conf/* $OAI_CONFIGSET_PATH/
 COPY dspace/solr/search/conf/* $SEARCH_CONFIGSET_PATH/
 COPY dspace/solr/statistics/conf/* $STATISTICS_CONFIGSET_PATH/
+COPY dspace/solr/qaevent/conf/* $QAEVENT_CONFIGSET_PATH/
+COPY dspace/solr/suggestion/conf/* $SUGGESTION_CONFIGSET_PATH
 
 RUN chown -R solr:solr /opt/solr/server/solr/configsets
 
